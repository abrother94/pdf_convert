cscope 15 $HOME/pdf_convert/E_OMCI -q 0000001994 0000492495
	@build/CMakeFiles/3.5.2/CompilerIdC/CMakeCCompilerId.c

1 #ifde
__lulus


5 #i
defed
(
__18CXX
)

6 
	#ID_VOID_MAIN


	)

13 #i
defed
(
__INTEL_COMPILER
|| defed(
__ICC
)

14 
	#COMPILER_ID
 "I"

	)

15 #i
defed
(
_MSC_VER
)

16 
	#SIMULATE_ID
 "MSVC"

	)

19 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

20 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

21 #i
defed
(
__INTEL_COMPILER_UPDATE
)

22 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

24 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

26 #i
defed
(
__INTEL_COMPILER_BUILD_DATE
)

28 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

30 #i
defed
(
_MSC_VER
)

32 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

33 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

36 #i
defed
(
__PATHCC__
)

37 
	#COMPILER_ID
 "PhS"

	)

38 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

39 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

40 #i
defed
(
__PATHCC_PATCHLEVEL__
)

41 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

44 #i
defed
(
__BORLANDC__
&& defed(
__CODEGEARC_VERSION__
)

45 
	#COMPILER_ID
 "Embdo"

	)

46 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

47 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

48 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

50 #i
defed
(
__BORLANDC__
)

51 
	#COMPILER_ID
 "Bnd"

	)

53 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

54 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

56 #i
defed
(
__WATCOMC__
) && __WATCOMC__ < 1200

57 
	#COMPILER_ID
 "Wcom"

	)

59 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

60 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10% 10)

	)

61 #i(
__WATCOMC__
 % 10) > 0

62 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

65 #i
defed
(
__WATCOMC__
)

66 
	#COMPILER_ID
 "OnWcom"

	)

68 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100/ 100)

	)

69 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10% 10)

	)

70 #i(
__WATCOMC__
 % 10) > 0

71 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

74 #i
defed
(
__SUNPRO_C
)

75 
	#COMPILER_ID
 "SunPro"

	)

76 #i
__SUNPRO_C
 >= 0x5100

78 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>12)

	)

79 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xFF)

	)

80 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

83 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>8)

	)

84 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xF)

	)

85 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

88 #i
defed
(
__HP_cc
)

89 
	#COMPILER_ID
 "HP"

	)

91 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_cc
/10000)

	)

92 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_cc
/100 % 100)

	)

93 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_cc
 % 100)

	)

95 #i
defed
(
__DECC
)

96 
	#COMPILER_ID
 "Comq"

	)

98 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECC_VER
/10000000)

	)

99 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECC_VER
/100000 % 100)

	)

100 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECC_VER
 % 10000)

	)

102 #i
defed
(
__IBMC__
&& defed(
__COMPILER_VER__
)

103 
	#COMPILER_ID
 "zOS"

	)

105 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

106 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

107 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

109 #i
defed
(
__IBMC__
&& !defed(
__COMPILER_VER__
) && __IBMC__ >= 800

110 
	#COMPILER_ID
 "XL"

	)

112 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

113 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

114 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

116 #i
defed
(
__IBMC__
&& !defed(
__COMPILER_VER__
) && __IBMC__ < 800

117 
	#COMPILER_ID
 "VisuAge"

	)

119 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

120 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

121 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

123 #i
defed
(
__PGI
)

124 
	#COMPILER_ID
 "PGI"

	)

125 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

126 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

127 #i
defed
(
__PGIC_PATCHLEVEL__
)

128 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

131 #i
defed
(
_CRAYC
)

132 
	#COMPILER_ID
 "Cy"

	)

133 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

134 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

136 #i
defed
(
__TI_COMPILER_VERSION__
)

137 
	#COMPILER_ID
 "TI"

	)

139 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

140 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

141 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

143 #i
defed
(
__FUJITSU
|| defed(
__FCC_VERSION
|| defed(
__fcc_vsi
)

144 
	#COMPILER_ID
 "Fujsu"

	)

146 #i
defed
(
__TINYC__
)

147 
	#COMPILER_ID
 "TyCC"

	)

149 #i
defed
(
__SCO_VERSION__
)

150 
	#COMPILER_ID
 "SCO"

	)

152 #i
defed
(
__g__
&& defed(
__e_bud_vsi__
)

153 
	#COMPILER_ID
 "ACng"

	)

154 #i
defed
(
_MSC_VER
)

155 
	#SIMULATE_ID
 "MSVC"

	)

157 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__g_maj__
)

	)

158 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__g_m__
)

	)

159 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__g_tchv__
)

	)

160 #i
defed
(
_MSC_VER
)

162 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

163 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

165 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__e_bud_vsi__
)

	)

167 #i
defed
(
__g__
)

168 
	#COMPILER_ID
 "Cng"

	)

169 #i
defed
(
_MSC_VER
)

170 
	#SIMULATE_ID
 "MSVC"

	)

172 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__g_maj__
)

	)

173 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__g_m__
)

	)

174 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__g_tchv__
)

	)

175 #i
defed
(
_MSC_VER
)

177 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

178 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

181 #i
defed
(
__GNUC__
)

182 
	#COMPILER_ID
 "GNU"

	)

183 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

184 #i
defed
(
__GNUC_MINOR__
)

185 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

187 #i
defed
(
__GNUC_PATCHLEVEL__
)

188 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

191 #i
defed
(
_MSC_VER
)

192 
	#COMPILER_ID
 "MSVC"

	)

194 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

195 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

196 #i
defed
(
_MSC_FULL_VER
)

197 #i
_MSC_VER
 >= 1400

199 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

202 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

205 #i
defed
(
_MSC_BUILD
)

206 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

209 #i
defed
(
__VISUALDSPVERSION__
|| defed(
__ADSPBLACKFIN__
|| defed(
__ADSPTS__
|| defed(
__ADSP21000__
)

210 
	#COMPILER_ID
 "ADSP"

	)

211 #i
defed
(
__VISUALDSPVERSION__
)

213 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__VISUALDSPVERSION__
>>24)

	)

214 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__VISUALDSPVERSION__
>>16 & 0xFF)

	)

215 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__VISUALDSPVERSION__
>>8 & 0xFF)

	)

218 #i
defed
(
__IAR_SYSTEMS_ICC__
 ) || defed(
__IAR_SYSTEMS_ICC
)

219 
	#COMPILER_ID
 "IAR"

	)

221 #i
defed
(
__ARMCC_VERSION
)

222 
	#COMPILER_ID
 "ARMCC"

	)

223 #i
__ARMCC_VERSION
 >= 1000000

225 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

226 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

227 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

230 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

231 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

232 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

236 #i
defed
(
SDCC
)

237 
	#COMPILER_ID
 "SDCC"

	)

239 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
SDCC
/100)

	)

240 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
SDCC
/10 % 10)

	)

241 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
SDCC
 % 10)

	)

243 #i
defed
(
_SGI_COMPILER_VERSION
|| defed(
_COMPILER_VERSION
)

244 
	#COMPILER_ID
 "MIPSo"

	)

245 #i
defed
(
_SGI_COMPILER_VERSION
)

247 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_SGI_COMPILER_VERSION
/100)

	)

248 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_SGI_COMPILER_VERSION
/10 % 10)

	)

249 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_SGI_COMPILER_VERSION
 % 10)

	)

252 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_COMPILER_VERSION
/100)

	)

253 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_COMPILER_VERSION
/10 % 10)

	)

254 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_COMPILER_VERSION
 % 10)

	)

261 #i
defed
(
__sgi
)

262 
	#COMPILER_ID
 "MIPSo"

	)

264 #i
defed
(
__hpux
|| defed(
__hpua
)

265 
	#COMPILER_ID
 "HP"

	)

268 
	#COMPILER_ID
 ""

	)

275 cڡ* 
	gfo_comp
 = "INFO" ":" "comp[" 
COMPILER_ID
 "]";

276 #ifde
SIMULATE_ID


277 cڡ* 
	gfo_simuϋ
 = "INFO" ":" "simuϋ[" 
SIMULATE_ID
 "]";

280 #ifde
__QNXNTO__


281 cڡ* 
	gqnxo
 = "INFO" ":" "qnxnto[]";

284 #i
defed
(
__CRAYXE
|| defed(
__CRAYXC
)

285 cڡ *
	gfo_ay
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

288 
	#STRINGIFY_HELPER
(
X
#X

	)

289 
	#STRINGIFY
(
X

	`STRINGIFY_HELPER
(X)

	)

292 #i
defed
(
__lux
|| defed(
__lux__
|| defed(
lux
)

293 
	#PLATFORM_ID
 "Lux"

	)

295 #i
defed
(
__CYGWIN__
)

296 
	#PLATFORM_ID
 "Cygw"

	)

298 #i
defed
(
__MINGW32__
)

299 
	#PLATFORM_ID
 "MGW"

	)

301 #i
defed
(
__APPLE__
)

302 
	#PLATFORM_ID
 "Dw"

	)

304 #i
defed
(
_WIN32
|| defed(
__WIN32__
|| defed(
WIN32
)

305 
	#PLATFORM_ID
 "Wdows"

	)

307 #i
defed
(
__FeBSD__
|| defed(
__FeBSD
)

308 
	#PLATFORM_ID
 "FeBSD"

	)

310 #i
defed
(
__NBSD__
|| defed(
__NBSD
)

311 
	#PLATFORM_ID
 "NBSD"

	)

313 #i
defed
(
__OnBSD__
|| defed(
__OPENBSD
)

314 
	#PLATFORM_ID
 "OnBSD"

	)

316 #i
defed
(
__sun
|| defed(
sun
)

317 
	#PLATFORM_ID
 "SunOS"

	)

319 #i
defed
(
_AIX
|| defed(
__AIX
|| defed(
__AIX__
|| defed(
__aix
|| defed(
__aix__
)

320 
	#PLATFORM_ID
 "AIX"

	)

322 #i
defed
(
__sgi
|| defed(
__sgi__
|| defed(
_SGI
)

323 
	#PLATFORM_ID
 "IRIX"

	)

325 #i
defed
(
__hpux
|| defed(
__hpux__
)

326 
	#PLATFORM_ID
 "HP-UX"

	)

328 #i
defed
(
__HAIKU__
)

329 
	#PLATFORM_ID
 "Haiku"

	)

331 #i
defed
(
__BeOS
|| defed(
__BEOS__
|| defed(
_BEOS
)

332 
	#PLATFORM_ID
 "BeOS"

	)

334 #i
defed
(
__QNX__
|| defed(
__QNXNTO__
)

335 
	#PLATFORM_ID
 "QNX"

	)

337 #i
defed
(
__u64
|| defed(
_u64
|| defed(
__TRU64__
)

338 
	#PLATFORM_ID
 "Tru64"

	)

340 #i
defed
(
__riscos
|| defed(
__riscos__
)

341 
	#PLATFORM_ID
 "RISCos"

	)

343 #i
defed
(
__six
|| defed(
__six__
|| defed(
__SINIX__
)

344 
	#PLATFORM_ID
 "SINIX"

	)

346 #i
defed
(
__UNIX_SV__
)

347 
	#PLATFORM_ID
 "UNIX_SV"

	)

349 #i
defed
(
__bsdos__
)

350 
	#PLATFORM_ID
 "BSDOS"

	)

352 #i
defed
(
_MPRAS
|| defed(
MPRAS
)

353 
	#PLATFORM_ID
 "MP-RAS"

	)

355 #i
defed
(
__osf
|| defed(
__osf__
)

356 
	#PLATFORM_ID
 "OSF1"

	)

358 #i
defed
(
_SCO_SV
|| defed(
SCO_SV
|| defed(
sco_sv
)

359 
	#PLATFORM_ID
 "SCO_SV"

	)

361 #i
defed
(
__urix
|| defed(
__urix__
|| defed(
_ULTRIX
)

362 
	#PLATFORM_ID
 "ULTRIX"

	)

364 #i
defed
(
__XENIX__
|| defed(
_XENIX
|| defed(
XENIX
)

365 
	#PLATFORM_ID
 "Xix"

	)

367 #i
defed
(
__WATCOMC__
)

368 #i
defed
(
__LINUX__
)

369 
	#PLATFORM_ID
 "Lux"

	)

371 #i
defed
(
__DOS__
)

372 
	#PLATFORM_ID
 "DOS"

	)

374 #i
defed
(
__OS2__
)

375 
	#PLATFORM_ID
 "OS2"

	)

377 #i
defed
(
__WINDOWS__
)

378 
	#PLATFORM_ID
 "Wdows3x"

	)

381 
	#PLATFORM_ID
 ""

	)

385 
	#PLATFORM_ID
 ""

	)

394 #i
defed
(
_WIN32
&& defed(
_MSC_VER
)

395 #i
defed
(
_M_IA64
)

396 
	#ARCHITECTURE_ID
 "IA64"

	)

398 #i
defed
(
_M_X64
|| defed(
_M_AMD64
)

399 
	#ARCHITECTURE_ID
 "x64"

	)

401 #i
defed
(
_M_IX86
)

402 
	#ARCHITECTURE_ID
 "X86"

	)

404 #i
defed
(
_M_ARM
)

405 #i
_M_ARM
 == 4

406 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

407 #i
_M_ARM
 == 5

408 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

410 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

413 #i
defed
(
_M_MIPS
)

414 
	#ARCHITECTURE_ID
 "MIPS"

	)

416 #i
defed
(
_M_SH
)

417 
	#ARCHITECTURE_ID
 "SHx"

	)

420 
	#ARCHITECTURE_ID
 ""

	)

423 #i
defed
(
__WATCOMC__
)

424 #i
defed
(
_M_I86
)

425 
	#ARCHITECTURE_ID
 "I86"

	)

427 #i
defed
(
_M_IX86
)

428 
	#ARCHITECTURE_ID
 "X86"

	)

431 
	#ARCHITECTURE_ID
 ""

	)

435 
	#ARCHITECTURE_ID
 ""

	)

439 
	#DEC
(
n
) \

440 ('0' + (((
n
) / 10000000)%10)), \

441 ('0' + (((
n
) / 1000000)%10)), \

442 ('0' + (((
n
) / 100000)%10)), \

443 ('0' + (((
n
) / 10000)%10)), \

444 ('0' + (((
n
) / 1000)%10)), \

445 ('0' + (((
n
) / 100)%10)), \

446 ('0' + (((
n
) / 10)%10)), \

447 ('0' + ((
n
% 10))

	)

450 
	#HEX
(
n
) \

451 ('0' + ((
n
)>>28 & 0xF)), \

452 ('0' + ((
n
)>>24 & 0xF)), \

453 ('0' + ((
n
)>>20 & 0xF)), \

454 ('0' + ((
n
)>>16 & 0xF)), \

455 ('0' + ((
n
)>>12 & 0xF)), \

456 ('0' + ((
n
)>>8 & 0xF)), \

457 ('0' + ((
n
)>>4 & 0xF)), \

458 ('0' + ((
n
& 0xF))

	)

461 #ifde
COMPILER_VERSION_MAJOR


462 cڡ 
	gfo_vsi
[] = {

465 
COMPILER_VERSION_MAJOR
,

466 #ifde
COMPILER_VERSION_MINOR


467 '.', 
COMPILER_VERSION_MINOR
,

468 #ifde
COMPILER_VERSION_PATCH


469 '.', 
COMPILER_VERSION_PATCH
,

470 #ifde
COMPILER_VERSION_TWEAK


471 '.', 
COMPILER_VERSION_TWEAK
,

479 #ifde
SIMULATE_VERSION_MAJOR


480 cڡ 
	gfo_simuϋ_vsi
[] = {

483 
SIMULATE_VERSION_MAJOR
,

484 #ifde
SIMULATE_VERSION_MINOR


485 '.', 
SIMULATE_VERSION_MINOR
,

486 #ifde
SIMULATE_VERSION_PATCH


487 '.', 
SIMULATE_VERSION_PATCH
,

488 #ifde
SIMULATE_VERSION_TWEAK


489 '.', 
SIMULATE_VERSION_TWEAK
,

500 cڡ* 
	gfo_fm
 = "INFO" ":" "fm[" 
PLATFORM_ID
 "]";

501 cڡ* 
	gfo_ch
 = "INFO" ":" "ch[" 
ARCHITECTURE_ID
 "]";

506 cڡ * 
	gfo_nguage_d_deu
 = "INFO" ":" "dialect_default["

507 #i!
defed
(
__STDC_VERSION__
)

509 #i
__STDC_VERSION__
 >= 201000L

511 #i
__STDC_VERSION__
 >= 199901L

519 #ifde
ID_VOID_MAIN


520 
	$ma
({
	}
}

522 
	$ma
(
gc
, * 
gv
[])

524 
que
 = 0;

525 
que
 +
fo_comp
[
gc
];

526 
que
 +
fo_fm
[
gc
];

527 
que
 +
fo_ch
[
gc
];

528 #ifde
COMPILER_VERSION_MAJOR


529 
que
 +
fo_vsi
[
gc
];

531 #ifde
SIMULATE_ID


532 
que
 +
fo_simuϋ
[
gc
];

534 #ifde
SIMULATE_VERSION_MAJOR


535 
que
 +
fo_simuϋ_vsi
[
gc
];

537 #i
	`defed
(
__CRAYXE
|| defed(
__CRAYXC
)

538 
que
 +
fo_ay
[
gc
];

540 
que
 +
fo_nguage_d_deu
[
gc
];

541 ()
gv
;

542  
que
;

543 
	}
}

	@build/CMakeFiles/3.5.2/CompilerIdCXX/CMakeCXXCompilerId.cpp

4 #ide
__lulus


12 #i
defed
(
__COMO__
)

13 
	#COMPILER_ID
 "Comu"

	)

15 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__COMO_VERSION__
 / 100)

	)

16 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__COMO_VERSION__
 % 100)

	)

18 #i
defed
(
__INTEL_COMPILER
|| defed(
__ICC
)

19 
	#COMPILER_ID
 "I"

	)

20 #i
defed
(
_MSC_VER
)

21 
	#SIMULATE_ID
 "MSVC"

	)

24 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

25 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

26 #i
defed
(
__INTEL_COMPILER_UPDATE
)

27 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

29 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

31 #i
defed
(
__INTEL_COMPILER_BUILD_DATE
)

33 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

35 #i
defed
(
_MSC_VER
)

37 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

38 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

41 #i
defed
(
__PATHCC__
)

42 
	#COMPILER_ID
 "PhS"

	)

43 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

44 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

45 #i
defed
(
__PATHCC_PATCHLEVEL__
)

46 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

49 #i
defed
(
__BORLANDC__
&& defed(
__CODEGEARC_VERSION__
)

50 
	#COMPILER_ID
 "Embdo"

	)

51 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

52 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

53 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

55 #i
defed
(
__BORLANDC__
)

56 
	#COMPILER_ID
 "Bnd"

	)

58 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

59 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

61 #i
defed
(
__WATCOMC__
) && __WATCOMC__ < 1200

62 
	#COMPILER_ID
 "Wcom"

	)

64 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

65 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10% 10)

	)

66 #i(
__WATCOMC__
 % 10) > 0

67 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

70 #i
defed
(
__WATCOMC__
)

71 
	#COMPILER_ID
 "OnWcom"

	)

73 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100/ 100)

	)

74 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10% 10)

	)

75 #i(
__WATCOMC__
 % 10) > 0

76 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

79 #i
defed
(
__SUNPRO_CC
)

80 
	#COMPILER_ID
 "SunPro"

	)

81 #i
__SUNPRO_CC
 >= 0x5100

83 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>12)

	)

84 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xFF)

	)

85 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

88 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>8)

	)

89 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xF)

	)

90 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

93 #i
defed
(
__HP_aCC
)

94 
	#COMPILER_ID
 "HP"

	)

96 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_aCC
/10000)

	)

97 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_aCC
/100 % 100)

	)

98 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_aCC
 % 100)

	)

100 #i
defed
(
__DECCXX
)

101 
	#COMPILER_ID
 "Comq"

	)

103 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECCXX_VER
/10000000)

	)

104 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECCXX_VER
/100000 % 100)

	)

105 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECCXX_VER
 % 10000)

	)

107 #i
defed
(
__IBMCPP__
&& defed(
__COMPILER_VER__
)

108 
	#COMPILER_ID
 "zOS"

	)

110 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

111 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

112 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

114 #i
defed
(
__IBMCPP__
&& !defed(
__COMPILER_VER__
) && __IBMCPP__ >= 800

115 
	#COMPILER_ID
 "XL"

	)

117 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

118 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

119 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

121 #i
defed
(
__IBMCPP__
&& !defed(
__COMPILER_VER__
) && __IBMCPP__ < 800

122 
	#COMPILER_ID
 "VisuAge"

	)

124 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

125 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

126 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

128 #i
defed
(
__PGI
)

129 
	#COMPILER_ID
 "PGI"

	)

130 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

131 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

132 #i
defed
(
__PGIC_PATCHLEVEL__
)

133 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

136 #i
defed
(
_CRAYC
)

137 
	#COMPILER_ID
 "Cy"

	)

138 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

139 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

141 #i
defed
(
__TI_COMPILER_VERSION__
)

142 
	#COMPILER_ID
 "TI"

	)

144 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

145 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

146 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

148 #i
defed
(
__FUJITSU
|| defed(
__FCC_VERSION
|| defed(
__fcc_vsi
)

149 
	#COMPILER_ID
 "Fujsu"

	)

151 #i
defed
(
__SCO_VERSION__
)

152 
	#COMPILER_ID
 "SCO"

	)

154 #i
defed
(
__g__
&& defed(
__e_bud_vsi__
)

155 
	#COMPILER_ID
 "ACng"

	)

156 #i
defed
(
_MSC_VER
)

157 
	#SIMULATE_ID
 "MSVC"

	)

159 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__g_maj__
)

	)

160 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__g_m__
)

	)

161 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__g_tchv__
)

	)

162 #i
defed
(
_MSC_VER
)

164 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

165 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

167 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__e_bud_vsi__
)

	)

169 #i
defed
(
__g__
)

170 
	#COMPILER_ID
 "Cng"

	)

171 #i
defed
(
_MSC_VER
)

172 
	#SIMULATE_ID
 "MSVC"

	)

174 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__g_maj__
)

	)

175 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__g_m__
)

	)

176 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__g_tchv__
)

	)

177 #i
defed
(
_MSC_VER
)

179 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

180 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

183 #i
defed
(
__GNUC__
)

184 
	#COMPILER_ID
 "GNU"

	)

185 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

186 #i
defed
(
__GNUC_MINOR__
)

187 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

189 #i
defed
(
__GNUC_PATCHLEVEL__
)

190 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

193 #i
defed
(
_MSC_VER
)

194 
	#COMPILER_ID
 "MSVC"

	)

196 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

197 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

198 #i
defed
(
_MSC_FULL_VER
)

199 #i
_MSC_VER
 >= 1400

201 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

204 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

207 #i
defed
(
_MSC_BUILD
)

208 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

211 #i
defed
(
__VISUALDSPVERSION__
|| defed(
__ADSPBLACKFIN__
|| defed(
__ADSPTS__
|| defed(
__ADSP21000__
)

212 
	#COMPILER_ID
 "ADSP"

	)

213 #i
defed
(
__VISUALDSPVERSION__
)

215 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__VISUALDSPVERSION__
>>24)

	)

216 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__VISUALDSPVERSION__
>>16 & 0xFF)

	)

217 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__VISUALDSPVERSION__
>>8 & 0xFF)

	)

220 #i
defed
(
__IAR_SYSTEMS_ICC__
 ) || defed(
__IAR_SYSTEMS_ICC
)

221 
	#COMPILER_ID
 "IAR"

	)

223 #i
defed
(
__ARMCC_VERSION
)

224 
	#COMPILER_ID
 "ARMCC"

	)

225 #i
__ARMCC_VERSION
 >= 1000000

227 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

228 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

229 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

232 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

233 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

234 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

238 #i
defed
(
_SGI_COMPILER_VERSION
|| defed(
_COMPILER_VERSION
)

239 
	#COMPILER_ID
 "MIPSo"

	)

240 #i
defed
(
_SGI_COMPILER_VERSION
)

242 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_SGI_COMPILER_VERSION
/100)

	)

243 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_SGI_COMPILER_VERSION
/10 % 10)

	)

244 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_SGI_COMPILER_VERSION
 % 10)

	)

247 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_COMPILER_VERSION
/100)

	)

248 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_COMPILER_VERSION
/10 % 10)

	)

249 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_COMPILER_VERSION
 % 10)

	)

256 #i
defed
(
__sgi
)

257 
	#COMPILER_ID
 "MIPSo"

	)

259 #i
defed
(
__hpux
|| defed(
__hpua
)

260 
	#COMPILER_ID
 "HP"

	)

263 
	#COMPILER_ID
 ""

	)

270 cڡ* 
	gfo_comp
 = "INFO" ":" "comp[" 
COMPILER_ID
 "]";

271 #ifde
SIMULATE_ID


272 cڡ* 
	gfo_simuϋ
 = "INFO" ":" "simuϋ[" 
SIMULATE_ID
 "]";

275 #ifde
__QNXNTO__


276 cڡ* 
	gqnxo
 = "INFO" ":" "qnxnto[]";

279 #i
defed
(
__CRAYXE
|| defed(
__CRAYXC
)

280 cڡ *
	gfo_ay
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

283 
	#STRINGIFY_HELPER
(
X
#X

	)

284 
	#STRINGIFY
(
X

	`STRINGIFY_HELPER
(X)

	)

287 #i
defed
(
__lux
|| defed(
__lux__
|| defed(
lux
)

288 
	#PLATFORM_ID
 "Lux"

	)

290 #i
defed
(
__CYGWIN__
)

291 
	#PLATFORM_ID
 "Cygw"

	)

293 #i
defed
(
__MINGW32__
)

294 
	#PLATFORM_ID
 "MGW"

	)

296 #i
defed
(
__APPLE__
)

297 
	#PLATFORM_ID
 "Dw"

	)

299 #i
defed
(
_WIN32
|| defed(
__WIN32__
|| defed(
WIN32
)

300 
	#PLATFORM_ID
 "Wdows"

	)

302 #i
defed
(
__FeBSD__
|| defed(
__FeBSD
)

303 
	#PLATFORM_ID
 "FeBSD"

	)

305 #i
defed
(
__NBSD__
|| defed(
__NBSD
)

306 
	#PLATFORM_ID
 "NBSD"

	)

308 #i
defed
(
__OnBSD__
|| defed(
__OPENBSD
)

309 
	#PLATFORM_ID
 "OnBSD"

	)

311 #i
defed
(
__sun
|| defed(
sun
)

312 
	#PLATFORM_ID
 "SunOS"

	)

314 #i
defed
(
_AIX
|| defed(
__AIX
|| defed(
__AIX__
|| defed(
__aix
|| defed(
__aix__
)

315 
	#PLATFORM_ID
 "AIX"

	)

317 #i
defed
(
__sgi
|| defed(
__sgi__
|| defed(
_SGI
)

318 
	#PLATFORM_ID
 "IRIX"

	)

320 #i
defed
(
__hpux
|| defed(
__hpux__
)

321 
	#PLATFORM_ID
 "HP-UX"

	)

323 #i
defed
(
__HAIKU__
)

324 
	#PLATFORM_ID
 "Haiku"

	)

326 #i
defed
(
__BeOS
|| defed(
__BEOS__
|| defed(
_BEOS
)

327 
	#PLATFORM_ID
 "BeOS"

	)

329 #i
defed
(
__QNX__
|| defed(
__QNXNTO__
)

330 
	#PLATFORM_ID
 "QNX"

	)

332 #i
defed
(
__u64
|| defed(
_u64
|| defed(
__TRU64__
)

333 
	#PLATFORM_ID
 "Tru64"

	)

335 #i
defed
(
__riscos
|| defed(
__riscos__
)

336 
	#PLATFORM_ID
 "RISCos"

	)

338 #i
defed
(
__six
|| defed(
__six__
|| defed(
__SINIX__
)

339 
	#PLATFORM_ID
 "SINIX"

	)

341 #i
defed
(
__UNIX_SV__
)

342 
	#PLATFORM_ID
 "UNIX_SV"

	)

344 #i
defed
(
__bsdos__
)

345 
	#PLATFORM_ID
 "BSDOS"

	)

347 #i
defed
(
_MPRAS
|| defed(
MPRAS
)

348 
	#PLATFORM_ID
 "MP-RAS"

	)

350 #i
defed
(
__osf
|| defed(
__osf__
)

351 
	#PLATFORM_ID
 "OSF1"

	)

353 #i
defed
(
_SCO_SV
|| defed(
SCO_SV
|| defed(
sco_sv
)

354 
	#PLATFORM_ID
 "SCO_SV"

	)

356 #i
defed
(
__urix
|| defed(
__urix__
|| defed(
_ULTRIX
)

357 
	#PLATFORM_ID
 "ULTRIX"

	)

359 #i
defed
(
__XENIX__
|| defed(
_XENIX
|| defed(
XENIX
)

360 
	#PLATFORM_ID
 "Xix"

	)

362 #i
defed
(
__WATCOMC__
)

363 #i
defed
(
__LINUX__
)

364 
	#PLATFORM_ID
 "Lux"

	)

366 #i
defed
(
__DOS__
)

367 
	#PLATFORM_ID
 "DOS"

	)

369 #i
defed
(
__OS2__
)

370 
	#PLATFORM_ID
 "OS2"

	)

372 #i
defed
(
__WINDOWS__
)

373 
	#PLATFORM_ID
 "Wdows3x"

	)

376 
	#PLATFORM_ID
 ""

	)

380 
	#PLATFORM_ID
 ""

	)

389 #i
defed
(
_WIN32
&& defed(
_MSC_VER
)

390 #i
defed
(
_M_IA64
)

391 
	#ARCHITECTURE_ID
 "IA64"

	)

393 #i
defed
(
_M_X64
|| defed(
_M_AMD64
)

394 
	#ARCHITECTURE_ID
 "x64"

	)

396 #i
defed
(
_M_IX86
)

397 
	#ARCHITECTURE_ID
 "X86"

	)

399 #i
defed
(
_M_ARM
)

400 #i
_M_ARM
 == 4

401 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

402 #i
_M_ARM
 == 5

403 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

405 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

408 #i
defed
(
_M_MIPS
)

409 
	#ARCHITECTURE_ID
 "MIPS"

	)

411 #i
defed
(
_M_SH
)

412 
	#ARCHITECTURE_ID
 "SHx"

	)

415 
	#ARCHITECTURE_ID
 ""

	)

418 #i
defed
(
__WATCOMC__
)

419 #i
defed
(
_M_I86
)

420 
	#ARCHITECTURE_ID
 "I86"

	)

422 #i
defed
(
_M_IX86
)

423 
	#ARCHITECTURE_ID
 "X86"

	)

426 
	#ARCHITECTURE_ID
 ""

	)

430 
	#ARCHITECTURE_ID
 ""

	)

434 
	#DEC
(
n
) \

435 ('0' + (((
n
) / 10000000)%10)), \

436 ('0' + (((
n
) / 1000000)%10)), \

437 ('0' + (((
n
) / 100000)%10)), \

438 ('0' + (((
n
) / 10000)%10)), \

439 ('0' + (((
n
) / 1000)%10)), \

440 ('0' + (((
n
) / 100)%10)), \

441 ('0' + (((
n
) / 10)%10)), \

442 ('0' + ((
n
% 10))

	)

445 
	#HEX
(
n
) \

446 ('0' + ((
n
)>>28 & 0xF)), \

447 ('0' + ((
n
)>>24 & 0xF)), \

448 ('0' + ((
n
)>>20 & 0xF)), \

449 ('0' + ((
n
)>>16 & 0xF)), \

450 ('0' + ((
n
)>>12 & 0xF)), \

451 ('0' + ((
n
)>>8 & 0xF)), \

452 ('0' + ((
n
)>>4 & 0xF)), \

453 ('0' + ((
n
& 0xF))

	)

456 #ifde
COMPILER_VERSION_MAJOR


457 cڡ 
	gfo_vsi
[] = {

460 
COMPILER_VERSION_MAJOR
,

461 #ifde
COMPILER_VERSION_MINOR


462 '.', 
COMPILER_VERSION_MINOR
,

463 #ifde
COMPILER_VERSION_PATCH


464 '.', 
COMPILER_VERSION_PATCH
,

465 #ifde
COMPILER_VERSION_TWEAK


466 '.', 
COMPILER_VERSION_TWEAK
,

474 #ifde
SIMULATE_VERSION_MAJOR


475 cڡ 
	gfo_simuϋ_vsi
[] = {

478 
SIMULATE_VERSION_MAJOR
,

479 #ifde
SIMULATE_VERSION_MINOR


480 '.', 
SIMULATE_VERSION_MINOR
,

481 #ifde
SIMULATE_VERSION_PATCH


482 '.', 
SIMULATE_VERSION_PATCH
,

483 #ifde
SIMULATE_VERSION_TWEAK


484 '.', 
SIMULATE_VERSION_TWEAK
,

495 cڡ* 
	gfo_fm
 = "INFO" ":" "fm[" 
PLATFORM_ID
 "]";

496 cڡ* 
	gfo_ch
 = "INFO" ":" "ch[" 
ARCHITECTURE_ID
 "]";

501 cڡ * 
	gfo_nguage_d_deu
 = "INFO" ":" "dialect_default["

502 #i
__lulus
 >= 201402L

504 #i
__lulus
 >= 201103L

513 
	$ma
(
gc
, * 
gv
[])

515 
que
 = 0;

516 
que
 +
fo_comp
[
gc
];

517 
que
 +
fo_fm
[
gc
];

518 #ifde
COMPILER_VERSION_MAJOR


519 
que
 +
fo_vsi
[
gc
];

521 #ifde
SIMULATE_ID


522 
que
 +
fo_simuϋ
[
gc
];

524 #ifde
SIMULATE_VERSION_MAJOR


525 
que
 +
fo_simuϋ_vsi
[
gc
];

527 #i
	`defed
(
__CRAYXE
|| defed(
__CRAYXC
)

528 
que
 +
fo_ay
[
gc
];

530 
que
 +
fo_nguage_d_deu
[
gc
];

531 ()
gv
;

532  
que
;

533 
	}
}

	@build/CMakeFiles/feature_tests.c

2 cڡ 
	gus
[] = {"\n"

4 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
) >= 404

11 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && 
defed
(
__STDC_VERSION__
) && __STDC_VERSION__ >= 199901L

18 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && 
defed
(
__STDC_VERSION__
) && __STDC_VERSION__ >= 201000L

25 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && 
defed
(
__STDC_VERSION__
) && __STDC_VERSION__ >= 199901L

34 
	$ma
(
gc
, ** 
gv
{ (rgv;  
us
[gc]; 
	}
}

	@build/CMakeFiles/feature_tests.cxx

2 cڡ 
	gus
[] = {"\n"

4 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>500 && 
__lulus
 >= 201402L

11 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>407 && 
__lulus
 >= 201103L

18 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>408 && 
__lulus
 >= 201103L

25 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>408 && 
__lulus
 >= 201103L

32 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>408 && 
__lulus
 >= 201103L

39 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

46 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

53 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

60 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

67 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

74 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

81 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

88 #i((
__GNUC__
 * 10000 + 
__GNUC_MINOR__
 * 100 + 
__GNUC_PATCHLEVEL__
>40801&& 
__lulus
 >= 201103L

95 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

102 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

109 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

116 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>407 && 
__lulus
 >= 201103L

123 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

130 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

137 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

144 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>405 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

151 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>407 && 
__lulus
 >= 201103L

158 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

165 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>407 && 
__lulus
 >= 201103L

172 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

179 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

186 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

193 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>408 && 
__lulus
 >= 201103L

200 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

207 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>405 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

214 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

221 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>405 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

228 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

235 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

242 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>407 && 
__lulus
 >= 201103L

249 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

256 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>407 && 
__lulus
 >= 201103L

263 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

270 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>405 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

277 #i((
__GNUC__
 * 10000 + 
__GNUC_MINOR__
 * 100 + 
__GNUC_PATCHLEVEL__
>40801&& 
__lulus
 >= 201103L

284 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>500 && 
__lulus
 >= 201402L

291 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>409 && 
__lulus
 > 201103L

298 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

305 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

312 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

319 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

326 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

333 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && 
__lulus


340 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>408 && 
__lulus
 >= 201103L

347 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

354 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

361 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

368 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>406 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

375 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>407 && 
__lulus
 >= 201103L

382 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>500 && 
__lulus
 >= 201402L

389 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

396 #i(
__GNUC__
 * 100 + 
__GNUC_MINOR__
>404 && (
__lulus
 >201103L || (
defed
(
__GXX_EXPERIMENTAL_CXX0X__
) && __GXX_EXPERIMENTAL_CXX0X__))

405 
	$ma
(
gc
, ** 
gv
{ (rgv;  
us
[gc]; 
	}
}

	@include/ME_802_1p_mapper_service_profile.hpp

88 #i!
defed
(
ME_802_1P_MAPPER_SERVICE_PROFILE_INCLUDE_HPP
)

89 
	#ME_802_1P_MAPPER_SERVICE_PROFILE_INCLUDE_HPP


	)

91 
	~<js/js.h
>

92 
	~<js/js.h
>

93 
	~<comm.h
>

94 
	~<ba_ass.h
>

96 as
	cME_802_1p_mr_rvi_ofe
 : 
public
 
ME_S


98 
public
:

99 
ME_802_1p_mr_rvi_ofe
();

100 
ME_802_1p_mr_rvi_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

102 ~
ME_802_1p_mr_rvi_ofe
();

103 
	mm_2
;

104 
	mm_r
[256]={};

105 
g_mhod
();

108 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

111 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

114 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

117 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

120 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

123 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

126 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

129 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

132 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

135 
bo
 
ibu_10_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

138 
bo
 
ibu_11_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

141 
bo
 
ibu_12_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

144 
bo
 
ibu_13_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

147 
bo
 
ibu_14_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_Extended_VLAN_tagging_operation_configuration_data.hpp

118 #i!
defed
(
ME_EXTENDED_VLAN_TAGGING_OPERATION_CONFIGURATION_DATA_INCLUDE_HPP
)

119 
	#ME_EXTENDED_VLAN_TAGGING_OPERATION_CONFIGURATION_DATA_INCLUDE_HPP


	)

121 
	~<js/js.h
>

122 
	~<js/js.h
>

123 
	~<comm.h
>

124 
	~<ba_ass.h
>

126 as
	cME_Exnded_VLAN_ggg_ݔi_cfiguti_da
 : 
public
 
ME_S


128 
public
:

129 
ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
();

130 
ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

132 ~
ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
();

133 
	mm_2
;

134 
	mm_r
[256]={};

135 
g_mhod
();

138 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

141 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

144 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

147 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

150 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

153 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

156 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

159 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_GAL_Ethernet_profile.hpp

28 #i!
defed
(
ME_GAL_ETHERNET_PROFILE_INCLUDE_HPP
)

29 
	#ME_GAL_ETHERNET_PROFILE_INCLUDE_HPP


	)

31 
	~<js/js.h
>

32 
	~<js/js.h
>

33 
	~<comm.h
>

34 
	~<ba_ass.h
>

36 as
	cME_GAL_Etht_ofe
 : 
public
 
ME_S


38 
public
:

39 
ME_GAL_Etht_ofe
();

40 
ME_GAL_Etht_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

42 ~
ME_GAL_Etht_ofe
();

43 
	mm_2
;

44 
	mm_r
[256]={};

45 
g_mhod
();

48 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

51 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_GEM_interworking_termination_point.hpp

88 #i!
defed
(
ME_GEM_INTERWORKING_TERMINATION_POINT_INCLUDE_HPP
)

89 
	#ME_GEM_INTERWORKING_TERMINATION_POINT_INCLUDE_HPP


	)

91 
	~<js/js.h
>

92 
	~<js/js.h
>

93 
	~<comm.h
>

94 
	~<ba_ass.h
>

96 as
	cME_GEM_rwkg_rmi_pot
 : 
public
 
ME_S


98 
public
:

99 
ME_GEM_rwkg_rmi_pot
();

100 
ME_GEM_rwkg_rmi_pot
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

102 ~
ME_GEM_rwkg_rmi_pot
();

103 
	mm_2
;

104 
	mm_r
[256]={};

105 
g_mhod
();

108 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

111 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

114 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

117 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

120 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

123 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

126 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

129 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

132 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_GEM_port_network_CTP.hpp

75 #i!
defed
(
ME_GEM_PORT_NETWORK_CTP_INCLUDE_HPP
)

76 
	#ME_GEM_PORT_NETWORK_CTP_INCLUDE_HPP


	)

78 
	~<js/js.h
>

79 
	~<js/js.h
>

80 
	~<comm.h
>

81 
	~<ba_ass.h
>

83 as
	cME_GEM_pt_twk_CTP
 : 
public
 
ME_S


85 
public
:

86 
ME_GEM_pt_twk_CTP
();

87 
ME_GEM_pt_twk_CTP
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

89 ~
ME_GEM_pt_twk_CTP
();

90 
	mm_2
;

91 
	mm_r
[256]={};

92 
g_mhod
();

95 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

98 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

101 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

104 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

107 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

110 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

113 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

116 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

119 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_MAC_bridge_configuration_data.hpp

51 #i!
defed
(
ME_MAC_BRIDGE_CONFIGURATION_DATA_INCLUDE_HPP
)

52 
	#ME_MAC_BRIDGE_CONFIGURATION_DATA_INCLUDE_HPP


	)

54 
	~<js/js.h
>

55 
	~<js/js.h
>

56 
	~<comm.h
>

57 
	~<ba_ass.h
>

59 as
	cME_MAC_bridge_cfiguti_da
 : 
public
 
ME_S


61 
public
:

62 
ME_MAC_bridge_cfiguti_da
();

63 
ME_MAC_bridge_cfiguti_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

65 ~
ME_MAC_bridge_cfiguti_da
();

66 
	mm_2
;

67 
	mm_r
[256]={};

68 
g_mhod
();

71 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

74 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

77 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

80 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

83 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

86 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

89 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

92 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

95 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_MAC_bridge_port_configuration_data.hpp

87 #i!
defed
(
ME_MAC_BRIDGE_PORT_CONFIGURATION_DATA_INCLUDE_HPP
)

88 
	#ME_MAC_BRIDGE_PORT_CONFIGURATION_DATA_INCLUDE_HPP


	)

90 
	~<js/js.h
>

91 
	~<js/js.h
>

92 
	~<comm.h
>

93 
	~<ba_ass.h
>

95 as
	cME_MAC_bridge_pt_cfiguti_da
 : 
public
 
ME_S


97 
public
:

98 
ME_MAC_bridge_pt_cfiguti_da
();

99 
ME_MAC_bridge_pt_cfiguti_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

101 ~
ME_MAC_bridge_pt_cfiguti_da
();

102 
	mm_2
;

103 
	mm_r
[256]={};

104 
g_mhod
();

107 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

110 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

113 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

116 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

119 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

122 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

125 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

128 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

131 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

134 
bo
 
ibu_10_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

137 
bo
 
ibu_11_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

140 
bo
 
ibu_12_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

143 
bo
 
ibu_13_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_MAC_bridge_service_profile.hpp

63 #i!
defed
(
ME_MAC_BRIDGE_SERVICE_PROFILE_INCLUDE_HPP
)

64 
	#ME_MAC_BRIDGE_SERVICE_PROFILE_INCLUDE_HPP


	)

66 
	~<js/js.h
>

67 
	~<js/js.h
>

68 
	~<comm.h
>

69 
	~<ba_ass.h
>

71 as
	cME_MAC_bridge_rvi_ofe
 : 
public
 
ME_S


73 
public
:

74 
ME_MAC_bridge_rvi_ofe
();

75 
ME_MAC_bridge_rvi_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

77 ~
ME_MAC_bridge_rvi_ofe
();

78 
	mm_2
;

79 
	mm_r
[256]={};

80 
g_mhod
();

83 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

86 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

89 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

92 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

95 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

98 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

101 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

104 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

107 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

110 
bo
 
ibu_10_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_Multicast_GEM_interworking_termination_point.hpp

110 #i!
defed
(
ME_MULTICAST_GEM_INTERWORKING_TERMINATION_POINT_INCLUDE_HPP
)

111 
	#ME_MULTICAST_GEM_INTERWORKING_TERMINATION_POINT_INCLUDE_HPP


	)

113 
	~<js/js.h
>

114 
	~<js/js.h
>

115 
	~<comm.h
>

116 
	~<ba_ass.h
>

118 as
	cME_Mui_GEM_rwkg_rmi_pot
 : 
public
 
ME_S


120 
public
:

121 
ME_Mui_GEM_rwkg_rmi_pot
();

122 
ME_Mui_GEM_rwkg_rmi_pot
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

124 ~
ME_Mui_GEM_rwkg_rmi_pot
();

125 
	mm_2
;

126 
	mm_r
[256]={};

127 
g_mhod
();

130 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

133 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

136 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

139 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

142 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

145 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

148 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

151 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

154 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_Multicast_operations_profile.hpp

122 #i!
defed
(
ME_MULTICAST_OPERATIONS_PROFILE_INCLUDE_HPP
)

123 
	#ME_MULTICAST_OPERATIONS_PROFILE_INCLUDE_HPP


	)

125 
	~<js/js.h
>

126 
	~<js/js.h
>

127 
	~<comm.h
>

128 
	~<ba_ass.h
>

130 as
	cME_Mui_ݔis_ofe
 : 
public
 
ME_S


132 
public
:

133 
ME_Mui_ݔis_ofe
();

134 
ME_Mui_ݔis_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

136 ~
ME_Mui_ݔis_ofe
();

137 
	mm_2
;

138 
	mm_r
[256]={};

139 
g_mhod
();

142 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

145 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

148 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

151 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

154 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

157 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

160 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

163 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

166 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

169 
bo
 
ibu_10_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

172 
bo
 
ibu_11_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

175 
bo
 
ibu_12_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

178 
bo
 
ibu_13_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

181 
bo
 
ibu_14_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_Multicast_subscriber_config_info.hpp

55 #i!
defed
(
ME_MULTICAST_SUBSCRIBER_CONFIG_INFO_INCLUDE_HPP
)

56 
	#ME_MULTICAST_SUBSCRIBER_CONFIG_INFO_INCLUDE_HPP


	)

58 
	~<js/js.h
>

59 
	~<js/js.h
>

60 
	~<comm.h
>

61 
	~<ba_ass.h
>

63 as
	cME_Mui_subsib_cfig_fo
 : 
public
 
ME_S


65 
public
:

66 
ME_Mui_subsib_cfig_fo
();

67 
ME_Mui_subsib_cfig_fo
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

69 ~
ME_Mui_subsib_cfig_fo
();

70 
	mm_2
;

71 
	mm_r
[256]={};

72 
g_mhod
();

75 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

78 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

81 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

84 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

87 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

90 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_ONT_data.hpp

47 #i!
defed
(
ME_ONT_DATA_INCLUDE_HPP
)

48 
	#ME_ONT_DATA_INCLUDE_HPP


	)

50 
	~<js/js.h
>

51 
	~<js/js.h
>

52 
	~<comm.h
>

53 
	~<ba_ass.h
>

55 as
	cME_ONT_da
 : 
public
 
ME_S


57 
public
:

58 
ME_ONT_da
();

59 
ME_ONT_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

61 ~
ME_ONT_da
();

62 
	mm_2
;

63 
	mm_r
[256]={};

64 
g_mhod
();

67 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

70 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_Physical_path_termination_point_Ethernet_UNI.hpp

146 #i!
defed
(
ME_PHYSICAL_PATH_TERMINATION_POINT_ETHERNET_UNI_INCLUDE_HPP
)

147 
	#ME_PHYSICAL_PATH_TERMINATION_POINT_ETHERNET_UNI_INCLUDE_HPP


	)

149 
	~<js/js.h
>

150 
	~<js/js.h
>

151 
	~<comm.h
>

152 
	~<ba_ass.h
>

154 as
	cME_Physil_th_rmi_pot_Etht_UNI
 : 
public
 
ME_S


156 
public
:

157 
ME_Physil_th_rmi_pot_Etht_UNI
();

158 
ME_Physil_th_rmi_pot_Etht_UNI
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

160 ~
ME_Physil_th_rmi_pot_Etht_UNI
();

161 
	mm_2
;

162 
	mm_r
[256]={};

163 
g_mhod
();

166 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

169 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

172 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

175 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

178 
bo
 
ibu_5_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

181 
bo
 
ibu_6_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

184 
bo
 
ibu_7_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

187 
bo
 
ibu_8_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

190 
bo
 
ibu_9_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

193 
bo
 
ibu_10_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

196 
bo
 
ibu_11_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

199 
bo
 
ibu_12_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

202 
bo
 
ibu_13_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

205 
bo
 
ibu_14_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

208 
bo
 
ibu_15_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

211 
bo
 
ibu_16_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_T_CONT.hpp

60 #i!
defed
(
ME_T_CONT_INCLUDE_HPP
)

61 
	#ME_T_CONT_INCLUDE_HPP


	)

63 
	~<js/js.h
>

64 
	~<js/js.h
>

65 
	~<comm.h
>

66 
	~<ba_ass.h
>

68 as
	cME_T_CONT
 : 
public
 
ME_S


70 
public
:

71 
ME_T_CONT
();

72 
ME_T_CONT
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

74 ~
ME_T_CONT
();

75 
	mm_2
;

76 
	mm_r
[256]={};

77 
g_mhod
();

80 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

83 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

86 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

89 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/ME_VLAN_tagging_filter_data.hpp

65 #i!
defed
(
ME_VLAN_TAGGING_FILTER_DATA_INCLUDE_HPP
)

66 
	#ME_VLAN_TAGGING_FILTER_DATA_INCLUDE_HPP


	)

68 
	~<js/js.h
>

69 
	~<js/js.h
>

70 
	~<comm.h
>

71 
	~<ba_ass.h
>

73 as
	cME_VLAN_ggg_fr_da
 : 
public
 
ME_S


75 
public
:

76 
ME_VLAN_ggg_fr_da
();

77 
ME_VLAN_ggg_fr_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

79 ~
ME_VLAN_ggg_fr_da
();

80 
	mm_2
;

81 
	mm_r
[256]={};

82 
g_mhod
();

85 
bo
 
ibu_1_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

88 
bo
 
ibu_2_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

91 
bo
 
ibu_3_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

94 
bo
 
ibu_4_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

	@include/Temp.hpp

1 #!/
b
/
bash


3 
	$HEAD_TOP
()

5 
lol
 
me_me
="$1"

6 
lol
 
t_num
="$2"

7 
lol
 
UPPER
=`
echo
 
$me_me
 | 
awk
 '{printoupper($0)}'`

9 
echo
 "

16 #i!
	`defed
("$UPPER"
_INCLUDE_HPP
)

17 #def"$UPPER"
_INCLUDE_HPP


19 
	~<js/js.h
>

20 
	~<js/js.h
>

21 
	~<comm.h
>

22 
	~<ba_ass.h
>

24 as
	c$me_me
 : 
public
 
ME_S


26 
public
:

27 
	`$me_me
();

28 
	`$me_me
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
);

30 ~
	`$me_me
();

31 
m_2
;

32 
m_r
[256]={};

33 
	`g_mhod
();

35 
	}
}

37 
	$HEAD_BOT
()

39 
lol
 
me_me
="$1"

40 
lol
 
t_num
="$2"

41 
lol
 
UPPER
=`
echo
 
$me_me
 | 
awk
 '{printoupper($0)}'`

42 
echo
 "

43 
	}
};

48 
	$HEAD_ATT
()

50 
lol
 
me_me
="$1"

51 
lol
 
t_num
="$2"

53 
n
=1; <= "$att_num" ;n++))

55 
echo
 "

56 
bo
 
ibu_
"$n"
	`_mhod
(
Ai
 
_Ai
, *
vue
, *
g
);

58 
de


59 
	}
}

62 
	$HEAD_TEMP
()

64 
lol
 
me_me
="$1"

65 
lol
 
t_num
="$2"

66 
lol
 
c
="$3"

67 
BN
=`
bame
 "$sec"`

68 
echo
 "/*"

69 
ME_INF
=`
t
 ./
ME_NAME
/
$BN
`

70 
echo
 "$ME_INF"

71 
echo
 "*/"

72 
HEAD_TOP
 "$me_name" "$att_num"

73 
HEAD_ATT
 "$me_name" "$att_num"

74 
HEAD_BOT
 "$me_name" "$att_num"

75 
	}
}

	@include/all_me.hpp

1 #i!
defed
(
ALL_ME_HPP_INCLUDED
)

2 
	#ALL_ME_HPP_INCLUDED


	)

5 
	~"ME_MAC_bridge_pt_cfiguti_da.h
"

6 
	~"ME_Physil_th_rmi_pot_Etht_UNI.h
"

7 
	~"ME_VLAN_ggg_fr_da.h
"

8 
	~"ME_MAC_bridge_cfiguti_da.h
"

9 
	~"ME_GEM_pt_twk_CTP.h
"

10 
	~"ME_MAC_bridge_rvi_ofe.h
"

11 
	~"ME_GEM_rwkg_rmi_pot.h
"

12 
	~"ME_Mui_subsib_cfig_fo.h
"

13 
	~"ME_T_CONT.h
"

14 
	~"ME_Mui_ݔis_ofe.h
"

15 
	~"ME_Exnded_VLAN_ggg_ݔi_cfiguti_da.h
"

16 
	~"ME_ONT_da.h
"

17 
	~"ME_802_1p_mr_rvi_ofe.h
"

18 
	~"ME_Mui_GEM_rwkg_rmi_pot.h
"

19 
	~"ME_GAL_Etht_ofe.h
"

	@include/base_class.hpp

1 #i!
defed
(
COMMON_CLASS_HPP_INCLUDED
)

2 
	#COMMON_CLASS_HPP_INCLUDED


	)

4 
	~<comm.h
>

6 as
	cAribu_S


8 
	mpublic
:

9 
UI32_T
 
Vue
;

10 * 
	mpVue
;

13 as
	cME_S


15 
	mpublic
:

17 
Js
::
Vue
 
m_j_me
;

18 
	$ME_S
():
	`m_ass_id
(0),
	$m__id
(0){;};

19 
	`ME_S
(
UI32_T
 
ass_id
, UI32_T 
_id
, 
Js
::
Vue
 
me_s
);

21 
vtu
 ~
	$ME_S
(){
	}
};

22 
vtu
 
	$g_mhod
(){
	}
};

23 
vtu
 
	$t_mhod
(){
	}
};

25 
UI32_T
 
	gm_ass_id
;

26 
UI32_T
 
	gm__id
;

27 
UI32_T
 
	gm_ais_b
=0;

29 
Aribu_S
 
	gm_Aribus
[17];

31 
vtu
 
bo
 
	$y
(
d
::
rg
 
_ai
){
	}
};

33 
vtu
 
bo
 
	$ibu_1_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

34 
vtu
 
bo
 
	$ibu_2_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

35 
vtu
 
bo
 
	$ibu_3_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

36 
vtu
 
bo
 
	$ibu_4_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

37 
vtu
 
bo
 
	$ibu_5_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

38 
vtu
 
bo
 
	$ibu_6_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

39 
vtu
 
bo
 
	$ibu_7_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

40 
vtu
 
bo
 
	$ibu_8_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

41 
vtu
 
bo
 
	$ibu_9_mhod

Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

42 
vtu
 
bo
 
	$ibu_10_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

43 
vtu
 
bo
 
	$ibu_11_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

44 
vtu
 
bo
 
	$ibu_12_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

45 
vtu
 
bo
 
	$ibu_13_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

46 
vtu
 
bo
 
	$ibu_14_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

47 
vtu
 
bo
 
	$ibu_15_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

48 
vtu
 
bo
 
	$ibu_16_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

49 
vtu
 
bo
 
	$ibu_17_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
){
	}
};

	@include/common.hpp

1 #i!
defed
(
COMMON_HPP_INCLUDED
)

2 
	#COMMON_HPP_INCLUDED


	)

4 
	~<js/js.h
>

5 
	~<js/js.h
>

6 
	~<o.h
>

7 
	~<sys/.h
>

9 
	#SWITCHCASE
(
cid
, 
s_id
, 
me_me
, 
me_s
) \

10 
cid
 :\

12 
me_me
 *
A
 = 
w
 
	`me_me
(
cid
, 
s_id
, 
me_s
);\

13 
	`tf
("CID[%d]\r\n", 
cid
);\

14 
M_OMCI_P
[
d
::
	`make_
(
cid
,
s_id
)]=
A
;\

16 }

	)

18 
	#DEFAULT_MODE
 
S_IRWXU
 | 
S_IRGRP
 | 
S_IXGRP
 | 
S_IROTH
 | 
S_IXOTH


	)

20 
	eAi


22 
	mMSG_TYPE_GET
 = 1,

23 
	mMSG_TYPE_SET
 = 2

26 
	tUI32_T
;

27 
	tUI16_T
;

28 
	tUI8_T
;

29 
	tBOOL_T
;

30 
	tI32_T
;

31 
	tI16_T
;

32 
	tI8_T
;

35 
BOOL_T
 
mkdp
(cڡ * 
th
, 
mode_t
 
mode
 = 
DEFAULT_MODE
);

	@include/me_c.hpp

1 #i!
defed
(
ME_S_HPP_INCLUDED
)

2 
	#ME_S_HPP_INCLUDED


	)

4 
	~<comm.h
>

5 
	~<ba_ass.h
>

6 
	~<js/js.h
>

7 
	~<js/js.h
>

9 
usg
 
mea
 
	gd
;

11 
cڡex
 cڡ 
	gDEFAULT_SUBSCRIPTION_FILE_PATH
[] = "./";

12 
cڡex
 cڡ 
	gME_SEC_PATH
[] = "S_ME/";

14 as
	cME_C


16 
	mpublic
:

18 
d
::
m
<d::

<,>, 
	mME_S
 * > 
	mM_OMCI_P
;

19 
	md
::
m
<
d
::

<,>, 
	mJs
::
Vue
> 
M_OMCI_G
;

21 
ME_C
();

22 ~
ME_C
();

23 
ME_S
 * 
g_me_obj
(
ass_id
, 
_id
);

24 
BOOL_T
 
_me_obj
(
ass_id
, 
_id
, 
Js
::
Vue
 
me_s
);

25 
BOOL_T
 
check_ai_vid
(
UI16_T
 
Css
, UI16_T 
Ai
);

26 
BOOL_T
 
check_me_s_vid
(
UI16_T
 
Css
);

27 
BOOL_T
 
check_me_o_vid
(
UI16_T
 
Css
, UI16_T 
_id
);

29 
	mJs
::
Vue
 
g_me_s_js
(
UI16_T
 
Css
);

31 
	mive
:

32 
BOOL_T
 
g_omci_s
();

33 
BOOL_T
 
e__me_obj
();

35 
a_l_me_obj
();

	@include/omci_parser.hpp

1 #i!
defed
(
PARSER_HPP_INCLUDED
)

2 
	#PARSER_HPP_INCLUDED


	)

4 
	~<comm.h
>

5 
	~<rg
>

6 
	~<m
>

7 
	~<me_c.h
>

8 
	~<time.h
>

10 
usg
 
mea
 
	gd
;

12 
	eOMCI_ME_CLASS_ID_E


17 
	mMECID_ONT_DATA
 = 2,

18 
	mMECID_CARDHOLDER
 = 5,

19 
	mMECID_CIRCUIT_PACK
 = 6,

20 
	mMECID_SOFTWARE_IMAGE
 = 7,

21 
	mMECID_PPTP_ETHERNET_UNI
 = 11,

22 
	mMECID_ETH_PM_HISTORY_DATA
 = 24,

23 
	mMECID_MAC_BRIDGE_SERVICE_PROFILE
 = 45,

24 
	mMECID_MAC_BR_CFGDATA
 = 46,

25 
	mMECID_MAC_BRIDGE_PORT_CONFIG_DATA
 = 47,

26 
	mMECID_MAC_BR_PORT_DSGDATA
 = 48,

27 
	mMECID_MAC_BR_PORT_FILTER_TABLE_DATA
 = 49,

28 
	mMECID_MAC_BR_PORT_BRIDGE_TABLE_DATA
 = 50,

29 
	mMECID_MAC_BRG_PM_HISTORY_DATA
 = 52,

30 
	mMECID_VLAN_TAGGING_OP_CONFIG_DATA
 = 78,

31 
	mMECID_VLAN_TAGGING_FILTER_DATA
 = 84,

32 
	mMECID_ETH_PM_HISTORY_DATA2
 = 89,

33 
	mMECID_I8021P_MAPPER_SERVICE_PROFILE
 = 130,

34 
	mMECID_OLT_G
 = 131,

35 
	mMECID_ONT_POWER_SHEDDING
 = 133,

36 
	mMECID_IP_HOST_CONFIG_DATA
 = 134,

37 
	mMECID_EXT_VLAN_TAGGING_OP_CONFIG_DATA
 = 171,

38 
	mMECID_ONT_SYS_MGMT
 = 240,

39 
	mMECID_ACS_VENDOR_SPECIFIC
 = 242,

40 
	mMECID_PROTOCOL_BASED_VLAN_TAGGING_OP_DATA
 = 245,

41 
	mMECID_ONT_G
 = 256,

42 
	mMECID_ONT2_G
 = 257,

43 
	mMECID_T_CONT
 = 262,

44 
	mMECID_ANI_G
 = 263,

45 
	mMECID_UNI_G
 = 264,

46 
	mMECID_GEM_INTER_TERMINATION_POINT
 = 266,

47 
	mMECID_GEM_PORT_PM_HISTORY_DATA
 = 267,

48 
	mMECID_GEM_PORT_NETWORK_CTP
 = 268,

49 
	mMECID_GAL_ETH_PROFILE
 = 272,

50 
	mMECID_THRESHLD_DATA_1
 = 273,

51 
	mMECID_THRESHLD_DATA_2
 = 274,

52 
	mMECID_PRIORITY_QUEUE_G
 = 277,

53 
	mMECID_TRAFFIC_SCHEDULER_G
 = 278,

54 
	mMECID_GEM_TRAFFIC_DESCRIPTOR
 = 280,

55 
	mMECID_MULTICAST_GEM_INTERWORK_TERM_POINT
 = 281,

56 
	mMECID_DOT1X_PORT_EXT_PKG
 = 290,

57 
	mMECID_DOT1X_CFG_PROF
 = 291,

58 
	mMECID_DOT1X_PM_HISTORY_DATA
 = 292,

59 
	mMECID_RADIUS_PM_HISTORY_DATA
 = 293,

60 
	mMECID_ETH_PM_HISTORY_DATA3
 = 296,

61 
	mMECID_DOT1AG_MAINTENANCE_DOMAIN
 = 299,

62 
	mMECID_DOT1AG_MAINTENANCE_ASSOCIATION
 = 300,

63 
	mMECID_DOT1AG_MEP
 = 302,

64 
	mMECID_MULTICAST_OPERATION_PROFILE
 = 309,

65 
	mMECID_MULTICAST_SUBSCRIBER_CONFIG_INFO
 = 310,

66 
	mMECID_MULTICAST_SUB_MONITOR
 = 311,

70 
	mMECID_PPTP_POTS_UNI
 = 53,

71 
	mMECID_VOICE_SERVICE_PROF
 = 58,

72 
	mMECID_TCPUDP_CFGDATA
 = 136,

73 
	mMECID_NETWORK_ADDR
 = 137,

74 
	mMECID_VOIP_CFGDATA
 = 138,

75 
	mMECID_VOIP_VOICE_CTP
 = 139,

76 
	mMECID_VOIP_LINE_STATUS
 = 141,

77 
	mMECID_VOIP_MEDIA_PROF
 = 142,

78 
	mMECID_RTP_PROF
 = 143,

79 
	mMECID_NET_DIAL_PLAN_TABLE
 = 145,

80 
	mMECID_VOIP_APPL_SERVICE_PROF
 = 146,

81 
	mMECID_VOIP_FEAT_ACC_CODES
 = 147,

82 
	mMECID_AUTHENT_SECURITY_METH
 = 148,

83 
	mMECID_SIP_AGENT_CFGDATA
 = 150,

84 
	mMECID_SIP_USER_DATA
 = 153,

85 
	mMECID_LARGE_STRING
 = 157,

87 
	mMECID_ETH_FRAME_PM_HISTORY_DATA_DOWNSTREAM
 = 321,

88 
	mMECID_ETH_FRAME_PM_HISTORY_DATA_UPSTREAM
 = 322,

89 
	mMECID_VIRTUAL_ETHER_INF_POINT
 = 329,

90 
	mMECID_GENERIC_STATUS_PORTAL
 = 330,

91 
	mMECID_ETH_PM_HISTORY_DATA4
 = 351,

92 
	mMECID_G9844_SPEC_CLASS_VALUE_LAST_PLUS_1
,

96 
	mMECID_ALU_PROPRIETARY_CLASS_VALUE_FIRST
 = 65281,

97 
	mMECID_ONT_AGGREGATE_GEM_PORT_PM_HISTORY_DATA
 = 65281,

98 
	mMECID_ETH_TRAFFIC_PM_HISTORY_DATA
 = 65282,

99 
	mMECID_NTP_CONFIG
 = 65288,

100 
	mMECID_VoIP_Cl_1
 = 65291,

101 
	mMECID_VoIP_Suml_1
 = 65292,

102 
	mMECID_VoIP_Cl_2
 = 65293,

103 
	mMECID_ONT_GENERIC_V2
 = 65296,

104 
	mMECID_UNI_SUPPLEMENTAL_1_V2
 = 65297,

105 
	mMECID_GEM_PORT_PM_HISTORY_DATA_PART_2
 = 65300,

106 
	mMECID_IPMACVLAN_ANTI_SPOOF_LIST_V2
 = 65301,

107 
	mMECID_NTP_CONFIG_V2
 = 65304,

108 
	mMECID_ALU_PROPRIETARY_CLASS_VALUE_LAST_PLUS_1
,

110 
	mME_G9844_SPEC_MAX_COUNT
 = ( 
MECID_G9844_SPEC_CLASS_VALUE_LAST_PLUS_1
 ),

111 
	mME_ALU_PROPRIETARY_MAX_COUNT

MECID_ALU_PROPRIETARY_CLASS_VALUE_LAST_PLUS_1
 -

112 
MECID_ALU_PROPRIETARY_CLASS_VALUE_FIRST
 ),

115 
	eOMCI_MESSAGE_TYPE_E


117 
	mMSGTYPE_CREATE
 = 4,

118 
	mMSGTYPE_DELETE
 = 6,

119 
	mMSGTYPE_SET
 = 8,

120 
	mMSGTYPE_GET
 = 9,

121 
	mMSGTYPE_GET_ALL_ALARMS
 = 11,

122 
	mMSGTYPE_GET_ALL_ALARMS_NEXT
 = 12,

123 
	mMSGTYPE_MIB_UPLOAD
 = 13,

124 
	mMSGTYPE_MIB_UPLOAD_NEXT
 = 14,

125 
	mMSGTYPE_MIB_RESET
 = 15,

126 
	mMSGTYPE_ALARM
 = 16,

127 
	mMSGTYPE_ATTRIBUTE_VALUE_CHANGE
 = 17,

128 
	mMSGTYPE_TEST
 = 18,

129 
	mMSGTYPE_START_SOFTWARE_DOWNLOAD
 = 19,

130 
	mMSGTYPE_DOWNLOAD_SECTION
 = 20,

131 
	mMSGTYPE_END_SOFTWARE_DOWNLOAD
 = 21,

132 
	mMSGTYPE_ACTIVATE_SOFTWARE
 = 22,

133 
	mMSGTYPE_COMMIT_SOFTWARE
 = 23,

134 
	mMSGTYPE_SYNCHRONIZE_TIME
 = 24,

135 
	mMSGTYPE_REBOOT
 = 25,

136 
	mMSGTYPE_GET_NEXT
 = 26,

137 
	mMSGTYPE_TEST_RESULT
 = 27,

138 
	mMSGTYPE_GET_CURRENT_DATA
 = 28,

139 
	mMSGTYPE_SET_ALU_NO_DATASYNC
 = 29,

140 
	mOMCI_ACTIONS_MAX_ID_PLUS_1
,

141 
	mMSGTYPE_MT_MASK
 = 0x1F,

144 
cڡex
 
UI8_T
 
	gOMCI_MSG_DB_MASK
 = 0x80;

145 
cڡex
 
UI8_T
 
	gOMCI_MSG_AR_MASK
 = 0x40;

146 
cڡex
 
UI8_T
 
	gOMCI_MSG_AK_MASK
 = 0x20;

147 
cڡex
 
UI8_T
 
	gOMCI_MSG_MT_MASK
 = 0x1F;

149 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_TRANS_ID
 = 0;

150 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_MSG_TYPE
 = (
OFFSET_OMCI_TRANS_ID
 +2);

151 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_DEV_ID
 = (
OFFSET_OMCI_MSG_TYPE
 +1);

152 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_CLASS_ID
 = (
OFFSET_OMCI_DEV_ID
 +1);

153 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_ME_ID
 = (
OFFSET_OMCI_CLASS_ID
 +2);

154 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_MSG_CONTENT
 = (
OFFSET_OMCI_ME_ID
 +2);

155 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_TRAILER
 = (
OFFSET_OMCI_MSG_CONTENT
 +32);

156 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_TRAILER_RES
 = (
OFFSET_OMCI_TRAILER
 +0);

157 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_TRAILER_CPCS
 = (
OFFSET_OMCI_TRAILER_RES
 +2);

158 
cڡex
 
UI8_T
 
	gOFFSET_OMCI_TRAILER_CRC
 = (
OFFSET_OMCI_TRAILER_CPCS
 +2);

160 
cڡex
 
UI8_T
 
	gOMCI_PKT_SIZE
 = (
OFFSET_OMCI_TRAILER_CRC
 +4);

161 
cڡex
 
UI8_T
 
	gMAX_SET_ATTRS_OFFSET
 = (
OFFSET_OMCI_TRAILER
 +0);

162 
cڡex
 
UI8_T
 
	gOFFSET_RESP_RESULT
 = (
OFFSET_OMCI_MSG_CONTENT
 +0);

163 
cڡex
 
UI8_T
 
	gOFFSET_ArsMask
 = (
OFFSET_OMCI_MSG_CONTENT
 +0);

164 
cڡex
 
UI8_T
 
	gOMCI_MSG_CONTENT_SIZE
 = 32;

165 
cڡex
 
UI8_T
 
	gOMCI_GEM_HEADER_SIZE
 = 5;

168 cڡ 
	gd
::
m
<
UI8_T
, std::
rg
> 
g_ai_t
 =

197 
cڡex
 
	gPLAYBACK_CFG_NAME
[] = "PlayBack_Cfg";

198 
cڡex
 
	gPLAYBACK_OLT_CFG_NAME
[] = "PlayBack_OLT_Cfg";

201 as
	cOMCI_Pr


203 
	mpublic
:

204 
OMCI_Pr
();

206 
	md
::
rg
 
g_omci_ai_me
(
UI8_T
 
ai_ID
);

207 
UI16_T
 
g_omci_ai_id
(
d
::
rg
 
vue
);

209 
UI16_T
 
omci_pkt_rr
(
UI8_T
 *
pkt_p
, UI8_T 
pkt_size
);

210 
omci_ay_back
();

212 
	mive
:

213 
d
::
rg
 
m_log_out_th
;

214 
	md
::
rg
 
m_log__th
;

215 
	mJs
::
Vue
 
m_ayback_cfg
;

216 
ME_C
 
	mm_me
;

217 
UI16_T
 
	mm_ayback_omci_num
 = {0};

219 
	gd
::
m
<, 
	gJs
::
Vue
> 
m_omci_ayback
;

221 
UI16_T
 
g_omci_ui16
(
UI8_T
 *
da
);

223 
BOOL_T
 
check_ai_vid
(
UI16_T
 
Css
, UI16_T 
Ai
);

224 
BOOL_T
 
check_me_ass_vid
(
UI16_T
 
Css
);

225 
BOOL_T
 
check_me__vid
(
UI16_T
 
Css
 ,UI16_T 
ME_ID
);

226 
BOOL_T
 
me__
(
UI16_T
 
TnsID
 ,UI16_T 
Css
 ,UI16_T 
ME_ID
, 
UI8_T
 *
pkt_p
, UI8_T 
pkt_size
);

227 
BOOL_T
 
omci_rr_vidxpkt
 (
UI8_T
 * 
pkt_p
);

229 
BOOL_T
 
is_omci_log_ab
();

230 
BOOL_T
 
is_omci_ay_ab
();

231 
BOOL_T
 
is_t_ay_ab
();

232 
g_cfg
();

233 
g_omci_ayback_da
();

	@open_source/json-cxx/examples/example.cpp

40 
	~"js/js.h
"

41 
	~"js/fmr/ty.h
"

43 
	~<funiڮ
>

44 
	~<ioam
>

46 
usg
 
mea
 
	gd
;

48 
lo
(cڡ 
js
::
Vue
& 
v
);

50 
	$lo
(cڡ 
js
::
Vue
& 
v
) {

51 aut

 = 
v
.
	`cbeg
(); v.
	`nd
() != it; it++) {

52 
cout
 << "Key: " << 

.
	`key
(<< "y: " << (->
	`g_ty
()<< 
dl
;

53 
	`lo
(*

);

55 
	}
}

57 
	$ma
() {

58 
js
::
Vue
 
	`v
("Test");

60 
cout
 << 
d
::
	`rg
(
v
<< 
dl
;

62 
v
 = 
js
::
	`Vue
(
ue
);

64 
cout
 << 
	`bo
(
v
<< 
dl
;

65 
v
 = 
nuαr
;

67 
cout
 << (
v
 !
nuαr
<< 
dl
;

69 
v
 = -1;

71 
cout
 << 
js
::
	`I
(
v
.
	`g_ty
()<< 
dl
;

72 
cout
 << 
js
::
	`I
(
v
<< 
dl
;

73 
cout
 << (
v
 =2<< 
dl
;

75 
v
 = 
nuαr
;

77 
v
.
	`push_back
(
nuαr
);

78 
v
.
	`push_back
(6);

79 
v
.
	`push_back
("Hello");

80 
v
.
	`push_back
(val);

82 
cout
 << 
v
.
	`size
(<< 
dl
;

83 
cout
 << 
	`t32_t
(
v
[0][""].
	`size
()<< 
dl
;

85 
v
 = 
nuαr
;

86 
v
["key1"] = 4;

87 
v
["key2"];

88 
v
["key3"] = -2;

89 
v
["key4"].
	`push_back
(
js
::
	`Pa
("subtest1", 5));

90 
v
["key4"].
	`push_back
(
js
::
	`Pa
("sub2", 
ue
));

91 
v
["key5"]["inkey4"] = "Test1";

92 
v
["key5"]["inkey5"] = "Test2";

94 
js
::
Vue
 
	`v2
("aa", 2);

95 
v2
["key1"] = 5;

96 
v2
["key2"] = {1, 3, 5};

97 
v2
["key3"] = -7;

98 
v2
["key4"].
	`push_back
(
js
::
	`Pa
("subtest1", 5));

99 
v2
["key4"].
	`push_back
(
js
::
	`Pa
("sub2", 
ue
));

100 
v2
["key5"]["inkey4"] = "Test1";

101 
v2
["key5"]["inkey5"] = "Test2";

102 
v2
["key6"][0] = 3;

103 
v2
["key6"][1] = 2;

104 
v2
["key6"][2] = 1;

105 
v2
["key6"][3] = 0;

106 
usg
 
Pa
 = 
js
::Pair;

107 (
v2
["key7"] = {
	`Pa
("a", 2), Pair("b", 3), Pair("b", 4)})[0];

108 
v2
["key8"] = 
js
::
	`Vue
(5, 
nuαr
);

109 
v2
["key8"].
	`assign
(5, 
ue
);

111 
js
::
Vue
 
v3
 = {

112 
Pa
{"key1", 1},

113 
Pa
{"key1", "test"},

114 
Pa
{"key2", {-7, 2, "Text"}},

115 
Pa
{"key3", {2, 
ue
, 
nuαr
}}

118 
cout
 << "Sliz: " << 
js
::
	`Sliz
(
v
<< 
dl
;

119 
cout
 << "Sliz: " << 
js
::
	`Sliz
(
v2
<< 
dl
;

120 
v
.
	`sw
(
v2
);

121 
cout
 << "Sliz: " << 
js
::
	`Sliz
(
v
<< 
dl
;

122 
cout
 << "Sliz: " << 
js
::
	`Sliz
(
v2
<< 
dl
;

124 
js
::
fmr
::
Py
 
ty
;

125 
cout
 << "Sliz: " << 
js
::
	`Sliz
(
v3
, &
ty
<< 
dl
;

127 
js
::
Vue
 
v4
;

128 
js
::
Vue
 
v5
;

129 
js
::
Vue
 
v6
;

131 
v6
["test1"] = 5;

133 cڡ 
js
::
Vue
& 
1
 = 
v6
;

134 cڡ 
js
::
Vue
& 
2
 = 
v5
;

136 
cout
 << "Te1: " << (
1
["1"] !
nuαr
<< 
dl
;

137 
cout
 << "Te2: " << (
2
["2"] !
nuαr
<< 
dl
;

138 
cout
 << "Te3: " << (
1
.
	`is_memb
("1")<< 
dl
;

139 
cout
 << "Te4: " << (
2
.
	`is_memb
("2")<< 
dl
;

141 
js
::
Derliz
 
	`derliz
(
R
"({

142 "key1":
ue
, "key3":

144 
l
 , "ke5": [ {"a": 4}, [], 5,

146 [2, 
ue
, 6],rue, 
l
 ], "key7":0.3e+4 
	}
})");

148 
derliz
 << 
R
"({"
ad
":true})";

149 
	gderliz
 << 
	gR
"({"
	g1
": "\
	guD83D
\
	guDE02
"})";

150 
	gderliz
 << 
	gR
"([2, 4, 5])";

151 
	gderliz
 << 
	gR
"([{"":5}])";

152 
	gderliz
 << 
	gR
"({"
	g2
":"😂" })";

153 
	gderliz
 << 
	gR
"({"
	g3
": "\
	gu01EC
"})";

154 
	gderliz
 << 
	gR
"(4)";

155 
	gderliz
 << 
	gR
"("
Sime
 
	grg
")";

157 i(
	gderliz
.
	$is_vid
()) {

158 aut
r
 = 
derliz
.
	`g_r
();

159 
cout
 << "Le: " << 
r
.
le
 << " cumn: " <<.
cumn


160 << " offt: " << 
r
.
offt


161 << " size: " << 
r
.
size
 << 
d
::
dl
;

162 
cout
 << "E: " << 
r
.
	`decode
(<< 
d
::
dl
;

163 
	}
}

165 
	gderliz
 << 
	gR
"(

173 "sub2":
ue


183 
ue
,

184 
ue
,

185 
ue
,

186 
ue
,

187 
ue


192 
	gderliz
 << 
	gR
"(

199 
	gue
,

200 
	gl
,

201 
	gnu
,

221 "ue": 
ue
,

222 "l": 
l
,

223 "nu": 
nu
,

252 i(
	gderliz
.
	$is_vid
()) {

253 aut
r
 = 
derliz
.
	`g_r
();

254 
cout
 << "Le: " << 
r
.
le
 << " cumn: " <<.
cumn


255 << " offt: " << 
r
.
offt


256 << " size: " << 
r
.
size
 << 
d
::
dl
;

257 
cout
 << "E: " << 
r
.
	`decode
(<< 
d
::
dl
;

258 
	}
}

260 
	gjs
::
Derliz
 
derliz_cy
(
derliz
);

262 
	gcout
 << "Deserializer: ";

263 !
	gderliz
.
	$emy
()) {

264 
derliz
 >> 
v4
;

265 
cout
 << 
js
::
	`Sliz
(
v4
, &
ty
<< 
dl
;

266 
	}
}

268 !
	gderliz_cy
.
	$emy
()) {

269 
derliz_cy
 >> 
v4
;

270 
cout
 << "Keys: " << 
dl
;

271 
	`lo
(
v4
);

272 
	}
}

274 
	gjs
::
Vue
 
v
;

275 
	gR
"({"
	gkey
":"
	gvue
","
	gnumb
":10})" >> 
	gv
;

277 
	gv
["number"] += 1;

279 
	gcout
 << 
	gv
 << 
	gjs
::
Vue
({
Pa
("a", 2), Pa("s", 2)}<< 
	gdl
;

281 aut
	g1
 = 
v
.
beg
();

282 aut
	g2
 = 
v
.
cbeg
();

284 
	gcout
 << (
	g1
 =
2
<< 
dl
;

	@open_source/json-cxx/examples/performance.cpp

40 
	~<chro
>

41 
	~<ioam
>

42 
	~<fam
>

43 
	~"js/js.h
"

45 
usg
 
mea
 
	gd
;

47 cڡ 
size_t
 
	gTEST_COUNT
 = 100;

49 
	$ma
(
gc
, * 
gv
[]) {

50 i(
gc
 < 2) {

54 
ifam
 
	`putfe
(
gv
[1]);

55 
d
::
rg
 
to_r
;

57 
putfe
.
	`ekg
(0, 
d
::
ios
::
d
);

58 
to_r
.
	`rve
(
	`size_t
(
putfe
.
	`g
()));

59 
putfe
.
	`ekg
(0, 
d
::
ios
::
beg
);

61 
to_r
.
	`assign
((
d
::
iambuf_
<>(
putfe
)),

62 
d
::
iambuf_
<>());

64 
cout
 << "Ssg" << 
dl
;

66 aut
t_time
 = 
chro
::
dy_ock
::
	`now
();

67 
size_t
 
i
 = 0; i < 
TEST_COUNT
; ++i) {

68 
js
::
Vue
 
vue
;

69 
js
::
	`Derliz
(
to_r
>> 
vue
;

71 aut
d_time
 = 
chro
::
dy_ock
::
	`now
();

72 aut
us
 = 
chro
::
duti_
<chro::
miocds
>(

73 
d_time
 - 
t_time
);

75 
cout
 << "[+] Finished successfully withnverage of: "

76 << (
us
.
	`cou
(/ (
TEST_COUNT
)<< " us\n" << 
dl
;

77 
	}
}

	@open_source/json-cxx/include/json/deserializer.hpp

44 #agm



45 
	~"js/vue.h
"

47 
	~<y
>

49 
mea
 
	gjs
 {

55 as
	cDerliz
 {

56 
	gpublic
:

62 
Derliz
();

75 
Derliz
(cڡ * 
r
);

88 
Derliz
(cڡ 
Sg
& 
r
);

96 
Derliz
(const Deserializer&);

105 
Derliz
(Deserializer&&);

118 
	gDerliz
& 
	gݔ
<<(cڡ * 
	gr
);

130 
	gDerliz
& 
	gݔ
<<(cڡ 
	gSg
& 
	gr
);

140 
	gDerliz
& 
	gݔ
>>(
	gVue
& 
	gvue
);

149 
	gDerliz
& 
	gݔ
=(cڡ 
Derliz
&);

159 
	gDerliz
& 
	gݔ
=(
Derliz
&&);

179 
nd
 
Derliz
 
	gݔ
>>(cڡ * 
	gr
, 
	gVue
& 
	gvue
);

199 
nd
 
Derliz
 
	gݔ
>>(cڡ 
	gSg
& 
	gr
, 
	gVue
& 
	gvue
);

211 
t_lim
(
size_t
 
lim
 = 
MAX_LIMIT_PER_OBJECT
);

220 
bo
 
emy
() const;

227 
size_t
 
size
() const;

230 
	sE
 {

232 as
	cCode
 {

233 
	gNONE
,

234 
	gEND_OF_FILE
,

235 
	gMISS_VALUE
,

236 
	gMISS_QUOTE
,

237 
	gMISS_COLON
,

238 
	gMISS_CURLY_CLOSE
,

239 
	gMISS_SQUARE_CLOSE
,

240 
	gNOT_MATCH_NULL
,

241 
	gNOT_MATCH_TRUE
,

242 
	gNOT_MATCH_FALSE
,

243 
	gINVALID_WHITESPACE
,

244 
	gINVALID_ESCAPE
,

245 
	gINVALID_UNICODE
,

246 
	gINVALID_NUMBER_INTEGER
,

247 
	gINVALID_NUMBER_FRACTION
,

248 
	gINVALID_NUMBER_EXPONENT
,

249 
	gDUPLICATE_KEY
,

253 
Code
 
	gcode
{};

255 
size_t
 
	gle
{};

257 
size_t
 
	gcumn
{};

259 
size_t
 
	gsize
{};

261 
size_t
 
	gofft
{};

263 
Sg
 
	gda
{};

271 cڡ * 
decode
();

279 
bo
 
is_vid
() const;

286 
E
 
g_r
() const;

287 
	give
:

289 cڡ 
size_t
 
MAX_LIMIT_PER_OBJECT
;

291 
Aay
 
	gm_y
;

293 cڡ * 
	gm_beg
;

294 cڡ * 
	gm_cut
;

295 cڡ * 
	gm_d
;

296 
size_t
 
	gm_lim
;

297 
	gE
::
Code
 
m_r_code
;

298 
Sg
 
	gm_r_da
;

301 
bo
 
ad_obje
(
Vue
& 
vue
);

302 
bo
 
is_dui
(cڡ 
Vue
& 
vue
, cڡ 
Sg
& 
key
, cڡ 
size_t
& 
cou
);

303 
bo
 
ad_obje_memb
(
Vue
& 
vue
, 
size_t
& 
cou
);

304 
bo
 
ad_rg
(
Sg
& 
r
);

305 
bo
 
ad_rg_unicode
(
Sg
& 
r
);

306 
bo
 
ad_rg_es
(
Sg
& 
r
);

307 
bo
 
ad_vue
(
Vue
& 
vue
);

308 
bo
 
ad_y
(
Vue
& 
vue
);

309 
bo
 
ad_y_emt
(
Vue
& 
vue
, 
size_t
& 
cou
);

310 
bo
 
ad_c
();

311 
bo
 
ad_que
();

312 
bo
 
ad_ue
(
Vue
& 
vue
);

313 
bo
 
ad_l
(
Vue
& 
vue
);

314 
bo
 
ad_nu
(
Vue
& 
vue
);

315 
bo
 
ad_numb
(
Vue
& 
vue
);

316 
bo
 
ad_numb_dig
(
Ut64
& 
r
);

317 
bo
 
ad_numb_g
(
Numb
& 
numb
);

318 
bo
 
ad_numb_aiڮ
(
Numb
& 
numb
);

319 
bo
 
ad_numb_expڒt
(
Numb
& 
numb
);

320 
bo
 
ad_unicode
(cڡ ** 
pos
, 
ut32_t
& 
code
);

321 
bo
 
ad_wheas
();

323 
bo
 
cou_rg_chs
(
size_t
& 
cou
);

325 
r_r
();

326 
bo
 
t_r
(
E
::
Code
 
r_code
);

329 
Derliz
 
	gݔ
>>(cڡ * 
	gr
, 
	gVue
& 
	gvue
);

330 
Derliz
 
	gݔ
>>(cڡ 
	gSg
& 
	gr
, 
	gVue
& 
	gvue
);

	@open_source/json-cxx/include/json/formatter.hpp

44 #agm



45 
	~"js/vue.h
"

46 
	~"js/wrr.h
"

48 
mea
 
	gjs
 {

53 as
	cFmr
 {

54 
	gpublic
:

56 
cڡex
 cڡ 
JSON_NULL
[] = "null";

59 
cڡex
 cڡ 
	gJSON_TRUE
[] = "true";

62 
cڡex
 cڡ 
	gJSON_FALSE
[] = "false";

69 
vtu
 
execu
(cڡ 
Vue
& 
vue
) = 0;

79 
	gd
::
rg
 
es_chas
(cڡ 
d
::rg& 
r
);

82 
	gvtu
 ~
Fmr
();

83 
	geed
:

84 
Wrr
* 
m_wrr
 = 
nuαr
;

85 
	give
:

86 
nd
 
ass
 
Sliz
;

88 
t_wrr
(
Wrr
* 
wrr
{ 
	gm_wrr
 = writter; }

	@open_source/json-cxx/include/json/formatter/compact.hpp

44 #agm



45 
	~"js/fmr.h
"

47 
mea
 
	gjs
 {

48 
mea
 
	gfmr
 {

55 as
	cCom
 : 
public
 
Fmr
 {

56 
public
:

62 
execu
(cڡ 
Vue
& 
vue

f
 
ovride
;

65 ~
Com
();

66 
	geed
:

67 
vtu
 
wre_vue
(cڡ 
Vue
& 
vue
);

68 
vtu
 
wre_obje
(cڡ 
Vue
& 
vue
);

69 
vtu
 
wre_y
(cڡ 
Vue
& 
vue
);

70 
vtu
 
wre_numb
(cڡ 
Vue
& 
vue
);

71 
vtu
 
wre_rg
(cڡ 
Vue
& 
vue
);

72 
vtu
 
wre_boޗn
(cڡ 
Vue
& 
vue
);

73 
vtu
 
wre_emy
(cڡ 
Vue
& 
vue
);

	@open_source/json-cxx/include/json/formatter/pretty.hpp

44 #agm



45 
	~"js/fmr.h
"

46 
	~"js/fmr/com.h
"

48 
mea
 
	gjs
 {

49 
mea
 
	gfmr
 {

57 as
	cPy
 : 
public
 
Com
 {

58 
public
:

60 
cڡex
 cڡ 
size_t
 
DEFAULT_INDENT
 = 4;

65 
Py
(: 
m_dt
(
DEFAULT_INDENT
), 
m_v
(0) { }

68 ~
Py
();

78 
t_dt
(
size_t
 
dt
{ 
	gm_dt
 = indent; }

79 
	give
:

80 
wre_obje
(cڡ 
Vue
& 
vue

ovride
;

81 
wre_y
(cڡ 
Vue
& 
vue

	govride
;

83 
size_t
 
	gm_dt
;

84 
size_t
 
	gm_v
;

	@open_source/json-cxx/include/json/iterator.hpp

44 #agm



45 
	~"js/vue.h
"

47 
	~<uty
>

48 
	~<
>

51 
mea
 
	gjs
 {

54 
	gme
<
bo
 
	gis_cڡ
>

55 
ass
 
	gba_
;

65 
	gme
<
bo
 
	gis_cڡ
 = 
l
>

66 
ba_
<
is_cڡ
> 
ݔ
+(cڡ ba_<is_cڡ>& 

,

67 
tyme
 
	gba_
<
	gis_cڡ
>::
difn_ty
 
n
);

74 
	gme
<
bo
 
	gis_cڡ
 = 
l
>

75 
ba_
<
is_cڡ
> 
ݔ
+(

76 
tyme
 
ba_
<
is_cڡ
>::
difn_ty
,

77 cڡ 
	gba_
<
	gis_cڡ
>&);

84 
	gme
<
bo
 
	gis_cڡ
 = 
l
>

85 
ba_
<
is_cڡ
> 
ݔ
-(const base_iterator<is_const>&,

86 
tyme
 
	gba_
<
	gis_cڡ
>::
difn_ty
);

95 
	gme
<
bo
 
	gis_cڡ
 = 
l
>

96 as
	cba_
 {

97 
public
:

99 
me
<
bo
 
B
, 
ass
 
T
, cs
F
>

100 
usg
 
cdiڮ_t
 = 
tyme
 
d
::
cdiڮ
<
B
, 
	gT
, 
	gF
>::
ty
;

103 
usg
 
	gvue_ty
 = 
Vue
;

106 
usg
 
	gdifn_ty
 = 
d
::
rdiff_t
;

109 
usg
 
	gpor
 = 
cdiڮ_t
<
is_cڡ
, cڡ 
	gvue_ty
*, value_type*>;

112 
usg
 
	gn
 = 
cdiڮ_t
<
is_cڡ
, cڡ 
	gvue_ty
&, value_type&>;

115 
usg
 
	g_gy
 = 
d
::
ndom_acss__g
;

118 
usg
 
	gvue_
 = 
por
;

121 
usg
 
	gy_
 = 
cdiڮ_t
<
is_cڡ
,

122 
	gAay
::
cڡ_
, Aay::

>;

125 
usg
 
	gobje_
 = 
cdiڮ_t
<
is_cڡ
,

126 
	gObje
::
cڡ_
, Obje::

>;

133 
ba_
();

138 
ba_
(const base_iterator&) = ;

143 
ba_
(base_iterator&&) = ;

151 
	gme
<
	gtyme
 = 
tyme
 
d
::
ab_if
<
is_cڡ
>>

152 
ba_
(const base_iterator<>&);

157 
ba_
(cڡ 
vue_
&);

162 
ba_
(cڡ 
y_
&);

167 
ba_
(cڡ 
obje_
&);

174 cڡ * 
key
() const;

179 
bo
 
is_y
() const;

184 
bo
 
is_obje
() const;

192 
	gme
<
	gtyme
 = 
tyme
 
d
::
ab_if
<
is_cڡ
>>

193 
ba_
& 
ݔ
=(cڡ ba_<>& 

);

198 
	gba_
& 
	gݔ
=(cڡ 
ba_
& 

) = ;

203 
	gba_
& 
	gݔ
=(
ba_
&& 

) = ;

208 
	gba_
& 
	gݔ
++();

213 
ba_
 
	gݔ
++();

218 
n
 
	gݔ
*() const;

223 
por
 
	gݔ
->() const;

230 
n
 
	gݔ
[](
	gdifn_ty
) const;

237 
	gba_
& 
	gݔ
+=(
difn_ty
);

244 
	gba_
& 
	gݔ
-=(
difn_ty
);

247 
nd
 
	gVue
;

250 
nd
 
	gba_
<
	gue
>;

253 
nd
 
bo
 
	gݔ
<(cڡ 
	gba_
<
	gue
>&,

254 cڡ 
	gba_
<
	gue
>&);

257 
nd
 
bo
 
	gݔ
>(cڡ 
	gba_
<
	gue
>&,

258 cڡ 
	gba_
<
	gue
>&);

262 
nd
 
bo
 
	gݔ
<=(cڡ 
ba_
<
ue
>&,

263 cڡ 
	gba_
<
	gue
>&);

267 
nd
 
bo
 
	gݔ
>=(cڡ 
ba_
<
ue
>&,

268 cڡ 
	gba_
<
	gue
>&);

271 
nd
 
bo
 
	gݔ
==(

272 cڡ 
ba_
<
ue
>&,

273 cڡ 
	gba_
<
	gue
>&);

276 
nd
 
bo
 
	gݔ
!=(

277 cڡ 
ba_
<
ue
>&,

278 cڡ 
	gba_
<
	gue
>&);

281 
nd
 
ba_
 
	gݔ
+<>(cڡ 
	gba_
&,

282 
	gba_
::
difn_ty
);

285 
nd
 
ba_
 
	gݔ
+<>(
	gba_
::
difn_ty
,

286 cڡ 
	gba_
&);

289 
nd
 
ba_
 
	gݔ
-<>(cڡ 
	gba_
&,

290 
	gba_
::
difn_ty
);

293 
nd
 
	gba_
::
difn_ty
 
ݔ
-(

294 
ba_
<
ue
>,

295 
	gba_
<
	gue
>);

298 
nd
 
sw
(
ba_
<>&, base_iterator<>&);

299 
	give
:

300 
tyme
 
Vue
::
Ty
 
m_ty
;

303 
vue_
 
	gm_vue_
;

304 
y_
 
	gm_y_
;

305 
obje_
 
	gm_obje_
;

309 
bo
 
	gݔ
<(cڡ 
	gba_
<
	gue
>&, const base_iterator<true>&);

311 
bo
 
	gݔ
>(cڡ 
	gba_
<
	gue
>&, const base_iterator<true>&);

313 
bo
 
	gݔ
<=(cڡ 
ba_
<
ue
>&, cڡ 
	gba_
<
	gue
>&);

315 
bo
 
	gݔ
>=(cڡ 
ba_
<
ue
>&, cڡ 
	gba_
<
	gue
>&);

317 
bo
 
	gݔ
==(cڡ 
ba_
<
ue
>&, cڡ 
	gba_
<
	gue
>&);

319 
bo
 
	gݔ
!=(cڡ 
ba_
<
ue
>&, cڡ 
	gba_
<
	gue
>&);

321 
	gba_
<>::
difn_ty
 
ݔ
-(
ba_
<
ue
>,

322 
	gba_
<
	gue
>);

324 
sw
(
ba_
<>&, base_iterator<>&);

	@open_source/json-cxx/include/json/json.hpp

44 #agm



45 
	~"js/vue.h
"

46 
	~"js/numb.h
"

47 
	~"js/.h
"

48 
	~"js/wrr.h
"

49 
	~"js/fmr.h
"

50 
	~"js/rliz.h
"

51 
	~"js/derliz.h
"

	@open_source/json-cxx/include/json/number.hpp

44 #agm



45 
	~<cdt
>

47 
mea
 
	gjs
 {

50 
usg
 
	gUt
 = ;

53 
usg
 
	gI
 = ;

56 
usg
 
	gUt64
 = 
d
::
ut64_t
;

59 
usg
 
	gI64
 = 
d
::
t64_t
;

62 
usg
 
	gDoub
 = ;

68 as
	cNumb
 {

69 
	gpublic
:

70 
nd
 
ass
 
Derliz
;

73 as
	cTy
 {

74 
	gINT
,

75 
	gUINT
,

76 
	gDOUBLE


85 
Numb
(: 
m_ty
(
Ty
::
INT
), 
m_t
(0) { }

92 
Numb
(
I
 
vue
: 
m_ty
(
Ty
::
INT
), 
m_t
(value) { }

99 
Numb
(
Ut
 
vue
: 
m_ty
(
Ty
::
UINT
), 
m_ut
(value) { }

106 
Numb
(
I64
 
vue
: 
m_ty
(
Ty
::
INT
), 
m_t
(value) { }

113 
Numb
(
Ut64
 
vue
: 
m_ty
(
Ty
::
UINT
), 
m_ut
(value) { }

120 
Numb
(
Doub
 
vue
: 
m_ty
(
Ty
::
DOUBLE
), 
m_doub
(value) { }

132 
	gNumb
& 
	gݔ
+=(cڡ 
Numb
& 
numb
);

137 
exic
 
ݔ
 
I
() const;

142 
exic
 
ݔ
 
Ut
() const;

147 
exic
 
ݔ
 
I64
() const;

152 
exic
 
ݔ
 
Ut64
() const;

157 
exic
 
ݔ
 
Doub
() const;

164 
bo
 
is_t
(cڡ {  
	gTy
::
INT
 =
m_ty
; }

171 
bo
 
is_ut
(cڡ {  
	gTy
::
UINT
 =
m_ty
; }

178 
bo
 
is_doub
(cڡ {  
	gTy
::
DOUBLE
 =
m_ty
; }

185 
Ty
 
g_ty
(cڡ {  
	gm_ty
; }

192 
nd
 
bo
 
	gݔ
==(cڡ 
Numb
&, cڡ 
	gNumb
&);

199 
nd
 
bo
 
	gݔ
!=(cڡ 
Numb
&, cڡ 
	gNumb
&);

207 
nd
 
bo
 
	gݔ
<(cڡ 
	gNumb
&, const Number&);

208 
	give
:

209 
Ty
 
m_ty
;

212 
I64
 
	gm_t
;

213 
Ut64
 
	gm_ut
;

214 
Doub
 
	gm_doub
;

218 
bo
 
	gݔ
==(cڡ 
Numb
&, cڡ 
	gNumb
&);

219 
bo
 
	gݔ
<(cڡ 
	gNumb
&, const Number&);

220 
le
 
bo
 
	gݔ
!=(cڡ 
Numb
& 
num1
, cڡ 
	gNumb
& 
	gnum2
) {

221  !(
	gnum1
 =
num2
);

	@open_source/json-cxx/include/json/serializer.hpp

44 #agm



45 
	~"js/vue.h
"

46 
	~"js/fmr.h
"

48 
mea
 
	gjs
 {

54 as
	cSliz
 {

55 
	gpublic
:

63 
Sliz
(
Fmr
* 
fmr
 = 
nuαr
: 
m_fmr
{formatter} { }

73 
Sliz
(cڡ 
Vue
& 
vue
, 
Fmr
* 
fmr
 = 
nuαr
) :

74 
m_fmr
{
fmr
} {

75 (*
this
)<<(
vue
);

83 
	gSliz
& 
	gݔ
<<(cڡ 
	gVue
& 
	gvue
);

88 
r
({ 
	gm_rlized
.clear(); }

97 
nd
 
	gSg
& 
	gݔ
<<(Sg&, 
	gSliz
&);

107 
nd
 
	gSg
& 
	gݔ
<<(Sg&, 
	gSliz
&&);

116 
nd
 
	gd
::
oam
& 
ݔ
<<(
d
::oam&, 
	gSliz
&);

126 
nd
 
	gd
::
oam
& 
ݔ
<<(
d
::oam&, 
	gSliz
&&);

131 
ݔ
 cڡ 
	gd
::
rg
& (cڡ {  
m_rlized
; }

132 
	give
:

133 
Sliz
(cڡ Sliz&
de
;

134 
Sliz
(Sliz&&
de
;

136 
	gSliz
& 
	gݔ
=(cڡ 
Sliz
&
de
;

137 
	gSliz
& 
	gݔ
=(
Sliz
&&
de
;

139 
Fmr
* 
	gm_fmr
 = 
nuαr
;

140 
Sg
 
	gm_rlized
 {};

143 
	gSg
& 
	gݔ
<<(Sg& 
	gr
, 
	gSliz
& 
	grliz
);

144 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, 
	gSliz
& 
	grliz
);

145 
	gSg
& 
	gݔ
<<(Sg& 
	gr
, 
	gSliz
&& 
	grliz
);

146 
	gd
::
oam
& 
ݔ
<<(
d
::oam& 
os
, 
	gSliz
&& 
	grliz
);

	@open_source/json-cxx/include/json/value.hpp

44 #agm



45 
	~"js/numb.h
"

47 
	~<rg
>

48 
	~<ve
>

49 
	~<dex
>

50 
	~<uty
>

52 
mea
 
	gjs
 {

54 
	gme
<
bo
 
	gis_cڡ
>

55 
ass
 
	gba_
;

57 
ass
 
	gVue
;

60 
usg
 
	gSg
 = 
d
::
rg
;

63 
usg
 
	gPa
 = 
d
::

<
Sg
, 
	gVue
>;

66 
usg
 
	gObje
 = 
d
::
ve
<
Pa
>;

69 
usg
 
	gAay
 = 
d
::
ve
<
Vue
>;

72 
usg
 
	gBo
 = 
bo
;

75 
usg
 
	gNu
 = 
d
::
nuαr_t
;

82 as
	cVue
 {

83 
	gpublic
:

84 
nd
 
ass
 
Derliz
;

87 
usg
 
	g
 = 
ba_
<
l
>;

90 
usg
 
	gcڡ_
 = 
ba_
<
ue
>;

93 as
	cTy
 {

94 
	gNIL
,

95 
	gOBJECT
,

96 
	gARRAY
,

97 
	gSTRING
,

98 
	gNUMBER
,

99 
	gBOOLEAN


105 as
	cExi
 : 
public
 
d
::
ruime_r
 {

106 
public
:

112 
Exi
(cڡ * 
r
);

119 
Exi
(cڡ 
d
::
rg
& 
r
);

122 
Exi
(const Exception&) = ;

125 ~
Exi
();

138 
Vue
(
Ty
 
ty
 = Ty::
NIL
);

152 
Vue
(
Nu
 
nu
);

161 
Vue
(
Bo
 
boޗn
);

171 
Vue
(cڡ * 
r
);

181 
Vue
(cڡ 
Sg
& 
r
);

191 
Vue
(cڡ 
Pa
& 

);

203 
Vue
(cڡ * 
key
, cڡ Vue& 
vue
);

214 
Vue
(cڡ 
Sg
& 
key
, cڡ Vue& 
vue
);

223 
Vue
(
Ut
 
vue
);

232 
Vue
(
I
 
vue
);

241 
Vue
(
Ut64
 
vue
);

250 
Vue
(
I64
 
vue
);

259 
Vue
(
Doub
 
vue
);

268 
Vue
(cڡ 
Numb
& 
numb
);

276 
Vue
(
size_t
 
cou
, cڡ Vue& 
vue
);

283 
Vue
(
d
::
liz_li
<
Pa
> 
_li
);

290 
Vue
(
d
::
liz_li
<Vue> 
_li
);

295 
Vue
(cڡ Vue& 
vue
);

303 
Vue
(Vue&& 
vue
);

310 ~
Vue
();

320 
	gVue
& 
	gݔ
=(cڡ 
Vue
& 
vue
);

331 
	gVue
& 
	gݔ
=(
Vue
&& 
vue
);

341 
	gVue
& 
	gݔ
=(
d
::
liz_li
<
Pa
> 
_li
);

351 
	gVue
& 
	gݔ
=(
d
::
liz_li
<
Vue
> 
_li
);

364 
	gVue
& 
	gݔ
+=(cڡ 
Vue
& 
vue
);

375 
assign
(
size_t
 
cou
, cڡ 
Vue
& 
vue
);

385 
assign
(
d
::
liz_li
<
Pa
> 
_li
);

395 
assign
(
d
::
liz_li
<
Vue
> 
_li
);

405 
push_back
(cڡ 
Pa
& 

);

415 
push_back
(cڡ 
Vue
& 
vue
);

422 
p_back
();

431 
size_t
 
size
() const;

441 
r
();

450 
bo
 
emy
(cڡ {  !
size
(); }

459 
size_t
 
a
(cڡ 
Sg
& 
key
);

468 
size_t
 
a
(cڡ * 
key
);

478 

 
a
(
cڡ_
 
pos
);

489 

 
a
(
cڡ_
 
f
, cڡ_ 
ϡ
);

499 

 

(
cڡ_
 
pos
, cڡ 
Vue
& 
vue
);

509 

 

(
cڡ_
 
pos
, 
Vue
&& 
vue
);

520 

 

(
cڡ_
 
pos
, 
size_t
 
cou
, cڡ 
Vue
& 
vue
);

532 

 

(
cڡ_
 
pos
,

533 
cڡ_
 
f
, cڡ_ 
ϡ
);

545 

 

(
cڡ_
 
pos
, 
d
::
liz_li
<
Vue
> 
_li
);

552 
sw
(
Vue
& 
vue
);

572 
	gVue
& 
	gݔ
[](
size_t
 
	gdex
);

584 cڡ 
	gVue
& 
	gݔ
[](
size_t
 
	gdex
) const;

603 
	gVue
& 
	gݔ
[](
	gdex
);

614 cڡ 
	gVue
& 
	gݔ
[](
	gdex
) const;

628 
	gVue
& 
	gݔ
[](cڡ * 
	gkey
);

640 cڡ 
	gVue
& 
	gݔ
[](cڡ * 
	gkey
) const;

654 
	gVue
& 
	gݔ
[](cڡ 
	gSg
& 
	gkey
);

666 cڡ 
	gVue
& 
	gݔ
[](cڡ 
	gSg
& 
	gkey
) const;

671 
Ty
 
g_ty
(cڡ {  
	gm_ty
; }

677 
bo
 
is_rg
() const {

678  
	gTy
::
STRING
 =
m_ty
;

685 
bo
 
is_obje
() const {

686  
	gTy
::
OBJECT
 =
m_ty
;

693 
bo
 
is_y
() const {

694  
	gTy
::
ARRAY
 =
m_ty
;

701 
bo
 
is_numb
() const {

702  
	gTy
::
NUMBER
 =
m_ty
;

709 
bo
 
is_boޗn
() const {

710  
	gTy
::
BOOLEAN
 =
m_ty
;

717 
bo
 
is_nu
() const {

718  
	gTy
::
NIL
 =
m_ty
;

725 
bo
 
is_t
() const {

726  
is_numb
(? 
Numb
(
m_numb
).
is_t
(: 
l
;

733 
bo
 
is_ut
() const {

734  
is_numb
(? 
Numb
(
m_numb
).
is_ut
(: 
l
;

741 
bo
 
is_doub
() const {

742  
is_numb
(? 
Numb
(
m_numb
).
is_doub
(: 
l
;

752 
bo
 
is_memb
(cڡ 
d
::
rg
& 
key
) const;

761 
bo
 
is_memb
(cڡ * 
key
) const;

764 
exic
 
ݔ
 
	gSg
&({  
	gm_rg
; }

767 
exic
 
ݔ
 cڡ 
	gSg
&(cڡ {  
	gm_rg
; }

770 
exic
 
ݔ
 cڡ *(cڡ {  
	gm_rg
.
c_r
(); }

773 
exic
 
ݔ
 
Bo
(cڡ {  
	gm_boޗn
; }

776 
exic
 
ݔ
 
Nu
(cڡ {  
	gnuαr
; }

779 
exic
 
ݔ
 
I
(cڡ {  I(
m_numb
); }

782 
exic
 
ݔ
 
Ut
(cڡ {  Ut(
m_numb
); }

785 
exic
 
ݔ
 
I64
(cڡ {  I64(
m_numb
); }

788 
exic
 
ݔ
 
Ut64
(cڡ {  Ut64(
m_numb
); }

791 
exic
 
ݔ
 
Doub
(cڡ {  Doub(
m_numb
); }

794 
exic
 
ݔ
 
	gAay
&({  
	gm_y
; }

797 
exic
 
ݔ
 
	gNumb
&({  
	gm_numb
; }

800 
exic
 
ݔ
 cڡ 
	gAay
&(cڡ {  
	gm_y
; }

803 
exic
 
ݔ
 cڡ 
	gObje
&(cڡ {  
	gm_obje
; }

806 
exic
 
ݔ
 cڡ 
	gNumb
&(cڡ {  
	gm_numb
; }

809 
	gSg
& 
as_rg
();

812 cڡ 
	gSg
& 
as_rg
() const;

815 cڡ * 
as_ch
() const;

818 
Bo
 
as_bo
() const;

821 
Nu
 
as_nu
() const;

824 
I
 
as_t
() const;

827 
Ut
 
as_ut
() const;

830 
I64
 
as_t64
() const;

833 
Ut64
 
as_ut64
() const;

836 
Doub
 
as_doub
() const;

839 
	gAay
& 
as_y
();

842 
	gNumb
& 
as_numb
();

845 cڡ 
	gAay
& 
as_y
() const;

848 cڡ 
	gObje
& 
as_obje
() const;

851 cڡ 
	gNumb
& 
as_numb
() const;

854 
bo
 
	gݔ
!(cڡ {  
is_nu
(); }

857 
nd
 
bo
 
	gݔ
==(cڡ 
Vue
&, cڡ 
	gVue
&);

860 
nd
 
bo
 
	gݔ
!=(cڡ 
Vue
&, cڡ 
	gVue
&);

863 
nd
 
bo
 
	gݔ
<(cڡ 
	gVue
&, const Value&);

866 
nd
 
bo
 
	gݔ
>(cڡ 
	gVue
&, const Value&);

869 
nd
 
bo
 
	gݔ
<=(cڡ 
Vue
&, cڡ 
	gVue
&);

872 
nd
 
bo
 
	gݔ
>=(cڡ 
Vue
&, cڡ 
	gVue
&);

875 

 
beg
();

878 

 
d
();

881 
cڡ_
 
beg
() const;

884 
cڡ_
 
d
() const;

887 
cڡ_
 
cbeg
() const;

890 
cڡ_
 
nd
() const;

891 
	give
:

892 
Ty
 
m_ty
;

895 
Obje
 
	gm_obje
;

896 
Aay
 
	gm_y
;

897 
Sg
 
	gm_rg
;

898 
Numb
 
	gm_numb
;

899 
Bo
 
	gm_boޗn
;

902 
_cڏ
(
Ty
 
ty
);

906 
bo
 
	gݔ
==(cڡ 
Vue
&, cڡ 
	gVue
&);

909 
le
 
bo
 
	gݔ
!=(cڡ 
Vue
& 
v1
, cڡ 
	gVue
& 
	gv2
) {

910  !(
	gv1
 =
v2
);

914 
bo
 
	gݔ
< (cڡ 
	gVue
&, const Value&);

917 
le
 
bo
 
	gݔ
> (cڡ 
	gVue
& 
	gv1
, cڡ Vue& 
	gv2
) {

918  
	gv2
 < 
	gv1
;

922 
le
 
bo
 
	gݔ
<=(cڡ 
Vue
& 
v1
, cڡ 
	gVue
& 
	gv2
) {

923  !(
	gv2
 < 
	gv1
);

927 
le
 
bo
 
	gݔ
>=(cڡ 
Vue
& 
v1
, cڡ 
	gVue
& 
	gv2
) {

928  !(
	gv1
 < 
	gv2
);

	@open_source/json-cxx/include/json/writter.hpp

44 #agm



45 
	~<rg
>

47 
mea
 
	gjs
 {

52 as
	cWrr
 {

53 
	gpublic
:

57 
vtu
 
p_back
() = 0;

64 
vtu
 
push_back
(
ch
) = 0;

72 
vtu
 
nd
(
d
::
size_t
 
cou
, 
ch
) = 0;

79 
vtu
 
nd
(cڡ * 
r
) = 0;

86 
vtu
 
nd
(cڡ 
d
::
rg
& 
r
) = 0;

89 
	gvtu
 ~
Wrr
();

	@open_source/json-cxx/include/json/writter/counter.hpp

44 #agm



45 
	~"js/wrr.h
"

47 
	~<crg
>

49 
mea
 
	gjs
 {

50 
mea
 
	gwrr
 {

55 as
	cCou
 : 
public
 
Wrr
 {

56 
public
:

60 
Cou
(: 
m_cou
(0) { }

65 
p_back
({ --
m_cou
; }

70 
push_back
({ ++
	gm_cou
; }

77 
nd
(
d
::
size_t
 
cou
, { 
	gm_cou
 += count; }

84 
nd
(cڡ * 
r
{ 
	gm_cou
 +

(str); }

91 
nd
(cڡ 
d
::
rg
& 
r
{ 
m_cou
 +r.
size
(); }

98 
size_t
 
g_cou
({  
	gm_cou
; }

101 ~
Cou
();

102 
	give
:

103 
size_t
 
m_cou
;

	@open_source/json-cxx/include/json/writter/string.hpp

44 #agm



45 
	~"js/wrr.h
"

47 
mea
 
	gjs
 {

48 
mea
 
	gwrr
 {

53 as
	cSg
 : 
public
 
Wrr
 {

54 
public
:

58 
Sg
(
size_t
 
rve
 = 0: 
m_rg
 {} { m_string.reserve(reserve); }

63 
p_back
({ 
	gm_rg
.pop_back(); }

68 
push_back
(
ch
{ 
	gm_rg
.push_back(ch); }

76 
nd
(
size_t
 
cou
, 
ch
{ 
	gm_rg
.append(count, ch); }

83 
nd
(cڡ * 
r
{ 
	gm_rg
.append(str); }

90 
nd
(cڡ 
d
::
rg
& 
r
{ 
m_rg
.append(str); }

97 cڡ 
	gd
::
rg
& 
g_rg
(cڡ {  
m_rg
; }

106 
	gd
::
rg
&& 
move_rg
({  
d
::
move
(
m_rg
); }

109 ~
Sg
();

110 
	give
:

111 
d
::
rg
 
m_rg
;

	@open_source/json-cxx/src/deserializer.cpp

44 
	~"js/derliz.h
"

47 
	~<cmh
>

48 
	~<crg
>

49 
	~<lims
>

51 
	#RSIZE_MAX_STR
 ( 4UL << 10 )

	)

53 
usg
 
mea
 
	gjs
;

56 
usg
 
	gCode
 = 
Derliz
::
E
::
Code
;

59 
usg
 
	gSuoge
 = 
d
::

<, >;

62 cڡ 
size_t
 
	gDerliz
::
MAX_LIMIT_PER_OBJECT
 = 0xFFFFFFFF;

64 
cڡex
 
	gJSON_NULL
[] = "null";

65 
cڡex
 
	gJSON_TRUE
[] = "true";

66 
cڡex
 
	gJSON_FALSE
[] = "false";

67 
cڡex
 
size_t
 
	gUNICODE_LENGTH
 = 4;

73 
	gme
<
size_t
 
	gN
>

74 
cڡex
 
size_t
 
ngth
(cڡ (&)[
N
]{  (
	gN
 - 1); }

80 
	gme
<
ass
 
	gT
, 
size_t
 
	gN
>

81 
cڡex
 
size_t
 
y_size
(
T
 (&)[
N
]{  
	gN
; }

83 
	gDerliz
::
	$Derliz
() :

84 
m_y
{
	}
},

85 
m_beg
(
nuαr
),

86 
m_cut
(
nuαr
),

87 
m_d
(
nuαr
),

88 
m_lim
(
MAX_LIMIT_PER_OBJECT
),

89 
m_r_code
(
Code
::
NONE
),

90 
	$m_r_da
({ 
	}
}

92 
	gDerliz
::
	$Derliz
(cڡ 
Derliz
& 
derliz
: 
	$Derliz
() {

93 
m_y
 = 
derliz
.m_array;

94 
	}
}

96 
	gDerliz
::
	$Derliz
(
Derliz
&& 
derliz
: 
	$Derliz
() {

97 
m_y
 = 
d
::
	`move
(
derliz
.m_array);

98 
derliz
.
m_y
.
	`r
();

100 
derliz
.
m_beg
 = 
nuαr
;

101 
derliz
.
m_cut
 = 
nuαr
;

102 
derliz
.
m_d
 = 
nuαr
;

103 
derliz
.
m_r_code
 = 
Code
::
NONE
;

104 
	}
}

106 
	gDerliz
::
	$Derliz
(cڡ * 
r
: 
	$Derliz
() {

107 (*
this
<< 
r
;

108 
	}
}

110 
	gDerliz
::
	$Derliz
(cڡ 
Sg
& 
r
: 
	$Derliz
() {

111 (*
this
<< 
r
;

112 
	}
}

114 
	gDerliz
& Derliz::
ݔ
=(cڡ 
Derliz
& 
derliz
) {

115 i(
this
 =&
derliz
) {  *this; }

117 
	gm_y
 = 
derliz
.
m_y
;

119 
	gm_beg
 = 
nuαr
;

120 
	gm_cut
 = 
nuαr
;

121 
	gm_d
 = 
nuαr
;

122 
	gm_r_code
 = 
Code
::
NONE
;

124  *
	gthis
;

127 
	gDerliz
& Derliz::
ݔ
=(
Derliz
&& 
derliz
) {

128 i(
this
 =&
derliz
) {  *this; }

130 
	gm_y
 = 
d
::
move
(
derliz
.
m_y
);

131 
	gderliz
.
	gm_y
.
r
();

133 
	gm_beg
 = 
nuαr
;

134 
	gm_cut
 = 
nuαr
;

135 
	gm_d
 = 
nuαr
;

136 
	gm_r_code
 = 
Code
::
NONE
;

138 
	gderliz
.
	gm_beg
 = 
nuαr
;

139 
	gderliz
.
	gm_cut
 = 
nuαr
;

140 
	gderliz
.
	gm_d
 = 
nuαr
;

141 
	gderliz
.
	gm_r_code
 = 
Code
::
NONE
;

143  *
	gthis
;

146 
	gDerliz
& Derliz::
ݔ
<<(cڡ * 
r
) {

147 
r_r
();

149 
size_t
 
	gr_size
 = 0;

151 i(
	gnuαr
 !
r
) {

152 
r_size
 = 

(
r
);

155 
	gm_beg
 = 
r
;

156 
	gm_cut
 = 
m_beg
;

157 
	gm_d
 = 
r
 + 
r_size
;

159 
Vue
 
	gvue
;

160 i(
ad_vue
(
vue
)) {

161 i(!
ad_wheas
()) {

162 
r_r
();

163 
	gm_y
.
push_back
(
d
::
move
(
vue
));

165 
t_r
(
Code
::
INVALID_WHITESPACE
);

169  *
	gthis
;

172 
	gDerliz
& Derliz::
ݔ
<<(cڡ 
Sg
& 
r
) {

173 
r_r
();

175 
	gm_beg
 = 
r
.
cbeg
().
ba
();

176 
	gm_cut
 = 
m_beg
;

177 
	gm_d
 = 
r
.
nd
().
ba
();

179 
Vue
 
	gvue
;

180 i(
ad_vue
(
vue
)) {

181 i(!
ad_wheas
()) {

182 
r_r
();

183 
	gm_y
.
push_back
(
d
::
move
(
vue
));

185 
t_r
(
Code
::
INVALID_WHITESPACE
);

189  *
	gthis
;

192 
	gDerliz
& Derliz::
ݔ
>>(
Vue
& 
vue
) {

193 i(
m_y
.
emy
()) {

194 
vue
 = 
Vue
::
Ty
::
NIL
;

197 
	gvue
 = 
d
::
move
(
m_y
.
back
());

198 
	gm_y
.
p_back
();

201  *
	gthis
;

204 
Derliz
 
	gjs
::
ݔ
>>(cڡ * 
r
, 
	gVue
& 
	gv
) {

205  
Derliz
(
r
>> 
	gv
;

208 
Derliz
 
	gjs
::
ݔ
>>(cڡ 
Sg
& 
r
, 
	gVue
& 
	gv
) {

209  
Derliz
(
r
>> 
	gv
;

212 
bo
 
	gDerliz
::
	$emy
() const {

213  
m_y
.
	`emy
();

214 
	}
}

216 
size_t
 
	gDerliz
::
	$size
() const {

217  
m_y
.
	`size
();

218 
	}
}

220 
	gDerliz
::
	$t_lim
(
size_t
 
lim
) {

221 
m_lim
 = 
lim
;

222 
	}
}

224 
le
 
	gDerliz
::
	$r_r
() {

225 
m_r_code
 = 
Code
::
NONE
;

226 
m_r_da
.
	`r
();

227 
	}
}

229 
	gDerliz
::
E
 
Derliz
::
	$g_r
() const {

230 
E
 
r
;

232 
r
.
code
 = 
m_r_code
;

233 
r
.
da
 = 
m_r_da
;

234 
r
.
le
 = 1;

235 
r
.
cumn
 = 1;

236 
r
.
offt
 = 
	`size_t
(
m_cut
 - 
m_beg
);

237 
r
.
size
 = 
	`size_t
(
m_d
 - 
m_beg
);

239 cڡ * 
ch
 = 
m_beg
;

241 
ch
 < 
m_cut
) {

242 i('\n' =*
ch
) {

243 ++
r
.
le
;

244 
r
.
cumn
 = 1;

247 ++
r
.
cumn
;

249 ++
ch
;

252  
r
;

253 
	}
}

255 
bo
 
	gDerliz
::
	$is_vid
() const {

256  
Code
::
NONE
 !
m_r_code
;

257 
	}
}

259 
bo
 
	gDerliz
::
	$ad_obje
(
Vue
& 
vue
) {

260 i(!
	`ad_wheas
(){  
l
; }

262 
vue
.
m_ty
 = 
Vue
::
Ty
::
OBJECT
;

263 
	`w
 (&
vue
.
m_obje

	`Obje
();

265 i('}' =*
m_cut
) {

266 ++
m_cut
;

267  
ue
;

270 
size_t
 
cou
 = 0;

272  
	`ad_obje_memb
(
vue
, 
cou
);

273 
	}
}

275 
bo
 
	gDerliz
::
	$is_dui
(cڡ 
Vue
& 
vue
, cڡ 
Sg
& 
key
, cڡ 
size_t
& 
cou
) {

278 
size_t
 
i
 = 
cou
; i < 
vue
.
m_obje
.
	`size
(); ++i) {

279 i(
vue
.
m_obje
[
i
].
f
 =
key
) {

280 
m_r_da
 = 
key
;

281  
ue
;

284  
l
;

285 
	}
}

287 
bo
 
	gDerliz
::
	$ad_obje_memb
(
Vue
& 
vue
, 
size_t
& 
cou
) {

288 
Sg
 
key
;

289 
Vue
 
tmp
;

291 i(!
	`ad_que
(){  
l
; }

292 i(!
	`ad_rg
(
key
){  
l
; }

293 i(!
	`ad_c
(){  
l
; }

294 i(!
	`ad_vue
(
tmp
){  
l
; }

295 i(!
	`ad_wheas
(){  
l
; }

297 ++
cou
;

299 i(',' =*
m_cut
) {

300 ++
m_cut
;

301 i(!
	`ad_obje_memb
(
vue
, 
cou
){  
l
; }

302 i(
	`is_dui
(
vue
, 
key
, 
cou
){ 
	`t_r
(
Code
::
DUPLICATE_KEY
);}

303 
vue
.
m_obje
[--
cou
].
f
 = 
d
::
	`move
(
key
);

304 
vue
.
m_obje
[
cou
].
cd
 = 
d
::
	`move
(
tmp
);

306 i('}' =*
m_cut
) {

307 ++
m_cut
;

308 i(
	`is_dui
(
vue
, 
key
, 
cou
){ 
	`t_r
(
Code
::
DUPLICATE_KEY
);}

309 
vue
.
m_obje
.
	`size
(
cou
);

310 
vue
.
m_obje
[--
cou
].
f
 = 
d
::
	`move
(
key
);

311 
vue
.
m_obje
[
cou
].
cd
 = 
d
::
	`move
(
tmp
);

315  
	`t_r
(
Code
::
MISS_CURLY_CLOSE
);

318  
ue
;

319 
	}
}

321 
le
 
bo
 
	gDerliz
::
	$ad_rg
(
Sg
& 
r
) {

322 
size_t
 
cy
 = 1;

323 
ch
;

325 i(!
	`cou_rg_chs
(
cy
)) {

326  
	`t_r
(
Code
::
END_OF_FILE
);

329 
r
.
	`rve
(
cy
);

331 
m_cut
 < 
m_d
) {

332 
ch
 = *(
m_cut
++);

333 
ch
) {

335  
ue
;

337 i(!
	`ad_rg_es
(
r
){  
l
; };

340 
r
.
	`push_back
(
ch
);

345  
	`t_r
(
Code
::
END_OF_FILE
);

346 
	}
}

348 
bo
 
	gDerliz
::
	$ad_rg_es
(
Sg
& 
r
) {

349 
ch
 = *
m_cut
;

351 
ch
) {

357 
ch
 = '\n';

360 
ch
 = '\r';

363 
ch
 = '\t';

366 
ch
 = '\b';

369 
ch
 = '\f';

372 ++
m_cut
;

373  
	`ad_rg_unicode
(
r
);

375  
	`t_r
(
Code
::
INVALID_ESCAPE
);

378 ++
m_cut
;

379 
r
.
	`push_back
(
ch
);

381  
ue
;

382 
	}
}

384 
le


385 
ut32_t
 
	$decode_utf16_suoge_
(cڡ 
Suoge
& 
suoge
) {

387 | ((0x03F & 
suoge
.
f
) << 10)

388 | (0x3FF & 
suoge
.
cd
);

389 
	}
}

391 
bo
 
	gDerliz
::
	$ad_rg_unicode
(
Sg
& 
r
) {

392 cڡ 
Suoge
 
	`SURROGATE_MIN
(0xD800, 0xDC00);

393 cڡ 
Suoge
 
	`SURROGATE_MAX
(0xDBFF, 0xDFFF);

395 
Suoge
 
suoge
;

396 
ut32_t
 
code
;

398 i(!
	`ad_unicode
(&
m_cut
, 
code
){  
l
; }

400 i(
m_cut
 + 2 + 
UNICODE_LENGTH
 < 
m_d
) {

401 i(('\\' =
m_cut
[0]) && ('u' == m_current[1])) {

402 
m_cut
 += 2;

403 i(
	`ad_unicode
(&
m_cut
, 
suoge
.
cd
)) {

404 
suoge
.
f
 = 
code
;

405 i((
SURROGATE_MIN
 <
suoge
)

406 && (
SURROGATE_MAX
 >
suoge
)) {

407 
code
 = 
	`decode_utf16_suoge_
(
suoge
);

409 { 
m_cut
 -(2 + 
UNICODE_LENGTH
); }

410 } {  
l
; }

414 i(
code
 < 0x80) {

415 
r
.
	`push_back
((
code
));

417 i(
code
 < 0x800) {

418 
r
.
	`push_back
((0xC0 | (0x1F & (
code
 >> 6))));

419 
r
.
	`push_back
((0x80 | (0x3F & (
code
 >> 0))));

421 i(
code
 < 0x10000) {

422 
r
.
	`push_back
((0xE0 | (0x0F & (
code
 >> 12))));

423 
r
.
	`push_back
((0x80 | (0x3F & (
code
 >> 6))));

424 
r
.
	`push_back
((0x80 | (0x3F & (
code
 >> 0))));

427 
r
.
	`push_back
((0xF0 | (0x07 & (
code
 >> 18))));

428 
r
.
	`push_back
((0x80 | (0x3F & (
code
 >> 12))));

429 
r
.
	`push_back
((0x80 | (0x3F & (
code
 >> 6))));

430 
r
.
	`push_back
((0x80 | (0x3F & (
code
 >> 0))));

433  
ue
;

434 
	}
}

436 
le
 
bo
 
	gDerliz
::
	$ad_unicode
(cڡ ** 
pos
, 
ut32_t
& 
code
) {

437 i(*
pos
 + 
UNICODE_LENGTH
 >
m_d
{  
	`t_r
(
Code
::
END_OF_FILE
); }

439 
cڡex
 
ut32_t
 
HEX_0_9
 = '0' - 0x0;

440 
cڡex
 
ut32_t
 
HEX_A_F
 = 'A' - 0xA;

441 
cڡex
 
ut32_t
 
HEX_a_f
 = 'a' - 0xA;

443 
ut32_t
 
ch
;

444 
size_t
 
cou
 = 
UNICODE_LENGTH
;

445 
code
 = 0;

447 
cou
--) {

448 
ch
 = 
	`ut32_t
(**
pos
);

449 
code
 <<= 4;

450 i(('0' <
ch
) && (ch <= '9')) {

451 
code
 |(
ch
 - 
HEX_0_9
);

453 i(('A' <
ch
) && (ch <= 'F')) {

454 
code
 |(
ch
 - 
HEX_A_F
);

456 i(('a' <
ch
) && (ch <= 'f')) {

457 
code
 |(
ch
 - 
HEX_a_f
);

460  
	`t_r
(
Code
::
INVALID_UNICODE
);

462 ++(*
pos
);

465  
ue
;

466 
	}
}

468 
le
 
bo
 
	gDerliz
::
	$cou_rg_chs
(
size_t
& 
cou
) {

469 cڡ 
Suoge
 
	`SURROGATE_MIN
(0xD800, 0xDC00);

470 cڡ 
Suoge
 
	`SURROGATE_MAX
(0xDBFF, 0xDFFF);

472 cڡ * 
pos
 = 
m_cut
;

474 
pos
 < 
m_d
) {

475 *
pos
) {

477  
ue
;

479 i('u' =*(++
pos
)) {

480 
ut32_t
 
code
;

481 i(!
	`ad_unicode
(&(++
pos
), 
code
){  
l
; }

482 i(
code
 < 0x80{ ++
cou
; }

483 i(
code
 < 0x800{ 
cou
 += 2; }

485 i((
SURROGATE_MIN
.
f
 > 
code
)

486 || (
SURROGATE_MAX
.
f
 < 
code
){ 
cou
 += 3; }

487 { 
cou
 += 4; }

490 ++
cou
;

491 ++
pos
;

495 ++
cou
;

496 ++
pos
;

501  
	`t_r
(
Code
::
END_OF_FILE
);

502 
	}
}

504 
bo
 
	gDerliz
::
	$ad_vue
(
Vue
& 
vue
) {

505 
bo
 
ok
 = 
l
;

506 
Sg
 
r
;

508 i(!
	`ad_wheas
(){  
l
; }

510 *
m_cut
) {

512 ++
m_cut
;

513 
ok
 = 
	`ad_rg
(
r
);

514 
vue
.
m_ty
 = 
Vue
::
Ty
::
STRING
;

515 
	`w
 (&
vue
.
m_rg

	`Sg
(
d
::
	`move
(
r
));

518 ++
m_cut
;

519 
ok
 = 
	`ad_obje
(
vue
);

522 ++
m_cut
;

523 
ok
 = 
	`ad_y
(
vue
);

526 
ok
 = 
	`ad_ue
(
vue
);

529 
ok
 = 
	`ad_l
(
vue
);

532 
ok
 = 
	`ad_nu
(
vue
);

535 
ok
 = 
	`ad_numb
(
vue
);

538 i(
d
::
	`isdig
(*
m_cut
)) {

539 
ok
 = 
	`ad_numb
(
vue
);

540 } { 
	`t_r
(
Code
::
MISS_VALUE
); }

544  
ok
;

545 
	}
}

547 
bo
 
	gDerliz
::
	$ad_y
(
Vue
& 
vue
) {

548 i(!
	`ad_wheas
(){  
l
; }

550 
vue
.
m_ty
 = 
Vue
::
Ty
::
ARRAY
;

551 
	`w
 (&
vue
.
m_y

	`Aay
();

553 i(']' =*
m_cut
) {

554 ++
m_cut
;

555  
ue
;

558 
size_t
 
cou
 = 0;

560  
	`ad_y_emt
(
vue
, 
cou
);

561 
	}
}

563 
bo
 
	gDerliz
::
	$ad_y_emt
(
Vue
& 
vue
, 
size_t
& 
cou
) {

564 
Vue
 
tmp
;

566 i(!
	`ad_vue
(
tmp
){  
l
; }

567 i(!
	`ad_wheas
(){  
l
; }

568 ++
cou
;

570 i(',' =*
m_cut
) {

571 ++
m_cut
;

572 i(!
	`ad_y_emt
(
vue
, 
cou
){  
l
; }

573 
vue
.
m_y
[--
cou
] = 
d
::
	`move
(
tmp
);

575 i(']' =*
m_cut
) {

576 ++
m_cut
;

577 
vue
.
m_y
.
	`size
(
cou
);

578 
vue
.
m_y
[--
cou
] = 
d
::
	`move
(
tmp
);

581  
	`t_r
(
Code
::
MISS_SQUARE_CLOSE
);

584  
ue
;

585 
	}
}

587 
le
 
bo
 
	gDerliz
::
	$ad_c
() {

588 i(!
	`ad_wheas
(){  
l
; }

589 i(':' !*
m_cut
) {

590  
	`t_r
(
Code
::
MISS_COLON
);

592 ++
m_cut
;

593  
ue
;

594 
	}
}

596 
le
 
bo
 
	gDerliz
::
	$ad_que
() {

597 i(!
	`ad_wheas
(){  
l
; }

598 i('"' !*
m_cut
) {

599  
	`t_r
(
Code
::
MISS_QUOTE
);

601 ++
m_cut
;

602  
ue
;

603 
	}
}

605 
bo
 
	gDerliz
::
	$ad_wheas
() {

606 
ch
;

608 
m_cut
 < 
m_d
) {

609 
ch
 = (*
m_cut
);

610 i((' ' =
ch
) || ('\n' == ch) || ('\r' == ch) || ('\t' == ch)) {

611 ++
m_cut
;

612 } {  
ue
; }

615  
	`t_r
(
Code
::
END_OF_FILE
);

616 
	}
}

618 
bo
 
	gDerliz
::
	$ad_numb_dig
(
Ut64
& 
vue
) {

619 
Ut64
 
max_ut64
 = 
d
::
numic_lims
<Ut64>::
	`max
();

620 
usg
 
d
::
isdig
;

622 i((
m_cut
 < 
m_d
&& 
	`isdig
(*m_current)) {

623 
vue
 = 
	`Ut64
(*
m_cut
 - '0');

624 ++
m_cut
;

625 } {  
l
; }

627 
m_cut
 < 
m_d
) {

628 i(
	`isdig
(*
m_cut
)) {

629 
Ut64
 
w_vue
 = 10 * 
vue
;

630 i(
w_vue
 / 10 !
vue
) {

631  
l
;

633 
Ut64
 
	`w_ϡ_dig
(*
m_cut
 - '0');

634 i(
w_vue
 > 
max_ut64
 - 
w_ϡ_dig
) {

635  
l
;

637 
vue
 = 
w_vue
 + 
w_ϡ_dig
;

638 ++
m_cut
;

639 } {  
ue
; }

642  
ue
;

643 
	}
}

645 
le
 
bo
 
	gDerliz
::
	$ad_numb_g
(
Numb
& 
numb
) {

647 
Ut64
 
abs_m_t64
 = 
	`Ut64
(
d
::
numic_lims
<
I64
>::
	`max
()) + 1;

649 
usg
 
d
::
isdig
;

651 
Ut64
 
vue
;

653 i(!
	`ad_numb_dig
(
vue
){  
l
; }

655 i(
Numb
::
Ty
::
UINT
 =
numb
.
m_ty
) {

656 
numb
.
m_ut
 = 
vue
;

658 i(
vue
 > 
abs_m_t64
) {

659  
l
;

661 
numb
.
m_t
 = 
	`I64
(-
vue
);

664  
ue
;

665 
	}
}

667 
le
 
bo
 
	gDerliz
::
	$ad_numb_aiڮ
(
Numb
& 
numb
) {

668 
usg
 
d
::
isdig
;

670 
Doub
 

 = 0.1;

671 
Doub
 
aiڮ
 = 0;

673 
m_cut
 < 
m_d
) {

674 i(
	`isdig
(*
m_cut
)) {

675 
aiڮ
 +(

 * (*
m_cut
 - '0'));

676 

 = 0.1 * step;

677 ++
m_cut
;

679 i(
Numb
::
Ty
::
UINT
 =
numb
.
m_ty
) {

680 
Doub
 
tmp
 = 
	`Doub
(
numb
.
m_ut
);

681 
numb
.
m_doub
 = 
tmp
 + 
aiڮ
;

683 
Doub
 
tmp
 = 
	`Doub
(
numb
.
m_t
);

684 
numb
.
m_doub
 = 
tmp
 - 
aiڮ
;

686 
numb
.
m_ty
 = 
Numb
::
Ty
::
DOUBLE
;

687  
ue
;

691  
	`t_r
(
Code
::
END_OF_FILE
);

692 
	}
}

694 
le
 
bo
 
	gDerliz
::
	$ad_numb_expڒt
(
Numb
& 
numb
) {

695 
usg
 
d
::
pow
;

697 
bo
 
is_give
 = 
l
;

698 
Ut64
 
vue
;

700 i('+' =*
m_cut
) {

701 ++
m_cut
;

702 } i('-' =*
m_cut
) {

703 
is_give
 = 
ue
;

704 ++
m_cut
;

707 i(!
	`ad_numb_dig
(
vue
){  
l
; }

709 
numb
.
m_ty
) {

710 
Numb
::
Ty
::
INT
:

711 i(
is_give
) {

712 
numb
.
m_doub
 *
	`pow
(0.1, 
vue
);

713 
numb
.
m_ty
 = 
Numb
::
Ty
::
DOUBLE
;

715 
numb
.
m_t
 *
	`I64
(
	`pow
(10, 
vue
));

718 
Numb
::
Ty
::
UINT
:

719 i(
is_give
) {

720 
numb
.
m_doub
 *
	`pow
(0.1, 
vue
);

721 
numb
.
m_ty
 = 
Numb
::
Ty
::
DOUBLE
;

723 
numb
.
m_ut
 *
	`Ut64
(
	`pow
(10, 
vue
));

726 
Numb
::
Ty
::
DOUBLE
:

727 i(
is_give
) {

728 
numb
.
m_doub
 *
	`pow
(0.1, 
vue
);

731 
numb
.
m_doub
 *
	`pow
(10, 
vue
);

738  
ue
;

739 
	}
}

741 
bo
 
	gDerliz
::
	$ad_numb
(
Vue
& 
vue
) {

742 
usg
 
d
::
isdig
;

745 
vue
.
m_ty
 = 
Vue
::
Ty
::
NUMBER
;

746 
	`w
 (&
vue
.
m_numb

	`Numb
();

748 i('-' =*
m_cut
) {

749 
vue
.
m_numb
.
m_ty
 = 
Numb
::
Ty
::
INT
;

750 
vue
.
m_numb
.
m_t
 = 0;

751 ++
m_cut
;

753 
vue
.
m_numb
.
m_ty
 = 
Numb
::
Ty
::
UINT
;

754 
vue
.
m_numb
.
m_ut
 = 0;

757 i('0' =*
m_cut
) {

758 ++
m_cut
;

759 } i(!
	`ad_numb_g
(
vue
.
m_numb
)) {

760  
	`t_r
(
Code
::
INVALID_NUMBER_INTEGER
);

763 i('.' =*
m_cut
) {

764 ++
m_cut
;

765 i(!
	`ad_numb_aiڮ
(
vue
.
m_numb
)) {

766  
	`t_r
(
Code
::
INVALID_NUMBER_FRACTION
);

770 i(('E' =*
m_cut
) || ('e' == *m_current)) {

771 ++
m_cut
;

772 i(!
	`ad_numb_expڒt
(
vue
.
m_numb
)) {

773  
	`t_r
(
Code
::
INVALID_NUMBER_EXPONENT
);

777  
ue
;

778 
	}
}

780 
le
 
bo
 
	gDerliz
::
	$ad_ue
(
Vue
& 
vue
) {

781 i(
m_cut
 + 
	`ngth
(
JSON_TRUE
> 
m_d
) {

782  
	`t_r
(
Code
::
END_OF_FILE
);

785 i(0 !
d
::
	`cmp
(
m_cut
, 
JSON_TRUE
, 
	`ngth
(JSON_TRUE))) {

786  
	`t_r
(
Code
::
NOT_MATCH_TRUE
);

789 
vue
.
m_ty
 = 
Vue
::
Ty
::
BOOLEAN
;

790 
vue
.
m_boޗn
 = 
ue
;

792 
m_cut
 +
	`ngth
(
JSON_TRUE
);

793  
ue
;

794 
	}
}

796 
le
 
bo
 
	gDerliz
::
	$ad_l
(
Vue
& 
vue
) {

797 i(
m_cut
 + 
	`ngth
(
JSON_FALSE
> 
m_d
) {

798  
	`t_r
(
Code
::
END_OF_FILE
);

801 i(0 !
d
::
	`cmp
(
m_cut
, 
JSON_FALSE
, 
	`ngth
(JSON_FALSE))) {

802  
	`t_r
(
Code
::
NOT_MATCH_FALSE
);

805 
vue
.
m_ty
 = 
Vue
::
Ty
::
BOOLEAN
;

806 
vue
.
m_boޗn
 = 
l
;

808 
m_cut
 +
	`ngth
(
JSON_FALSE
);

809  
ue
;

810 
	}
}

812 
le
 
bo
 
	gDerliz
::
	$ad_nu
(
Vue
& 
vue
) {

813 i(
m_cut
 + 
	`ngth
(
JSON_NULL
> 
m_d
) {

814  
	`t_r
(
Code
::
END_OF_FILE
);

817 i(0 !
d
::
	`cmp
(
m_cut
, 
JSON_NULL
, 
	`ngth
(JSON_NULL))) {

818  
	`t_r
(
Code
::
NOT_MATCH_NULL
);

821 
vue
.
m_ty
 = 
Vue
::
Ty
::
NIL
;

823 
m_cut
 +
	`ngth
(
JSON_NULL
);

824  
ue
;

825 
	}
}

827 
le
 
bo
 
	gDerliz
::
	$t_r
(
E
::
Code
 
r_code
) {

828 i(
Code
::
NONE
 =
m_r_code
) {

829 
m_r_code
 = 
r_code
;

831  
l
;

832 
	}
}

835 
	sECodes
 {

836 
	mDerliz
::
E
::
Code
 
code
;

837 cڡ * 
	mmesge
;

840 cڡ 
ECodes
 
	gg_r_codes
[] = {

841 { 
Code
::
NONE
, "Norror." },

842 { 
Code
::
END_OF_FILE
, "End of fileeached." },

843 { 
Code
::
MISS_QUOTE
, "Missing quote '\"' for string." },

844 { 
Code
::
MISS_COLON
, "Missing colon ':' in memberair." },

845 { 
Code
::
MISS_CURLY_CLOSE
, "Missing comma ',' or closing curly '}' for object." },

846 { 
Code
::
MISS_SQUARE_CLOSE
, "Missing comma ',' or closing square ']' forrray." },

847 { 
Code
::
NOT_MATCH_NULL
, "Did you mean 'null'?" },

848 { 
Code
::
NOT_MATCH_TRUE
, "Did you mean 'true'?" },

849 { 
Code
::
NOT_MATCH_FALSE
, "Did you mean 'false'?" },

850 { 
Code
::
MISS_VALUE
, "Missing value inrray/member." },

851 { 
Code
::
INVALID_WHITESPACE
, "Invalid whitespace character." },

852 { 
Code
::
INVALID_ESCAPE
, "Invalidscape character." },

853 { 
Code
::
INVALID_UNICODE
, "Invalid unicode." },

854 { 
Code
::
INVALID_NUMBER_INTEGER
, "Invalid integralart ofumber. Check forossible overflows beyond "

856 { 
Code
::
INVALID_NUMBER_FRACTION
, "Invalidumber fractionalart." },

857 { 
Code
::
INVALID_NUMBER_EXPONENT
, "Invalidumberxponentart." },

858 { 
Code
::
DUPLICATE_KEY
, "Duplicate key in object." }

861 cڡ * 
	gDerliz
::
E
::
	$decode
() {

862 cڡuto& 
r
 : 
g_r_codes
) {

863 i(
r
.
code
 == code) {

864  
r
.
mesge
;

868 
	}
}

	@open_source/json-cxx/src/formatter.cpp

44 
	~"js/fmr.h
"

46 
	~<gܙhm
>

48 
usg
 
mea
 
	gjs
;

50 
cڡex
 cڡ 
	gFmr
::
JSON_NULL
[];

51 
cڡex
 cڡ 
	gFmr
::
JSON_TRUE
[];

52 
cڡex
 cڡ 
	gFmr
::
JSON_FALSE
[];

54 
	gd
::
rg
 
Fmr
::
	$es_chas
(cڡ 
d
::
rg
& 
r
) {

55 
d
::
rg
::
difn_ty
 
cou
 =

56 
d
::
	`cou_if
(
r
.
	`cbeg
(), s.
	`nd
(),

57 [](cڡ & 
ch
) {  (('\\' == ch) || ('\"' == ch)); }

60 i(0 =
cou
{  
r
; }

62 
d
::
rg
 
esd
 {};

63 
esd
.
	`rve
(
r
.
	`size
(+ 
d
::
rg
::
	`size_ty
(
cou
));

65 
d
::
	`f_ch
(
r
.
	`cbeg
(), s.
	`nd
(),

66 [&
esd
](cڡ & 
ch
) {

67 i(('\\' =
ch
) || ('\"' == ch)) {

68 
esd
.
	`push_back
('\\');

70 
esd
.
	`push_back
(
ch
);

74  
esd
;

75 
	}
}

77 
	gFmr
::~
	$Fmr
({ 
	}
}

	@open_source/json-cxx/src/formatter/compact.cpp

44 
	~"js/fmr/com.h
"

46 
	~"js/.h
"

48 
	~<iom
>

49 
	~<sam
>

51 
usg
 
mea
 
	gjs
::
fmr
;

53 
	gCom
::~
	$Com
({ 
	}
}

55 
Com
::
	$execu
(cڡ 
js
::
Vue
& 
vue
) {

56 
	`wre_vue
(
vue
);

57 
	}
}

59 
	gCom
::
	$wre_vue
(cڡ 
Vue
& 
vue
) {

60 
vue
.
	`g_ty
()) {

61 
Vue
::
Ty
::
OBJECT
:

62 
	`wre_obje
(
vue
);

64 
Vue
::
Ty
::
ARRAY
:

65 
	`wre_y
(
vue
);

67 
Vue
::
Ty
::
STRING
:

68 
	`wre_rg
(
vue
);

70 
Vue
::
Ty
::
NUMBER
:

71 
	`wre_numb
(
vue
);

73 
Vue
::
Ty
::
BOOLEAN
:

74 
	`wre_boޗn
(
vue
);

76 
Vue
::
Ty
::
NIL
:

77 
	`wre_emy
(
vue
);

82 
	}
}

84 
	gCom
::
	$wre_obje
(cڡ 
Vue
& 
vue
) {

85 
m_wrr
->
	`push_back
('{');

87 cڡuto& 
memb
 : 
	`Obje
(
vue
)) {

88 
	`wre_rg
(
memb
.
f
);

89 
m_wrr
->
	`push_back
(':');

90 
	`wre_vue
(
memb
.
cd
);

91 
m_wrr
->
	`push_back
(',');

94 i(
vue
.
	`size
() > 0) {

95 
m_wrr
->
	`p_back
();

98 
m_wrr
->
	`push_back
('}');

99 
	}
}

101 
	gCom
::
	$wre_y
(cڡ 
Vue
& 
vue
) {

102 
m_wrr
->
	`push_back
('[');

104 cڡuto& 
v
 : 
vue
) {

105 
	`wre_vue
(
v
);

106 
m_wrr
->
	`push_back
(',');

109 i(
vue
.
	`size
() > 0) {

110 
m_wrr
->
	`p_back
();

113 
m_wrr
->
	`push_back
(']');

114 
	}
}

116 
	gCom
::
	$wre_rg
(cڡ 
Vue
& 
vue
) {

117 
m_wrr
->
	`push_back
('"');

118 
m_wrr
->
	`nd
(
	`es_chas
(
	`Sg
(
vue
)));

119 
m_wrr
->
	`push_back
('"');

120 
	}
}

122 
	gCom
::
	$wre_numb
(cڡ 
Vue
& 
vue
) {

123 
	`Numb
(
vue
).
	`g_ty
()) {

124 
Numb
::
Ty
::
INT
:

125 
m_wrr
->
	`nd
(
d
::
	`to_rg
(
	`I64
(
vue
)));

127 
Numb
::
Ty
::
UINT
:

128 
m_wrr
->
	`nd
(
d
::
	`to_rg
(
	`Ut64
(
vue
)));

130 
Numb
::
Ty
::
DOUBLE
: {

131 
d
::
rgam
 
am
;

132 
am
 << 
d
::
	`cisi
(16<< 
	`Doub
(
vue
);

133 
m_wrr
->
	`nd
(
am
.
	`r
());

139 
	}
}

141 
	gCom
::
	$wre_boޗn
(cڡ 
Vue
& 
vue
) {

142 
m_wrr
->
	`nd
((
ue
 =
	`Bo
(
vue
)? 
JSON_TRUE
 : 
JSON_FALSE
);

143 
	}
}

145 
	gCom
::
	$wre_emy
(cڡ 
Vue
&) {

146 
m_wrr
->
	`nd
(
JSON_NULL
);

147 
	}
}

	@open_source/json-cxx/src/formatter/pretty.cpp

44 
	~"js/fmr/ty.h
"

46 
	~"js/.h
"

48 
	~<iom
>

49 
	~<sam
>

51 
usg
 
mea
 
	gjs
::
fmr
;

53 
	gPy
::~
	$Py
({ 
	}
}

55 
Py
::
	$wre_obje
(cڡ 
Vue
& 
vue
) {

56 i(
vue
.
	`size
() > 0) {

57 
m_wrr
->
	`push_back
('{');

59 ++
m_v
;

60 
size_t
 
dt_ngth
 = 
m_dt
 * 
m_v
;

62 cڡ 
Obje
& 
obj
 = 
	`Obje
(
vue
);

63 aut

 = 
obj
.
	`cbeg
(); i< obj.
	`nd
(); ++it) {

64 
m_wrr
->
	`push_back
('\n');

65 
m_wrr
->
	`nd
(
dt_ngth
, ' ');

66 
	`wre_rg
(

->
f
);

67 
m_wrr
->
	`nd
(" : ");

68 
	`wre_vue
(

->
cd
);

69 
m_wrr
->
	`push_back
(',');

72 
m_wrr
->
	`p_back
();

73 
m_wrr
->
	`push_back
('\n');

75 --
m_v
;

77 
m_wrr
->
	`nd
(
m_dt
 * 
m_v
, ' ');

78 
m_wrr
->
	`push_back
('}');

81 
m_wrr
->
	`nd
("{}");

83 
	}
}

85 
	gPy
::
	$wre_y
(cڡ 
Vue
& 
vue
) {

86 i(
vue
.
	`size
() > 0) {

87 
m_wrr
->
	`push_back
('[');

89 ++
m_v
;

91 
size_t
 
dt_ngth
 = 
m_dt
 * 
m_v
;

93 cڡuto& 
v
 : 
vue
) {

94 
m_wrr
->
	`push_back
('\n');

95 
m_wrr
->
	`nd
(
dt_ngth
, ' ');

96 
	`wre_vue
(
v
);

97 
m_wrr
->
	`push_back
(',');

100 
m_wrr
->
	`p_back
();

101 
m_wrr
->
	`push_back
('\n');

103 --
m_v
;

105 
m_wrr
->
	`nd
(
m_dt
 * 
m_v
, ' ');

106 
m_wrr
->
	`push_back
(']');

109 
m_wrr
->
	`nd
("[]");

111 
	}
}

	@open_source/json-cxx/src/iterator.cpp

40 
	~"js/.h
"

42 
usg
 
mea
 
	gjs
;

44 
	gme
<
bo
 
	gis_cڡ
>

45 
	gba_
<
	gis_cڡ
>::
	$ba_
() :

46 
	$m_ty
(
Vue
::
Ty
::
ARRAY
)

48 
	`w
 (&
m_y_

	`y_
();

49 
	}
}

51 
mea
 
	gjs
 {

58 
	gme
<>

59 
	gme
<>

60 
	gba_
<
	gue
>::
ba_
(cڡ ba_<
l
>& 

) :

61 
m_ty
(

.m_type)

63 i(
is_y
()) {

64 
w
 (&
m_y_

y_
(

.m_array_iterator);

66 i(
is_obje
()) {

67 
w
 (&
m_obje_

obje_
(

.m_object_iterator);

70 
w
 (&
m_vue_

vue_
(

.m_value_iterator);

81 
	gme
<>

82 
	gme
<>

83 
	gba_
<
	gue
>&

84 
	gba_
<
	gue
>::
ݔ
=(cڡ 
ba_
<
l
>& 

) {

85 
m_ty
 = 

.m_type;

87 i(
is_y
()) {

88 
	gm_y_
 = 

.
m_y_
;

90 i(
is_obje
()) {

91 
	gm_obje_
 = 

.
m_obje_
;

94 
	gm_vue_
 = 

.
m_vue_
;

96  *
	gthis
;

101 
	gme
<
bo
 
	gis_cڡ
>

102 
	gba_
<
	gis_cڡ
>::
	$ba_
(cڡ 
vue_
& 

) :

103 
	`m_ty
(

->
	$g_ty
())

105 
	`w
 (&
m_vue_

	`vue_
(

);

106 
	}
}

108 
	gme
<
bo
 
	gis_cڡ
>

109 
	gba_
<
	gis_cڡ
>::
	$ba_
(cڡ 
y_
& 

) :

110 
	$m_ty
(
Vue
::
Ty
::
ARRAY
)

112 
	`w
 (&
m_y_

	`y_
(

);

113 
	}
}

115 
	gme
<
bo
 
	gis_cڡ
>

116 
	gba_
<
	gis_cڡ
>::
	$ba_
(cڡ 
obje_
& 

) :

117 
	$m_ty
(
Vue
::
Ty
::
OBJECT
)

119 
	`w
 (&
m_obje_

	`obje_
(

);

120 
	}
}

122 
	gme
<
bo
 
	gis_cڡ
>

123 
bo
 
	gba_
<
	gis_cڡ
>::
	$is_y
() const {

124  
Vue
::
Ty
::
ARRAY
 =
m_ty
;

125 
	}
}

127 
	gme
<
bo
 
	gis_cڡ
>

128 
bo
 
	gba_
<
	gis_cڡ
>::
	$is_obje
() const {

129  
Vue
::
Ty
::
OBJECT
 =
m_ty
;

130 
	}
}

132 
	gme
<
bo
 
	gis_cڡ
>

133 
	gba_
<
	gis_cڡ
>& ba_<is_cڡ>::
ݔ
++() {

134 i(
is_y
()) {

135 
m_y_
++;

137 i(
is_obje
()) {

138 
	gm_obje_
++;

141 
	gm_vue_
++;

143  *
	gthis
;

146 
	gme
<
bo
 
	gis_cڡ
>

147 
	gba_
<
	gis_cڡ
> ba_<is_cڡ>::
ݔ
++() {

148 
ba_
 
mp
(*
this
);

149 
	gݔ
++();

150  
	gmp
;

153 
	gme
<
bo
 
	gis_cڡ
>

154 
tyme
 
	gba_
<
	gis_cڡ
>::
por


155 
ba_
<
is_cڡ
>::
ݔ
->() const {

156 
por
 
r
;

157 i(
is_y
()) {

158 
	gr
 = &(*
m_y_
);

160 i(
is_obje
()) {

161 
	gr
 = &
m_obje_
->
cd
;

164 
	gr
 = 
m_vue_
;

166  
	gr
;

169 
	gme
<
bo
 
	gis_cڡ
>

170 
tyme
 
	gba_
<
	gis_cڡ
>::
n


171 
ba_
<
is_cڡ
>::
ݔ
*() const {

172  *
ݔ
->();

175 
	gme
<
bo
 
	gis_cڡ
>

176 
tyme
 
	gba_
<
	gis_cڡ
>::
n


177 
ba_
<
is_cڡ
>::
ݔ
[](
difn_ty
 
n
) const {

178 
por
 
r
;

180 i(
is_y
()) {

181 
	gr
 = &
m_y_
[
n
];

183 i(
is_obje
()) {

184 
	gr
 = &
m_obje_
[
n
].
cd
;

187 
	gr
 = &
m_vue_
[
n
];

190  *
	gr
;

193 
	gme
<
bo
 
	gis_cڡ
>

194 
	gba_
<
	gis_cڡ
>&

195 
	gba_
<
	gis_cڡ
>::
ݔ
+=(
difn_ty
 
n
) {

196 i(
is_y
()) {

197 
m_y_
 +
n
;

199 i(
is_obje
()) {

200 
	gm_obje_
 +
n
;

203 i(
	gn
 >= 0) {

204 
n
--{ ++
m_vue_
; }

207 
	gn
++{ --
	gm_vue_
; }

211  *
	gthis
;

214 
	gme
<
bo
 
	gis_cڡ
>

215 
	gba_
<
	gis_cڡ
>&

216 
	gba_
<
	gis_cڡ
>::
ݔ
-=(
difn_ty
 
n
) {

217 i(
is_y
()) {

218 
m_y_
 +-
n
;

220 i(
is_obje
()) {

221 
	gm_obje_
 +-
n
;

224 
	gm_vue_
 +-
n
;

227  *
	gthis
;

230 
	gme
<
bo
 
	gis_cڡ
>

231 cڡ * 
	gba_
<
	gis_cڡ
>::
	$key
() const {

232 i(
	`is_obje
()) {

233  
m_obje_
->
f
.
	`c_r
();

236 
	}
}

238 
bo
 
	gjs
::
ݔ
==(cڡ 
ba_
<
ue
>& 
1
,

239 cڡ 
	gba_
<
	gue
>& 
	g2
) {

240 i(
	g1
.
	gm_ty
 !
2
.
m_ty
{  
l
; }

242 
bo
 
	gsu
 = 
l
;

244 i(
	gVue
::
Ty
::
ARRAY
 =
1
.
m_ty
) {

245 
su
 = (
1
.
m_y_
 =
2
.m_array_iterator);

247 i(
	gVue
::
Ty
::
OBJECT
 =
1
.
m_ty
) {

248 
su
 = (
1
.
m_obje_
 =
2
.m_object_iterator);

251 
	gsu
 = (
1
.
m_vue_
 =
2
.m_value_iterator);

254  
	gsu
;

257 
bo
 
	gjs
::
ݔ
!=(cڡ 
ba_
<
ue
>& 
1
,

258 cڡ 
	gba_
<
	gue
>& 
	g2
) {

259  !(
	g1
 =
2
);

262 
bo
 
	gjs
::
ݔ
<(cڡ 
ba_
<
ue
>& 
1
,

263 cڡ 
	gba_
<
	gue
>& 
	g2
) {

264 i(
	g1
.
	gm_ty
 !
2
.
m_ty
{  
l
; }

266 
bo
 
	gsu
 = 
l
;

268 i(
	gVue
::
Ty
::
ARRAY
 =
1
.
m_ty
) {

269 
su
 = (
1
.
m_y_
 < 
2
.m_array_iterator);

271 i(
	gVue
::
Ty
::
OBJECT
 =
1
.
m_ty
) {

272 
su
 = (
1
.
m_obje_
 < 
2
.m_object_iterator);

275 
	gsu
 = (
1
.
m_vue_
 < 
2
.m_value_iterator);

278  
	gsu
;

281 
bo
 
	gjs
::
ݔ
>(cڡ 
ba_
<
ue
>& 
1
,

282 cڡ 
	gba_
<
	gue
>& 
	g2
) {

283  
	g2
 < 
	g1
;

286 
bo
 
	gjs
::
ݔ
<=(cڡ 
ba_
<
ue
>& 
1
,

287 cڡ 
	gba_
<
	gue
>& 
	g2
) {

288  !(
	g2
 < 
	g1
);

291 
bo
 
	gjs
::
ݔ
>=(cڡ 
ba_
<
ue
>& 
1
,

292 cڡ 
	gba_
<
	gue
>& 
	g2
) {

293  !(
	g1
 < 
	g2
);

296 
	gba_
<>::
difn_ty


297 
js
::
ݔ
-(
ba_
<
ue
> 
2
,

298 
	gba_
<
	gue
> 
	g1
) {

299 i(
	g1
.
	gm_ty
 !
2
.
m_ty
) {  0; }

301 
	gba_
<>::
difn_ty
 
n
 = 0;

303 i(
	g1
 < 
	g2
) {

304 
	g1
 < 
	g2
{ ++
	gn
; ++it1; }

307 
	g2
 < 
	g1
{ --
	gn
; ++it2; }

310  
	gn
;

313 
	gjs
::
sw
(
ba_
<>& 
1
, ba_<>& 
2
) {

314 i(
	g1
.
	gm_ty
 !
2
.
m_ty
) { ; }

316 i(
	gVue
::
Ty
::
ARRAY
 =
1
.
m_ty
) {

317 
sw
(
1
.
m_y_
, 
2
.m_array_iterator);

319 i(
	gVue
::
Ty
::
OBJECT
 =
1
.
m_ty
) {

320 
sw
(
1
.
m_obje_
, 
2
.m_object_iterator);

323 
Vue
* 
	gtmp
 = 
1
.
m_vue_
;

324 
	g1
.
	gm_vue_
 = 
2
.
m_vue_
;

325 
	g2
.
	gm_vue_
 = 
tmp
;

329 
	gme
<
bo
 
	gis_cڡ
>

330 
	gba_
<
	gis_cڡ
> 
	gjs
::
ݔ
+(

331 cڡ 
ba_
<
is_cڡ
>& 

,

332 
tyme
 
	gba_
<
	gis_cڡ
>::
difn_ty
 
n
) {

333 
ba_
<
is_cڡ
> 
tmp
 = 

;

334  
	gtmp
 +
n
;

337 
	gme
<
bo
 
	gis_cڡ
>

338 
	gba_
<
	gis_cڡ
> 
	gjs
::
ݔ
+(

339 
tyme
 
ba_
<
is_cڡ
>::
difn_ty
 
n
,

340 cڡ 
	gba_
<
	gis_cڡ
>& 
	g
) {

341  
	g
 + 
	gn
;

344 
	gme
<
bo
 
	gis_cڡ
>

345 
	gba_
<
	gis_cڡ
> 
	gjs
::
ݔ
-(cڡ 
ba_
<
is_cڡ
>& 

,

346 
tyme
 
	gba_
<
	gis_cڡ
>::
difn_ty
 
n
) {

347 
ba_
<
is_cڡ
> 
tmp
 = 

;

348  
	gtmp
 -
n
;

351 
mea
 
	gjs
 {

354 
me


355 
	gba_
<> 
	gݔ
+(cڡ ba_<>& 
	g
,

356 
	gba_
<>::
difn_ty
 
n
);

359 
me


360 
	gba_
<> 
	gݔ
+(ba_<>::
difn_ty
 
n
,

361 cڡ 
	gba_
<>& 
	g
);

364 
me


365 
	gba_
<> 
	gݔ
-(cڡ ba_<>& 
	g
,

366 
	gba_
<>::
difn_ty
 
n
);

369 
me


370 
	gba_
<
	gue
> 
	gݔ
+(cڡ ba_<ue>& 
	g
,

371 
	gba_
<
	gue
>::
difn_ty
 
n
);

374 
me


375 
	gba_
<
	gue
> 
	gݔ
+(ba_<ue>::
difn_ty
 
n
,

376 cڡ 
	gba_
<
	gue
>& 
	g
);

379 
me


380 
	gba_
<
	gue
> 
	gݔ
-(cڡ ba_<ue>& 
	g
,

381 
	gba_
<
	gue
>::
difn_ty
 
n
);

383 
me
 
ass
 
	gba_
<>;

384 
me
 
ass
 
	gba_
<
	gue
>;

	@open_source/json-cxx/src/number.cpp

44 
	~"js/numb.h
"

46 
	~<cmh
>

47 
	~<lims
>

49 
usg
 
mea
 
	gjs
;

51 
	gNumb
::
ݔ
 
	$Ut
() const {

52 
Ut64
 
vue
 = 0;

54 
m_ty
) {

55 
Ty
::
INT
:

56 
vue
 = 
	`Ut64
(
m_t
);

58 
Ty
::
UINT
:

59 
vue
 = 
m_ut
;

61 
Ty
::
DOUBLE
:

62 
vue
 = 
	`Ut64
(
d
::
	`round
(
m_doub
));

68  
	`Ut
(
vue
);

69 
	}
}

71 
	gNumb
::
ݔ
 
	$I
() const {

72 
I64
 
vue
 = 0;

74 
m_ty
) {

75 
Ty
::
INT
:

76 
vue
 = 
m_t
;

78 
Ty
::
UINT
:

79 
vue
 = 
	`I64
(
m_ut
);

81 
Ty
::
DOUBLE
:

82 
vue
 = 
	`I64
(
d
::
	`round
(
m_doub
));

88  
	`I
(
vue
);

89 
	}
}

91 
	gNumb
::
ݔ
 
	$Ut64
() const {

92 
Ut64
 
vue
 = 0;

94 
m_ty
) {

95 
Ty
::
INT
:

96 
vue
 = 
	`Ut64
(
m_t
);

98 
Ty
::
UINT
:

99 
vue
 = 
m_ut
;

101 
Ty
::
DOUBLE
:

102 
vue
 = 
	`Ut64
(
d
::
	`round
(
m_doub
));

108  
vue
;

109 
	}
}

111 
	gNumb
::
ݔ
 
	$I64
() const {

112 
I64
 
vue
 = 0;

114 
m_ty
) {

115 
Ty
::
INT
:

116 
vue
 = 
m_t
;

118 
Ty
::
UINT
:

119 
vue
 = 
	`I64
(
m_ut
);

121 
Ty
::
DOUBLE
:

122 
vue
 = 
	`I64
(
d
::
	`round
(
m_doub
));

128  
vue
;

129 
	}
}

131 
	gNumb
::
ݔ
 
	$Doub
() const {

132 
Doub
 
vue
 = 0;

134 
m_ty
) {

135 
Ty
::
INT
:

136 
vue
 = 
	`Doub
(
m_t
);

138 
Ty
::
UINT
:

139 
vue
 = 
	`Doub
(
m_ut
);

141 
Ty
::
DOUBLE
:

142 
vue
 = 
m_doub
;

148  
vue
;

149 
	}
}

151 
	gNumb
& Numb::
ݔ
+=(cڡ 
Numb
& 
numb
) {

152 
m_ty
) {

153 
Ty
::
INT
:

154 
m_t
 +
I
(
numb
);

156 
	gTy
::
UINT
:

157 
m_ut
 +
Ut
(
numb
);

159 
	gTy
::
DOUBLE
:

160 
m_doub
 +
Doub
(
numb
);

166  *
	gthis
;

169 
bo
 
	gjs
::
ݔ
==(cڡ 
Numb
& 
num1
, cڡ 
	gNumb
& 
	gnum2
) {

170 
bo
 
	gsu
 = 
l
;

172 
	gnum1
.
g_ty
()) {

173 
	gNumb
::
Ty
::
INT
:

174 
su
 = (
num1
.
m_t
 =
I64
(
num2
));

176 
	gNumb
::
Ty
::
UINT
:

177 
su
 = (
num1
.
m_ut
 =
Ut64
(
num2
));

179 
	gNumb
::
Ty
::
DOUBLE
:

180 
su
 = 
d
::
bs
(
num1
.
m_doub
 - 
Doub
(
num2
)) <

181 
d
::
numic_lims
<
Doub
>::
s
();

184 
su
 = 
l
;

188  
	gsu
;

191 
bo
 
	gjs
::
ݔ
<(cڡ 
Numb
& 
num1
, cڡ 
	gNumb
& 
	gnum2
) {

192 
bo
 
	gsu
 = 
l
;

194 
	gnum1
.
g_ty
()) {

195 
	gNumb
::
Ty
::
INT
:

196 
su
 = (
num1
.
m_t
 < 
I
(
num2
));

198 
	gNumb
::
Ty
::
UINT
:

199 
su
 = (
num1
.
m_ut
 < 
Ut
(
num2
));

201 
	gNumb
::
Ty
::
DOUBLE
:

202 
su
 = 
num1
.
m_doub
 < 
Doub
(
num2
);

205 
su
 = 
l
;

209  
	gsu
;

	@open_source/json-cxx/src/serializer.cpp

44 
	~"js/rliz.h
"

46 
	~"js/fmr/com.h
"

47 
	~"js/wrr/cou.h
"

48 
	~"js/wrr/rg.h
"

50 
usg
 
mea
 
	gjs
;

52 
	gSliz
& Sliz::
ݔ
<<(cڡ 
Vue
& 
vue
) {

53 
fmr
::
Com
 
com
 {};

54 
Fmr
* 
	gfmt
 = 
m_fmr
;

56 i(
	gnuαr
 =
fmt
{ fm&
com
; }

58 
	gwrr
::
Cou
 
cou
 {};

59 
	gfmt
->
t_wrr
(&
cou
);

60 
	gfmt
->
execu
(
vue
);

62 
	gwrr
::
Sg
 
r
 {
cou
.
g_cou
()};

63 
	gfmt
->
t_wrr
(&
r
);

64 
	gfmt
->
execu
(
vue
);

66 
	gm_rlized
 = 
r
.
move_rg
();

68  *
	gthis
;

71 
	gSg
& 
	gjs
::
ݔ
<<(
Sg
& 
r
, 
	gSliz
& 
	grliz
) {

72 
	gr
 +
rliz
.
m_rlized
;

73 
	grliz
.
r
();

74  
	gr
;

77 
	gd
::
oam
& 
js
::
ݔ
<<(
d
::oam& 
os
, 
	gSliz
& 
	grliz
) {

78 
	gos
 << 
	grliz
.
	gm_rlized
;

79 
	grliz
.
r
();

80  
	gos
;

83 
	gSg
& 
	gjs
::
ݔ
<<(
Sg
& 
r
, 
	gSliz
&& 
	grliz
) {

84 
	gr
 +
d
::
move
(
rliz
.
m_rlized
);

85 
	grliz
.
r
();

86  
	gr
;

89 
	gd
::
oam
& 
js
::
ݔ
<<(
d
::oam& 
os
, 
	gSliz
&& 
	grliz
) {

90 
	gos
 << 
	gd
::
move
(
rliz
.
m_rlized
);

91 
	grliz
.
r
();

92  
	gos
;

	@open_source/json-cxx/src/value.cpp

44 
	~"js/vue.h
"

45 
	~"js/.h
"

47 
	~<lims
>

48 
	~<ty_as
>

49 
	~<funiڮ
>

51 
usg
 
mea
 
	gjs
;

56 
	gme
<
tyme
 
	gT
>

57 
usg
 
	gw_memy
 = 
tyme
 
d
::
igd_age
<(
T
),

58 
	gd
::
ignmt_of
<
T
>::
vue
>::
ty
;

61 cڡ 
	gw_memy
<
	gVue
> 
	gg_nu_vue_w
 {};

64 cڡ * 
	gg_nu_vue_f
 = &
g_nu_vue_w
;

67 cڡ 
	gVue
& 
	gg_nu_vue
 = *
ic_
<cڡ 
Vue
*>(
g_nu_vue_f
);

69 
	gVue
::
Exi
::
	$Exi
(cڡ * 
r
: 
	$ruime_r
(
r
{ 
	}
}

71 
Vue
::
Exi
::
	$Exi
(cڡ 
d
::
rg
& 
r
: 
	$ruime_r
(
r
{ 
	}
}

73 
Vue
::
Exi
::~
	$Exi
({ 
	}
}

75 
Vue
::
	$Vue
(
Ty
 
ty
: 
	$m_ty
(
ty
) {

76 
	`_cڏ
(
ty
);

77 
	}
}

79 
	gVue
::
	$Vue
(
Nu
: 
	$m_ty
(
Ty
::
NIL
{ 
	}
}

81 
Vue
::
	$Vue
(
Bo
 
boޗn
: 
	$m_ty
(
Ty
::
BOOLEAN
) {

82 
m_boޗn
 = 
boޗn
;

83 
	}
}

85 
	gVue
::
	$Vue
(cڡ * 
r
: 
	$m_ty
(
Ty
::
STRING
) {

86 
	`w
 (&
m_rg

	`Sg
(
r
);

87 
	}
}

89 
	gVue
::
	$Vue
(cڡ 
Sg
& 
r
: 
	$m_ty
(
Ty
::
STRING
) {

90 
	`w
 (&
m_rg

	`Sg
(
r
);

91 
	}
}

93 
	gVue
::
	$Vue
(cڡ 
Pa
& 

: 
	$m_ty
(
Ty
::
OBJECT
) {

94 
	`w
 (&
m_obje

Obje
{

};

95 
	}
}

97 
	gVue
::
	$Vue
(cڡ * 
key
, cڡ 
Vue
& 
vue
: 
	$m_ty
(
Ty
::
OBJECT
) {

98 
	`w
 (&
m_obje

Obje
{
d
::
	`make_
(
key
, 
vue
)};

99 
	}
}

101 
	gVue
::
	$Vue
(cڡ 
Sg
& 
key
, cڡ 
Vue
& 
vue
: 
	$m_ty
(
Ty
::
OBJECT
) {

102 
	`w
 (&
m_obje

Obje
{
d
::
	`make_
(
key
, 
vue
)};

103 
	}
}

105 
	gVue
::
	$Vue
(
Ut
 
vue
: 
	$m_ty
(
Ty
::
NUMBER
) {

106 
	`w
 (&
m_numb

	`Numb
(
vue
);

107 
	}
}

109 
	gVue
::
	$Vue
(
I
 
vue
: 
	$m_ty
(
Ty
::
NUMBER
) {

110 
	`w
 (&
m_numb

	`Numb
(
vue
);

111 
	}
}

113 
	gVue
::
	$Vue
(
Ut64
 
vue
: 
	$m_ty
(
Ty
::
NUMBER
) {

114 
	`w
 (&
m_numb

	`Numb
(
vue
);

115 
	}
}

117 
	gVue
::
	$Vue
(
I64
 
vue
: 
	$m_ty
(
Ty
::
NUMBER
) {

118 
	`w
 (&
m_numb

	`Numb
(
vue
);

119 
	}
}

121 
	gVue
::
	$Vue
(
Doub
 
vue
: 
	$m_ty
(
Ty
::
NUMBER
) {

122 
	`w
 (&
m_numb

	`Numb
(
vue
);

123 
	}
}

125 
	gVue
::
	$Vue
(cڡ 
Numb
& 
numb
: 
	$m_ty
(
Ty
::
NUMBER
) {

126 
	`w
 (&
m_numb

	`Numb
(
numb
);

127 
	}
}

129 
	gVue
::
	$Vue
(
size_t
 
cou
, cڡ 
Vue
& 
vue
: 
	$m_ty
(
Ty
::
ARRAY
) {

130 
	`w
 (&
m_y

	`Aay
(
cou
, 
vue
);

131 
	}
}

133 
	gVue
::
Vue
(
d
::
liz_li
<
Pa
> 
_li
: 
	$m_ty
(
Ty
::
OBJECT
) {

134 
	`w
 (&
m_obje

	`Obje
();

136 aut

 = 
_li
.
	`beg
(); i< in_li.
	`d
(); ++it) {

137 (*
this
)[

->
f
] = it->
cd
;

139 
	}
}

141 
	gVue
::
Vue
(
d
::
liz_li
<Vue> 
_li
: 
	$m_ty
(
Ty
::
ARRAY
) {

142 
	`w
 (&
m_y

	`Aay
();

143 
m_y
 = 
_li
;

144 
	}
}

146 
	gVue
::~
	$Vue
() {

147 
m_ty
) {

148 
Ty
::
OBJECT
:

149 
m_obje
.~
	`ve
();

151 
Ty
::
ARRAY
:

152 
m_y
.~
	`ve
();

154 
Ty
::
STRING
:

155 
m_rg
.~
	`basic_rg
();

157 
Ty
::
NUMBER
:

158 
m_numb
.~
	`Numb
();

160 
Ty
::
BOOLEAN
:

161 
Ty
::
NIL
:

165 
	}
}

167 
	gVue
::
	$_cڏ
(
Ty
 
ty
) {

168 
m_ty
 = 
ty
;

169 
ty
) {

170 
Ty
::
OBJECT
:

171 
	`w
 (&
m_obje

	`Obje
();

173 
Ty
::
ARRAY
:

174 
	`w
 (&
m_y

	`Aay
();

176 
Ty
::
STRING
:

177 
	`w
 (&
m_rg

	`Sg
();

179 
Ty
::
NUMBER
:

180 
	`w
 (&
m_numb

	`Numb
();

182 
Ty
::
BOOLEAN
:

183 
m_boޗn
 = 
l
;

185 
Ty
::
NIL
:

189 
	}
}

191 
	gVue
::
	$Vue
(cڡ 
Vue
& 
vue
: 
	$m_ty
(
vue
.
m_ty
) {

192 
	`_cڏ
(
m_ty
);

193 
ݔ
=(
vue
);

194 
	}
}

196 
	gVue
::
	$Vue
(
Vue
&& 
vue
: 
	$m_ty
(
vue
.
m_ty
) {

197 
	`_cڏ
(
m_ty
);

198 
ݔ
=(
d
::
	`move
(
vue
));

199 
	}
}

201 
	gVue
& Vue::
ݔ
=(cڡ 
Vue
& 
vue
) {

202 i(&
vue
 =
this
) {  *this; }

204 i(
	gvue
.
	gm_ty
 !
m_ty
) {

205 
this
->~
Vue
();

206 
_cڏ
(
vue
.
m_ty
);

209 
	gm_ty
) {

210 
	gTy
::
OBJECT
:

211 
m_obje
 = 
vue
.m_object;

213 
	gTy
::
ARRAY
:

214 
m_y
 = 
vue
.m_array;

216 
	gTy
::
STRING
:

217 
m_rg
 = 
vue
.m_string;

219 
	gTy
::
NUMBER
:

220 
m_numb
 = 
vue
.m_number;

222 
	gTy
::
BOOLEAN
:

223 
m_boޗn
 = 
vue
.m_boolean;

225 
	gTy
::
NIL
:

230  *
	gthis
;

233 
	gVue
& Vue::
ݔ
=(
Vue
&& 
vue
) {

234 i(&
vue
 =
this
) {  *this; }

236 i(
	gvue
.
	gm_ty
 !
m_ty
) {

237 
this
->~
Vue
();

238 
_cڏ
(
vue
.
m_ty
);

241 
	gm_ty
) {

242 
	gTy
::
OBJECT
:

243 
m_obje
 = 
d
::
move
(
vue
.m_object);

245 
	gTy
::
ARRAY
:

246 
m_y
 = 
d
::
move
(
vue
.m_array);

248 
	gTy
::
STRING
:

249 
m_rg
 = 
d
::
move
(
vue
.m_string);

251 
	gTy
::
NUMBER
:

252 
m_numb
 = 
d
::
move
(
vue
.m_number);

254 
	gTy
::
BOOLEAN
:

255 
m_boޗn
 = 
d
::
move
(
vue
.m_boolean);

257 
	gTy
::
NIL
:

262  *
	gthis
;

265 
	gVue
& Vue::
ݔ
=(
d
::
liz_li
<
Pa
> 
_li
) {

266 
this
->~
Vue
();

267 
_cڏ
(
Ty
::
OBJECT
);

269 aut
	g
 = 
_li
.
beg
(); i< 
	g_li
.
d
(); ++it) {

270 (*
	gthis
)[

->
f
] = it->
cd
;

273  *
	gthis
;

276 
	gVue
& Vue::
ݔ
=(
d
::
liz_li
<
Vue
> 
_li
) {

277 
this
->~
Vue
();

278 
_cڏ
(
Ty
::
ARRAY
);

280 
	gm_y
 = 
_li
;

282  *
	gthis
;

285 
	gVue
& Vue::
ݔ
+=(cڡ 
Vue
& 
vue
) {

286 
m_ty
) {

287 
Ty
::
OBJECT
:

288 i(
vue
.
is_obje
()) {

289 aut

 = 
vue
.
cbeg
(); 
	gvue
.
nd
(!; ++
	g
) {

290 (*
	gthis
)[

.
key
()] = *it;

294 
	gTy
::
ARRAY
:

295 i(
vue
.
is_y
()) {

296 
m_y
.

(m_y.
d
(),

297 
vue
.
m_y
.
beg
(),

298 
vue
.
m_y
.
d
());

300 i(
	gvue
.
is_obje
()) {

301 
	gm_y
.

(
m_y
.
d
(),

302 
vue
.
m_obje
.
beg
(),

303 
vue
.
m_obje
.
d
());

306 
	gm_y
.
push_back
(
vue
);

309 
	gTy
::
STRING
:

310 i(
vue
.
is_rg
()) {

311 
m_rg
 +
vue
.m_string;

314 
	gTy
::
NUMBER
:

315 i(
vue
.
is_numb
()) {

316 
m_numb
 +
vue
.m_number;

319 
	gTy
::
NIL
:

320 *
this
 = 
vue
;

322 
	gTy
::
BOOLEAN
:

327  *
	gthis
;

330 
	gVue
::
assign
(
d
::
liz_li
<
Pa
> 
_li
) {

331 *
this
 = 
_li
;

334 
	gVue
::
assign
(
d
::
liz_li
<
Vue
> 
_li
) {

335 *
this
 = 
_li
;

338 
	gVue
::
	$assign
(
size_t
 
cou
, cڡ 
Vue
& 
vue
) {

339 
this
->~
	`Vue
();

340 
	`_cڏ
(
Ty
::
ARRAY
);

341 
	`w
 (&
m_y

	`Aay
(
cou
, 
vue
);

342 
	}
}

344 
size_t
 
	gVue
::
	$size
() const {

345 
size_t
 
vue
 = 0;

347 
m_ty
) {

348 
Ty
::
OBJECT
:

349 
vue
 = 
m_obje
.
	`size
();

351 
Ty
::
ARRAY
:

352 
vue
 = 
m_y
.
	`size
();

354 
Ty
::
STRING
:

355 
Ty
::
NIL
:

356 
Ty
::
NUMBER
:

357 
Ty
::
BOOLEAN
:

362  
vue
;

363 
	}
}

365 
	gVue
::
	$r
() {

366 
m_ty
) {

367 
Ty
::
OBJECT
:

368 
m_obje
.
	`r
();

370 
Ty
::
ARRAY
:

371 
m_y
.
	`r
();

373 
Ty
::
STRING
:

374 
m_rg
.
	`r
();

376 
Ty
::
NUMBER
:

377 
m_numb
 = 0;

379 
Ty
::
BOOLEAN
:

380 
m_boޗn
 = 
l
;

382 
Ty
::
NIL
:

386 
	}
}

388 
	gVue
& Vue::
ݔ
[](
dex
) {

389  (*
this
)[
size_t
(
dex
)];

392 cڡ 
	gVue
& Vue::
ݔ
[](
dex
) const {

393  (*
this
)[
size_t
(
dex
)];

396 
	gVue
& Vue::
ݔ
[](cڡ 
Sg
& 
key
) {

397  (*
this
)[
key
.
c_r
()];

400 cڡ 
	gVue
& Vue::
ݔ
[](cڡ 
Sg
& 
key
) const {

401  (*
this
)[
key
.
c_r
()];

404 
bo
 
	gVue
::
	$is_memb
(cڡ 
d
::
rg
& 
key
) const {

405  
	`is_memb
(
key
.
	`c_r
());

406 
	}
}

408 
bo
 
	gVue
::
	$is_memb
(cڡ * 
key
) const {

409 i(!
	`is_obje
(){  
l
; }

410 cڡuto& 

 : 
m_obje
) {

411 i(
key
 =

.
f
) {

412  
ue
;

415  
l
;

416 
	}
}

418 
size_t
 
	gVue
::
	$a
(cڡ * 
key
) {

419 i(!
	`is_obje
()) {  0; }

421 aut

 = 
m_obje
.
	`beg
(); i!m_obje.
	`d
(); it++) {

422 i(
key
 =

->
f
) {

423 
m_obje
.
	`a
(

);

429 
	}
}

431 
size_t
 
	gVue
::
	$a
(cڡ 
Sg
& 
key
) {

432  
	`a
(
key
.
	`c_r
());

433 
	}
}

435 
	gVue
::

 
Vue
::
	$a
(
cڡ_
 
pos
) {

436 

 
tmp
;

438 i(
	`is_y
(&& 
pos
.is_array()) {

439 
tmp
 = 
d
::
	`move
(
m_y
.
	`a
(
pos
.
m_y_
));

441 i(
	`is_obje
(&& 
pos
.is_object()) {

442 
tmp
 = 
d
::
	`move
(
m_obje
.
	`a
(
pos
.
m_obje_
));

445 
tmp
 =
	`d
();

448  
tmp
;

449 
	}
}

451 
	gVue
::

 
Vue
::
	$a
(
cڡ_
 
f
, cڡ_ 
ϡ
) {

452 

 
tmp
;

454 aut

 = 
f
; i< 
ϡ
; ++it) {

455 
tmp
 = 
	`a
(

);

458  
tmp
;

459 
	}
}

461 
	gVue
::

 
Vue
::
	$
(
cڡ_
 
pos
, cڡ 
Vue
& 
vue
) {

462 

 
tmp
;

464 i(
	`is_y
(&& 
pos
.is_array()) {

465 
tmp
 = 
d
::
	`move
(
m_y
.
	`
(
pos
.
m_y_
, 
vue
));

467 i(
	`is_obje
(&& 
pos
.is_obje(&& 
vue
.is_object()) {

468 aut

 = 
vue
.
	`cbeg
(); vue.
	`nd
(!; ++, ++
pos
) {

469 i(!
	`is_memb
(

.
	`key
())) {

470 
tmp
 = 
d
::
	`move
(
m_obje
.
	`
(
pos
.
m_obje_
,

471 
	`Pa
(

.
	`key
(), *it)));

476 
tmp
 = 
	`d
();

479  
tmp
;

480 
	}
}

482 
	gVue
::

 
Vue
::
	$
(
cڡ_
 
pos
, 
Vue
&& 
vue
) {

483 

 
tmp
;

485 i(
	`is_y
(&& 
pos
.is_array()) {

486 
tmp
 = 
d
::
	`move
(
m_y
.
	`
(
pos
.
m_y_
, std::move(
vue
)));

488 i(
	`is_obje
(&& 
pos
.is_obje(&& 
vue
.is_object()) {

489 aut

 = 
vue
.
	`cbeg
(); vue.
	`nd
(!; ++, ++
pos
) {

490 i(!
	`is_memb
(

.
	`key
())) {

491 
tmp
 = 
d
::
	`move
(
m_obje
.
	`
(
pos
.
m_obje_
,

492 
	`Pa
(

.
	`key
(), 
d
::
	`move
(*it))));

497 
tmp
 = 
	`d
();

500  
tmp
;

501 
	}
}

503 
	gVue
::

 
Vue
::
	$
(
cڡ_
 
pos
,

504 
size_t
 
cou
, cڡ 
Vue
& 
vue
) {

505 

 
tmp
;

507 0 < 
cou
--) {

508 
tmp
 = 
	`
(
pos
++, 
vue
);

511  
tmp
;

512 
	}
}

514 
	gVue
::

 
Vue
::
	$
(
cڡ_
 
pos
,

515 
cڡ_
 
f
, cڡ_ 
ϡ
) {

516 

 
tmp
;

518 aut

 = 
f
; i< 
ϡ
; ++it) {

519 
tmp
 = 
	`
(
pos
++, *

);

522  
tmp
;

523 
	}
}

525 
	gVue
::

 
Vue
::

(
cڡ_
 
pos
,

526 
d
::
liz_li
<
Vue
> 
_li
) {

527  

(
pos
, 
_li
.
beg
(), in_li.
d
());

530 
	gSg
& 
	gVue
::
	$as_rg
() {

531 i(
Ty
::
STRING
 !
m_ty
) {

532 
throw
 
Vue
::
	`Exi
("JSON isn't string");

534  
m_rg
;

535 
	}
}

537 cڡ 
	gSg
& 
	gVue
::
	$as_rg
() const {

538 i(
Ty
::
STRING
 !
m_ty
) {

539 
throw
 
Vue
::
	`Exi
("JSON isn't string");

541  
m_rg
;

542 
	}
}

544 cڡ * 
	gVue
::
	$as_ch
() const {

545 i(
Ty
::
STRING
 !
m_ty
) {

546 
throw
 
Vue
::
	`Exi
("JSON isn't string");

548  
m_rg
.
	`c_r
();

549 
	}
}

551 
Bo
 
	gVue
::
	$as_bo
() const {

552 i(
Ty
::
BOOLEAN
 !
m_ty
) {

553 
throw
 
Vue
::
	`Exi
("JSON isn't boolean");

555  
m_boޗn
;

556 
	}
}

558 
Nu
 
	gVue
::
	$as_nu
() const {

559 i(
Ty
::
NIL
 !
m_ty
) {

560 
throw
 
Vue
::
	`Exi
("JSON isn'tull");

562  
nuαr
;

563 
	}
}

565 
I
 
	gVue
::
	$as_t
() const {

566 i(
Ty
::
NUMBER
 !
m_ty
) {

567 
throw
 
Vue
::
	`Exi
("JSON isn'tumber");

569  
	`I
(
m_numb
);

570 
	}
}

572 
Ut
 
	gVue
::
	$as_ut
() const {

573 i(
Ty
::
NUMBER
 !
m_ty
) {

574 
throw
 
Vue
::
	`Exi
("JSON isn'tumber");

576  
	`Ut
(
m_numb
);

577 
	}
}

579 
I64
 
	gVue
::
	$as_t64
() const {

580 i(
Ty
::
NUMBER
 !
m_ty
) {

581 
throw
 
Vue
::
	`Exi
("JSON isn'tumber");

583  
	`I64
(
m_numb
);

584 
	}
}

586 
Ut64
 
	gVue
::
	$as_ut64
() const {

587 i(
Ty
::
NUMBER
 !
m_ty
) {

588 
throw
 
Vue
::
	`Exi
("JSON isn'tumber");

590  
	`Ut64
(
m_numb
);

591 
	}
}

593 
Doub
 
	gVue
::
	$as_doub
() const {

594 i(
Ty
::
NUMBER
 !
m_ty
) {

595 
throw
 
Vue
::
	`Exi
("JSON isn'tumber");

597  
	`Doub
(
m_numb
);

598 
	}
}

600 
	gAay
& 
	gVue
::
	$as_y
() {

601 i(
Ty
::
ARRAY
 !
m_ty
) {

602 
throw
 
Vue
::
	`Exi
("JSON isn'tnrray");

604  
m_y
;

605 
	}
}

607 
	gNumb
& 
	gVue
::
	$as_numb
() {

608 i(
Ty
::
NUMBER
 !
m_ty
) {

609 
throw
 
Vue
::
	`Exi
("JSON isn'tumber");

611  
m_numb
;

612 
	}
}

614 cڡ 
	gAay
& 
	gVue
::
	$as_y
() const {

615 i(
Ty
::
ARRAY
 !
m_ty
) {

616 
throw
 
Vue
::
	`Exi
("JSON isn'tnrray");

618  
m_y
;

619 
	}
}

621 cڡ 
	gObje
& 
	gVue
::
	$as_obje
() const {

622 i(
Ty
::
OBJECT
 !
m_ty
) {

623 
throw
 
Vue
::
	`Exi
("JSON isn'tn object");

625  
m_obje
;

626 
	}
}

628 cڡ 
	gNumb
& 
	gVue
::
	$as_numb
() const {

629 i(
Ty
::
NUMBER
 !
m_ty
) {

630 
throw
 
Vue
::
	`Exi
("JSON isn'tumber");

632  
m_numb
;

633 
	}
}

635 
	gVue
& Vue::
ݔ
[](cڡ * 
key
) {

636 i(!
is_obje
()) {

637 i(
is_nu
(){ *
this
 = 
Ty
::
OBJECT
; }

638 {  *
	gthis
; }

641 auto& 
	g
 : 
m_obje
) {

642 i(
key
 =

.
f
) {

643  

.
cd
;

647 
	gm_obje
.
ema_back
(
key
, 
Vue
());

649  
	gm_obje
.
back
().
	gcd
;

652 cڡ 
	gVue
& Vue::
ݔ
[](cڡ * 
key
) const {

653 i(!
is_obje
(){  *
this
; }

655 cڡuto& 
	g
 : 
m_obje
) {

656 i(
key
 =

.
f
) {

657  

.
cd
;

661  
	gg_nu_vue
;

664 
	gVue
& Vue::
ݔ
[](cڡ 
size_t
 
dex
) {

665 i(
is_nu
(){ *
this
 = 
Ty
::
ARRAY
; }

667 
Vue
* 
	gr
;

669 i(
is_y
()) {

670 i(
size
(=
dex
) {

671 
m_y
.
ema_back
(
Vue
());

673 
	gr
 = &
m_y
[
dex
];

675 i(
is_obje
()) {

676 
	gr
 = &
m_obje
[
dex
].
cd
;

679 
	gr
 = 
this
;

682  *
	gr
;

685 cڡ 
	gVue
& Vue::
ݔ
[](cڡ 
size_t
 
dex
) const {

686 cڡ 
Vue
* 
r
;

688 i(
is_y
()) {

689 
	gr
 = &
m_y
[
dex
];

691 i(
is_obje
()) {

692 
	gr
 = &
m_obje
[
dex
].
cd
;

695 
	gr
 = 
this
;

698  *
	gr
;

701 
	gVue
::
	$push_back
(cڡ 
Vue
& 
vue
) {

702 i(
	`is_nu
(){ *
this
 = 
	`Vue
(
Ty
::
ARRAY
); }

704 i(
	`is_y
()) {

705 
m_y
.
	`push_back
(
vue
);

707 
	}
}

709 
	gVue
::
	$push_back
(cڡ 
Pa
& 

) {

710 i(
	`is_nu
(){ *
this
 = 
Ty
::
OBJECT
; }

712 i(
	`is_obje
()) {

713 (*
this
)[

.
f
] =a.
cd
;

715 i(
	`is_y
()) {

716 
m_y
.
	`push_back
(

);

718 
	}
}

720 
	gVue
::
	$p_back
() {

721 i(
	`is_y
()) {

722 
m_y
.
	`p_back
();

724 i(
	`is_obje
()) {

725 
m_obje
.
	`p_back
();

728 *
this
 = 
Ty
::
NIL
;

730 
	}
}

732 
	gVue
::
	$sw
(
Vue
& 
vue
) {

733 
Vue
 
	`mp
(
d
::
	`move
(
vue
));

734 
vue
 = 
d
::
	`move
(*
this
);

735 *
this
 = 
d
::
	`move
(
mp
);

736 
	}
}

738 
bo
 
	gjs
::
ݔ
==(cڡ 
Vue
& 
v1
, cڡ 
	gVue
& 
	gv2
) {

739 i(
	gv1
.
	gm_ty
 !
v2
.
m_ty
{  
l
; }

741 
bo
 
	gsu
 = 
l
;

743 
	gv1
.
	gm_ty
) {

744 
	gVue
::
Ty
::
OBJECT
:

745 
su
 = (
v1
.
m_obje
 =
v2
.m_object);

747 
	gVue
::
Ty
::
ARRAY
:

748 
su
 = (
v1
.
m_y
 =
v2
.m_array);

750 
	gVue
::
Ty
::
STRING
:

751 
su
 = (
v1
.
m_rg
 =
v2
.m_string);

753 
	gVue
::
Ty
::
NUMBER
:

754 
su
 = (
v1
.
m_numb
 =
v2
.m_number);

756 
	gVue
::
Ty
::
BOOLEAN
:

757 
su
 = (
v1
.
m_boޗn
 =
v2
.m_boolean);

759 
	gVue
::
Ty
::
NIL
:

760 
su
 = 
ue
;

766  
	gsu
;

769 
bo
 
	gjs
::
ݔ
<(cڡ 
Vue
& 
v1
, cڡ 
	gVue
& 
	gv2
) {

770 i(
	gv1
.
	gm_ty
 !
v2
.
m_ty
{  
l
; }

772 
bo
 
	gsu
 = 
l
;

774 
	gv1
.
	gm_ty
) {

775 
	gVue
::
Ty
::
OBJECT
:

776 
su
 = (
v1
.
m_obje
 < 
v2
.m_object);

778 
	gVue
::
Ty
::
ARRAY
:

779 
su
 = (
v1
.
m_y
 < 
v2
.m_array);

781 
	gVue
::
Ty
::
STRING
:

782 
su
 = (
v1
.
m_rg
 < 
v2
.m_string);

784 
	gVue
::
Ty
::
NUMBER
:

785 
su
 = (
v1
.
m_numb
 < 
v2
.m_number);

787 
	gVue
::
Ty
::
BOOLEAN
:

788 
su
 = (
v1
.
m_boޗn
 < 
v2
.m_boolean);

790 
	gVue
::
Ty
::
NIL
:

795  
	gsu
;

798 
	gVue
::

 
Vue
::
	$beg
() {

799 

 
tmp
;

801 i(
	`is_y
()) {

802 
tmp
 = 
m_y
.
	`beg
();

804 i(
	`is_obje
()) {

805 
tmp
 = 
m_obje
.
	`beg
();

808 
tmp
 = 
this
;

811  
tmp
;

812 
	}
}

814 
	gVue
::

 
Vue
::
	$d
() {

815 

 
tmp
;

817 i(
	`is_y
()) {

818 
tmp
 = 
m_y
.
	`d
();

820 i(
	`is_obje
()) {

821 
tmp
 = 
m_obje
.
	`d
();

824 
tmp
 = 
this
;

827  
tmp
;

828 
	}
}

830 
	gVue
::
cڡ_
 
Vue
::
	$cbeg
() const {

831 
cڡ_
 
tmp
;

833 i(
	`is_y
()) {

834 
tmp
 = 
m_y
.
	`cbeg
();

836 i(
	`is_obje
()) {

837 
tmp
 = 
m_obje
.
	`cbeg
();

840 
tmp
 = 
this
;

843  
tmp
;

844 
	}
}

846 
	gVue
::
cڡ_
 
Vue
::
	$nd
() const {

847 
cڡ_
 
tmp
;

849 i(
	`is_y
()) {

850 
tmp
 = 
m_y
.
	`nd
();

852 i(
	`is_obje
()) {

853 
tmp
 = 
m_obje
.
	`nd
();

856 
tmp
 = 
this
;

859  
tmp
;

860 
	}
}

862 
	gVue
::
cڡ_
 
Vue
::
	$beg
() const {

863  
	`cbeg
();

864 
	}
}

866 
	gVue
::
cڡ_
 
Vue
::
	$d
() const {

867  
	`nd
();

868 
	}
}

	@open_source/json-cxx/src/writter.cpp

44 
	~"js/wrr.h
"

46 
usg
 
mea
 
	gjs
;

48 
	gWrr
::~
	$Wrr
({ 
	}
}

	@open_source/json-cxx/src/writter/counter.cpp

44 
	~"js/wrr/cou.h
"

46 
usg
 
mea
 
	gjs
::
wrr
;

48 
	gCou
::~
	$Cou
({ 
	}
}

	@open_source/json-cxx/src/writter/string.cpp

44 
	~"js/wrr/rg.h
"

46 
usg
 
mea
 
	gjs
::
wrr
;

48 
	gSg
::~
	$Sg
({ 
	}
}

	@open_source/json-cxx/tests/test_deserializer.cpp

40 
	~"g/g.h
"

41 
	~"js/js.h
"

43 
	~<ioam
>

45 
usg
 
mea
 
	gjs
;

47 as
	cDerlizTe
 : 
public
 ::
g
::
Te
 {

48 
eed
:

49 
Derliz
 
m_derliz
;

51 
vtu
 
	$SUp
() {

55 
vtu
 
	$TrDown
() {

56 i(
m_derliz
.
	`is_vid
()) {

57 
Derliz
::
E
 
r
 = 
m_derliz
.
	`g_r
();

58 
d
::

 << "Psg invid " << 
r
.
	`decode
() << "tine "

59 << 
r
.
le
 << " icum " <<.
cumn
 << 
d
::
dl
;

61 
	}
}

63 ~
DerlizTe
();

66 
	gDerlizTe
::~
	$DerlizTe
({ 
	}
}

68 
	$TEST_F
(
DerlizTe
, 
PosiveSimeObje
) {

69 
Vue
 
vue
;

71 
m_derliz
 << 
R
"({"
key
":"

"})" >> 
vue
;

73 
	`EXPECT_TRUE
(
vue
.
	`is_obje
());

74 
	`EXPECT_EQ
(
vue
.
	`size
(), 1);

75 
	`EXPECT_EQ
(
vue
["key"], "test");

76 
	}
}

78 
	$TEST_F
(
DerlizTe
, 
PosiveSimeAay
) {

79 
Vue
 
vue
;

81 
m_derliz
 << 
R
"([0, 1, 2])" >> 
vue
;

83 
	`EXPECT_TRUE
(
vue
.
	`is_y
());

84 
	`EXPECT_EQ
(
vue
.
	`size
(), 3);

85 
	`EXPECT_EQ
(
vue
[0], 0);

86 
	`EXPECT_EQ
(
vue
[1], 1);

87 
	`EXPECT_EQ
(
vue
[2], 2);

88 
	}
}

90 
	$TEST_F
(
DerlizTe
, 
PosiveSimeSg
) {

91 
Vue
 
vue
;

93 
m_derliz
 << 
R
"("

")" >> 
vue
;

95 
	`EXPECT_TRUE
(
vue
.
	`is_rg
());

96 
	`EXPECT_EQ
(
vue
.
	`size
(), 0);

97 
	`EXPECT_EQ
(
vue
.
	`as_rg
().
	`size
(), 4);

98 
	`EXPECT_EQ
(
vue
, "test");

99 
	}
}

101 
	$TEST_F
(
DerlizTe
, 
PosiveSimeNumbUnsigdIeg
) {

102 
Vue
 
vue
;

104 
m_derliz
 << 
R
"(13)" >> 
vue
;

106 
	`EXPECT_TRUE
(
vue
.
	`is_numb
());

107 
	`EXPECT_TRUE
(
vue
.
	`is_ut
());

108 
	`EXPECT_EQ
(
vue
.
	`size
(), 0);

109 
	`EXPECT_EQ
(
vue
, 13);

110 
	}
}

112 
	$TEST_F
(
DerlizTe
, 
PosiveSimeNumbSigdIeg
) {

113 
Vue
 
vue
;

115 
m_derliz
 << 
R
"(-13)" >> 
vue
;

117 
	`EXPECT_TRUE
(
vue
.
	`is_numb
());

118 
	`EXPECT_TRUE
(
vue
.
	`is_t
());

119 
	`EXPECT_EQ
(
vue
.
	`size
(), 0);

120 
	`EXPECT_EQ
(
vue
, -13);

121 
	}
}

147 
	$TEST_F
(
DerlizTe
, 
PosiveSimeTrue
) {

148 
Vue
 
vue
;

150 
m_derliz
 << 
R
"rue)" >> 
vue
;

152 
	`EXPECT_TRUE
(
vue
.
	`is_boޗn
());

153 
	`EXPECT_EQ
(
vue
.
	`size
(), 0);

154 
	`EXPECT_EQ
(
vue
, 
ue
);

155 
	}
}

157 
	$TEST_F
(
DerlizTe
, 
PosiveSimeF
) {

158 
Vue
 
vue
;

160 
m_derliz
 << 
R
"(l)" >> 
vue
;

162 
	`EXPECT_TRUE
(
vue
.
	`is_boޗn
());

163 
	`EXPECT_EQ
(
vue
.
	`size
(), 0);

164 
	`EXPECT_EQ
(
vue
, 
l
);

165 
	}
}

167 
	$TEST_F
(
DerlizTe
, 
PosiveSimeNu
) {

168 
Vue
 
vue
;

170 
m_derliz
 << 
R
"u)" >> 
vue
;

172 
	`EXPECT_TRUE
(
vue
.
	`is_nu
());

173 
	`EXPECT_EQ
(
vue
.
	`size
(), 0);

174 
	`EXPECT_EQ
(
vue
, 
nuαr
);

175 
	}
}

177 
	$TEST_F
(
DerlizTe
, 
NegiveExtTru
) {

178 
Vue
 
vue
;

180 
m_derliz
 << 
R
"ru)" >> 
vue
;

182 
	`EXPECT_TRUE
(
m_derliz
.
	`is_vid
());

183 
	`EXPECT_EQ
(
vue
, 
nuαr
);

184 
	}
}

186 
	$TEST_F
(
DerlizTe
, 
NegiveExtFe
) {

187 
Vue
 
vue
;

189 
m_derliz
 << 
R
"(le)" >> 
vue
;

191 
	`EXPECT_TRUE
(
m_derliz
.
	`is_vid
());

192 
	`EXPECT_EQ
(
vue
, 
nuαr
);

193 
	}
}

195 
	$TEST_F
(
DerlizTe
, 
NegiveExtNul
) {

196 
Vue
 
vue
;

198 
m_derliz
 << 
R
"ul)" >> 
vue
;

200 
	`EXPECT_TRUE
(
m_derliz
.
	`is_vid
());

201 
	`EXPECT_EQ
(
vue
, 
nuαr
);

202 
	}
}

	@open_source/json-cxx/tests/test_runner.cpp

40 
	~<dio.h
>

42 
	~"g/g.h
"

44 
	$ma
(
gc
, **
gv
) {

45 
	`tf
("Running main() fromest_runner.cpp\n");

46 
g
::
	`InGoogTe
(&
gc
, 
gv
);

47  
	`RUN_ALL_TESTS
();

48 
	}
}

	@open_source/jsoncpp-1.7.2.no-abi/include/json/allocator.h

6 #ide
CPPTL_JSON_ALLOCATOR_H_INCLUDED


7 
	#CPPTL_JSON_ALLOCATOR_H_INCLUDED


	)

9 
	~<crg
>

10 
	~<memy
>

12 
mea
 
	gJs
 {

13 
	gme
<
tyme
 
	gT
>

14 as
	cSecuAot
 {

15 
	gpublic
:

17 
usg
 
vue_ty
 = 
T
;

18 
usg
 
	gpor
 = 
T
*;

19 
usg
 
	gcڡ_por
 = cڡ 
T
*;

20 
usg
 
	gn
 = 
T
&;

21 
usg
 
	gcڡ_n
 = cڡ 
T
&;

22 
usg
 
	gsize_ty
 = 
d
::
size_t
;

23 
usg
 
	gdifn_ty
 = 
d
::
rdiff_t
;

28 
por
 
lo
(
size_ty
 
n
) {

30  
	gic_
<
	gpor
>(::
ݔ
 
w
(
n
 * (
T
)));

40 
do
(vީ
por
 
p
, 
size_ty
 
n
) {

41 
	gd
::
memt
(
p
, 0, 
n
 * (
T
));

43 ::
ݔ
 
de
(
p
);

49 
	gme
<
	gtyme
... 
	gArgs
>

50 
cڡru
(
por
 
p
, 
Args
&&... 
gs
) {

52 ::
w
 (
ic_
<*>(
p
)
T
(
d
::
fwd
<
Args
>(
gs
)...);

55 
size_ty
 
max_size
() const {

56  
size_t
(-1/ (
	gT
);

59 
por
 
addss

n
 
x
 ) const {

60  
	gd
::
addssof
(
x
);

63 
cڡ_por
 
addss

cڡ_n
 
x
 ) const {

64  
	gd
::
addssof
(
x
);

70 
deroy
(
por
 
p
) {

72 
	gp
->~
T
();

76 
SecuAot
() {}

77 
	gme
<
tyme
 
	gU
> 
SecuAot
(cڡ SecuAot<
U
>&) {}

78 
	gme
<
tyme
 
	gU
> 
	sbd
 { 
usg
 
	gh
 = 
SecuAot
<
U
>; };

82 
	gme
<
tyme
 
	gT
,ym
	gU
>

83 
bo
 
	gݔ
==(cڡ 
SecuAot
<
T
>&, cڡ 
	gSecuAot
<
	gU
>&) {

84  
	gue
;

87 
	gme
<
tyme
 
	gT
,ym
	gU
>

88 
bo
 
	gݔ
!=(cڡ 
SecuAot
<
T
>&, cڡ 
	gSecuAot
<
	gU
>&) {

89  
	gl
;

	@open_source/jsoncpp-1.7.2.no-abi/include/json/assertions.h

6 #ide
CPPTL_JSON_ASSERTIONS_H_INCLUDED


7 
	#CPPTL_JSON_ASSERTIONS_H_INCLUDED


	)

9 
	~<dlib.h
>

10 
	~<sam
>

12 #i!
defed
(
JSON_IS_AMALGAMATION
)

13 
	~"cfig.h
"

20 #i
JSON_USE_EXCEPTION


23 
	#JSON_ASSERT
(
cdi
) \

24 {i(!(
cdi
){
Js
::
	`throwLogicE
"as js faed" );}}

	)

26 
	#JSON_FAIL_MESSAGE
(
mesge
) \

28 
JSONCPP_OSTRINGSTREAM
 
oss
; os<< 
mesge
; \

29 
Js
::
	`throwLogicE
(
oss
.
	`r
()); \

30 
	`abt
(); \

31 }

	)

35 
	#JSON_ASSERT
(
cdi

	`as
(cdi)

	)

39 
	#JSON_FAIL_MESSAGE
(
mesge
) \

41 
JSONCPP_OSTRINGSTREAM
 
oss
; os<< 
mesge
; \

42 
	`as
(
l
 && 
oss
.
	`r
().
	`c_r
()); \

43 
	`abt
(); \

44 }

	)

49 
	#JSON_ASSERT_MESSAGE
(
cdi
, 
mesge
) \

50 i(!(
cdi
)) { \

51 
	`JSON_FAIL_MESSAGE
(
mesge
); \

52 }

	)

	@open_source/jsoncpp-1.7.2.no-abi/include/json/autolink.h

6 #ide
JSON_AUTOLINK_H_INCLUDED


7 
	#JSON_AUTOLINK_H_INCLUDED


	)

9 
	~"cfig.h
"

11 #ifde
JSON_IN_CPPTL


12 
	~<l/l_autޚk.h
>

15 #i!
defed
(
JSON_NO_AUTOLINK
&& !defed(
JSON_DLL_BUILD
) && \

16 !
	$defed
(
JSON_IN_CPPTL
)

17 
	#CPPTL_AUTOLINK_NAME
 "js"

	)

18 #unde
CPPTL_AUTOLINK_DLL


19 #ifde
JSON_DLL


20 
	#CPPTL_AUTOLINK_DLL


	)

22 
	~"autޚk.h
"

	@open_source/jsoncpp-1.7.2.no-abi/include/json/config.h

6 #ide
JSON_CONFIG_H_INCLUDED


7 
	#JSON_CONFIG_H_INCLUDED


	)

8 
	~<ddef.h
>

9 
	~<rg
>

23 #ide
JSON_USE_EXCEPTION


24 
	#JSON_USE_EXCEPTION
 1

	)

32 #ifde
JSON_IN_CPPTL


33 
	~<l/cfig.h
>

34 #ide
JSON_USE_CPPTL


35 
	#JSON_USE_CPPTL
 1

	)

39 #ifde
JSON_IN_CPPTL


40 
	#JSON_API
 
CPPTL_API


	)

41 #i
defed
(
JSON_DLL_BUILD
)

42 #i
defed
(
_MSC_VER
|| defed(
__MINGW32__
)

43 
	#JSON_API
 
	`__deec
(
dexpt
)

	)

44 
	#JSONCPP_DISABLE_DLL_INTERFACE_WARNING


	)

46 #i
defed
(
JSON_DLL
)

47 #i
defed
(
_MSC_VER
|| defed(
__MINGW32__
)

48 
	#JSON_API
 
	`__deec
(
dimpt
)

	)

49 
	#JSONCPP_DISABLE_DLL_INTERFACE_WARNING


	)

52 #i!
defed
(
JSON_API
)

53 
	#JSON_API


	)

61 #i
defed
(
_MSC_VER
)

62 #i
_MSC_VER
 <= 1200

65 
	#JSON_USE_INT64_DOUBLE_CONVERSION
 1

	)

70 #agm
wng
(
dib
 : 4786)

73 #i
_MSC_VER
 >= 1500

75 
	#JSONCPP_DEPRECATED
(
mesge

	`__deec
(
	`dd
(mesge))

	)

80 #i
defed
(
_MSC_VER
) && _MSC_VER <= 1600

81 
	#JSONCPP_OVERRIDE


	)

83 
	#JSONCPP_OVERRIDE
 
ovride


	)

87 #ide
JSON_HAS_RVALUE_REFERENCES


89 #i
defed
(
_MSC_VER
) && _MSC_VER >= 1600

90 
	#JSON_HAS_RVALUE_REFERENCES
 1

	)

93 #ifde
__g__


94 #i
__has_u
(
cxx_rvue_ns
)

95 
	#JSON_HAS_RVALUE_REFERENCES
 1

	)

98 #i
defed
 
__GNUC__


99 #i
defed
(
__GXX_EXPERIMENTAL_CXX0X__
|| (
__lulus
 >= 201103L)

100 
	#JSON_HAS_RVALUE_REFERENCES
 1

	)

107 #ide
JSON_HAS_RVALUE_REFERENCES


108 
	#JSON_HAS_RVALUE_REFERENCES
 0

	)

111 #ifde
__g__


112 #i
defed
 
__GNUC__


113 #i(
__GNUC__
 > 4 || (__GNUC__ =4 && 
__GNUC_MINOR__
 >= 5))

114 
	#JSONCPP_DEPRECATED
(
mesge

	`__ibu__
 ((
	`dd
(mesge)))

	)

115 #i(
__GNUC__
 > 3 || (__GNUC__ =3 && 
__GNUC_MINOR__
 >= 1))

116 
	#JSONCPP_DEPRECATED
(
mesge

	`__ibu__
((
__dd__
))

	)

120 #i!
defed
(
JSONCPP_DEPRECATED
)

121 
	#JSONCPP_DEPRECATED
(
mesge
)

	)

124 #i
__GNUC__
 >= 6

125 
	#JSON_USE_INT64_DOUBLE_CONVERSION
 1

	)

128 #i!
defed
(
JSON_IS_AMALGAMATION
)

130 
	~"vsi.h
"

132 #i
JSONCPP_USING_SECURE_MEMORY


133 
	~"lot.h
"

138 
mea
 
	gJs
 {

139 
	tI
;

140 
	tUI
;

141 #i
defed
(
JSON_NO_INT64
)

142 
	tLgeI
;

143 
	tLgeUI
;

144 #unde
JSON_HAS_INT64


147 #i
defed
(
_MSC_VER
)

148 
__t64
 
	tI64
;

149 
	t__t64
 
	tUI64
;

151 
	tI64
;

152 
	tUI64
;

154 
I64
 
	tLgeI
;

155 
UI64
 
	tLgeUI
;

156 
	#JSON_HAS_INT64


	)

158 #i
JSONCPP_USING_SECURE_MEMORY


159 
	#JSONCPP_STRING
 
d
::
basic_rg
<, std::
ch_as
<>, 
Js
::
SecuAot
<> >

	)

160 
	#JSONCPP_OSTRINGSTREAM
 
d
::
basic_orgam
<, std::
ch_as
<>, 
Js
::
SecuAot
<> >

	)

161 
	#JSONCPP_OSTREAM
 
d
::
basic_oam
<, std::
ch_as
<>>

	)

162 
	#JSONCPP_ISTRINGSTREAM
 
d
::
basic_irgam
<, std::
ch_as
<>, 
Js
::
SecuAot
<> >

	)

163 
	#JSONCPP_ISTREAM
 
d
::
iam


	)

165 
	#JSONCPP_STRING
 
d
::
rg


	)

166 
	#JSONCPP_OSTRINGSTREAM
 
d
::
orgam


	)

167 
	#JSONCPP_OSTREAM
 
d
::
oam


	)

168 
	#JSONCPP_ISTRINGSTREAM
 
d
::
irgam


	)

169 
	#JSONCPP_ISTREAM
 
d
::
iam


	)

	@open_source/jsoncpp-1.7.2.no-abi/include/json/features.h

6 #ide
CPPTL_JSON_FEATURES_H_INCLUDED


7 
	#CPPTL_JSON_FEATURES_H_INCLUDED


	)

9 #i!
defed
(
JSON_IS_AMALGAMATION
)

10 
	~"fwds.h
"

13 
mea
 
	gJs
 {

19 as
	cJSON_API
 
	gFtus
 {

20 
	gpublic
:

27 
Ftus
 
l
();

35 
Ftus
 
riMode
();

39 
Ftus
();

42 
bo
 
	glowCommts_
;

46 
bo
 
	griRo_
;

49 
bo
 
	glowDrݳdNuPhds_
;

52 
bo
 
	glowNumicKeys_
;

	@open_source/jsoncpp-1.7.2.no-abi/include/json/forwards.h

6 #ide
JSON_FORWARDS_H_INCLUDED


7 
	#JSON_FORWARDS_H_INCLUDED


	)

9 #i!
defed
(
JSON_IS_AMALGAMATION
)

10 
	~"cfig.h
"

13 
mea
 
	gJs
 {

16 
ass
 
	gFaWr
;

17 
ass
 
	gStydWr
;

20 
ass
 
	gRd
;

23 
ass
 
	gFtus
;

26 
	tAayIndex
;

27 
ass
 
	gSticSg
;

28 
ass
 
	gPh
;

29 
ass
 
	gPhArgumt
;

30 
ass
 
	gVue
;

31 
ass
 
	gVueItBa
;

32 
ass
 
	gVueIt
;

33 
ass
 
	gVueCڡIt
;

	@open_source/jsoncpp-1.7.2.no-abi/include/json/json.h

6 #ide
JSON_JSON_H_INCLUDED


7 
	#JSON_JSON_H_INCLUDED


	)

9 
	~"autޚk.h
"

10 
	~"vue.h
"

11 
	~"ad.h
"

12 
	~"wr.h
"

13 
	~"us.h
"

	@open_source/jsoncpp-1.7.2.no-abi/include/json/reader.h

6 #ide
CPPTL_JSON_READER_H_INCLUDED


7 
	#CPPTL_JSON_READER_H_INCLUDED


	)

9 #i!
defed
(
JSON_IS_AMALGAMATION
)

10 
	~"us.h
"

11 
	~"vue.h
"

13 
	~<deque
>

14 
	~<iosfwd
>

15 
	~<ack
>

16 
	~<rg
>

17 
	~<iam
>

21 #i
defed
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)

22 #agm
wng
(
push
)

23 #agm
wng
(
dib
 : 4251)

26 
mea
 
	gJs
 {

33 as
	cJSON_API
 
	gRd
 {

34 
	gpublic
:

35 
	tCh
;

36 cڡ 
	tCh
* 
	tLoti
;

44 
	sSuudE
 {

45 
rdiff_t
 
	gofft_t
;

46 
rdiff_t
 
	gofft_lim
;

47 
JSONCPP_STRING
 
	gmesge
;

53 
Rd
();

58 
Rd
(cڡ 
Ftus
& 
us
);

74 
bo


75 
r
(cڡ 
d
::
rg
& 
documt
, 
Vue
& 
ro
, 
bo
 
cCommts
 = 
ue
);

95 
bo
 
r
(cڡ * 
begDoc
,

96 cڡ * 
dDoc
,

97 
Vue
& 
ro
,

98 
bo
 
cCommts
 = 
ue
);

102 
bo
 
r
(
JSONCPP_ISTREAM
& 
is
, 
Vue
& 
ro
, bo 
cCommts
 = 
ue
);

113 
JSONCPP_DEPRECATED
("Use getFormattedErrorMessages() instead.")

114 
JSONCPP_STRING
 
gFmedEMesges
() const;

124 
JSONCPP_STRING
 
gFmdEMesges
() const;

133 
	gd
::
ve
<
SuudE
> 
gSuudEs
() const;

141 
bo
 
pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
);

150 
bo
 
pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
, cڡ Vue& 
exa
);

156 
bo
 
good
() const;

158 
	give
:

159 
	eTokTy
 {

160 
tokEndOfSm
 = 0,

161 
	gtokObjeBeg
,

162 
	gtokObjeEnd
,

163 
	gtokAayBeg
,

164 
	gtokAayEnd
,

165 
	gtokSg
,

166 
	gtokNumb
,

167 
	gtokTrue
,

168 
	gtokF
,

169 
	gtokNu
,

170 
	gtokAayS
,

171 
	gtokMembS
,

172 
	gtokCommt
,

173 
	gtokE


176 as
	cTok
 {

177 
	gpublic
:

178 
TokTy
 
ty_
;

179 
Loti
 
	gt_
;

180 
Loti
 
	gd_
;

183 as
	cEInfo
 {

184 
	gpublic
:

185 
Tok
 
tok_
;

186 
JSONCPP_STRING
 
	gmesge_
;

187 
Loti
 
	gexa_
;

190 
	gd
::
	tdeque
<
	tEInfo
> 
	tEs
;

192 
bo
 
adTok
(
Tok
& 
tok
);

193 
skSs
();

194 
bo
 
mch
(
Loti
 
n
, 
nLgth
);

195 
bo
 
adCommt
();

196 
bo
 
adCStyCommt
();

197 
bo
 
adCStyCommt
();

198 
bo
 
adSg
();

199 
adNumb
();

200 
bo
 
adVue
();

201 
bo
 
adObje
(
Tok
& 
tok
);

202 
bo
 
adAay
(
Tok
& 
tok
);

203 
bo
 
decodeNumb
(
Tok
& 
tok
);

204 
bo
 
decodeNumb
(
Tok
& 
tok
, 
Vue
& 
decoded
);

205 
bo
 
decodeSg
(
Tok
& 
tok
);

206 
bo
 
decodeSg
(
Tok
& 
tok
, 
JSONCPP_STRING
& 
decoded
);

207 
bo
 
decodeDoub
(
Tok
& 
tok
);

208 
bo
 
decodeDoub
(
Tok
& 
tok
, 
Vue
& 
decoded
);

209 
bo
 
decodeUnicodeCodePot
(
Tok
& 
tok
,

210 
Loti
& 
cut
,

211 
Loti
 
d
,

212 & 
unicode
);

213 
bo
 
decodeUnicodeEsSequ
(
Tok
& 
tok
,

214 
Loti
& 
cut
,

215 
Loti
 
d
,

216 & 
unicode
);

217 
bo
 
addE
(cڡ 
JSONCPP_STRING
& 
mesge
, 
Tok
& 
tok
, 
Loti
 
exa
 = 0);

218 
bo
 
covFromE
(
TokTy
 
skUTok
);

219 
bo
 
addEAndRecov
(cڡ 
JSONCPP_STRING
& 
mesge
,

220 
Tok
& 
tok
,

221 
TokTy
 
skUTok
);

222 
skUS
();

223 
	gVue
& 
cutVue
();

224 
Ch
 
gNextCh
();

226 
gLotiLeAndCumn
(
Loti
 
loti
, & 
le
, & 
cumn
) const;

227 
JSONCPP_STRING
 
gLotiLeAndCumn
(
Loti
 
loti
) const;

228 
addCommt
(
Loti
 
beg
, Loti 
d
, 
CommtPmt
 
amt
);

229 
skCommtToks
(
Tok
& 
tok
);

231 
	gd
::
	tack
<
	tVue
*> 
	tNodes
;

232 
Nodes
 
	gnodes_
;

233 
Es
 
	grs_
;

234 
JSONCPP_STRING
 
	gdocumt_
;

235 
Loti
 
	gbeg_
;

236 
Loti
 
	gd_
;

237 
Loti
 
	gcut_
;

238 
Loti
 
	gϡVueEnd_
;

239 
Vue
* 
	gϡVue_
;

240 
JSONCPP_STRING
 
	gcommtsBefe_
;

241 
Ftus
 
	gus_
;

242 
bo
 
	gcCommts_
;

247 as
	cJSON_API
 
	gChRd
 {

248 
	gpublic
:

249 
vtu
 ~
ChRd
() {}

267 
vtu
 
bo
 
r
(

268 cڡ* 
begDoc
, cڡ* 
dDoc
,

269 
Vue
* 
ro
, 
JSONCPP_STRING
* 
rs
) = 0;

271 as
	cJSON_API
 
	gFay
 {

272 
	gpublic
:

273 
vtu
 ~
Fay
() {}

277 
vtu
 
ChRd
* 
wChRd
() const = 0;

293 as
	cJSON_API
 
	gChRdBud
 : 
public
 
ChRd
::
Fay
 {

294 
public
:

333 
Js
::
Vue
 
gs_
;

335 
ChRdBud
();

336 ~
ChRdBud
(
	gJSONCPP_OVERRIDE
;

338 
ChRd
* 
wChRd
(cڡ 
	gJSONCPP_OVERRIDE
;

343 
bo
 
vide
(
Js
::
Vue
* 
vid
) const;

347 
	gVue
& 
	gݔ
[](
JSONCPP_STRING
 
	gkey
);

354 
tDeus
(
Js
::
Vue
* 
gs
);

360 
riMode
(
Js
::
Vue
* 
gs
);

367 
bo
 
JSON_API
 
rFromSm
(

368 
ChRd
::
Fay
 const&,

369 
JSONCPP_ISTREAM
&,

370 
Vue
* 
ro
, 
d
::
rg
* 
rs
);

396 
JSON_API
 
	gJSONCPP_ISTREAM
& 
	gݔ
>>(JSONCPP_ISTREAM&, 
	gVue
&);

400 #i
defed
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)

401 #agm
wng
(
p
)

	@open_source/jsoncpp-1.7.2.no-abi/include/json/value.h

6 #ide
CPPTL_JSON_H_INCLUDED


7 
	#CPPTL_JSON_H_INCLUDED


	)

9 #i!
defed
(
JSON_IS_AMALGAMATION
)

10 
	~"fwds.h
"

12 
	~<rg
>

13 
	~<ve
>

14 
	~<exi
>

16 #ide
JSON_USE_CPPTL_SMALLMAP


17 
	~<m
>

19 
	~<l/smlm.h
>

21 #ifde
JSON_USE_CPPTL


22 
	~<l/fwds.h
>

28 #i!
defed
(
JSONCPP_NORETURN
)

29 #i
defed
(
_MSC_VER
)

30 
	#JSONCPP_NORETURN
 
	`__deec
(
nܑu
)

	)

31 #i
defed
(
__GNUC__
)

32 
	#JSONCPP_NORETURN
 
	`__ibu__
 ((
__nܑu__
))

	)

34 
	#JSONCPP_NORETURN


	)

40 #i
defed
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)

41 #agm
wng
(
push
)

42 #agm
wng
(
dib
 : 4251)

47 
mea
 
	gJs
 {

53 as
	cJSON_API
 
	gExi
 : 
public
 
d
::
exi
 {

54 
public
:

55 
Exi
(
JSONCPP_STRING
 cڡ& 
msg
);

56 ~
Exi
(
throw
(
	gJSONCPP_OVERRIDE
;

57 cڡ* 
wh
(cڡ 
throw
(
	gJSONCPP_OVERRIDE
;

58 
	geed
:

59 
JSONCPP_STRING
 
msg_
;

68 as
	cJSON_API
 
	gRuimeE
 : 
public
 
Exi
 {

69 
public
:

70 
RuimeE
(
JSONCPP_STRING
 cڡ& 
msg
);

79 as
	cJSON_API
 
	gLogicE
 : 
public
 
Exi
 {

80 
public
:

81 
LogicE
(
JSONCPP_STRING
 cڡ& 
msg
);

85 
JSONCPP_NORETURN
 
throwRuimeE
(
JSONCPP_STRING
 cڡ& 
msg
);

87 
JSONCPP_NORETURN
 
throwLogicE
(
JSONCPP_STRING
 cڡ& 
msg
);

91 
	eVueTy
 {

92 
	gnuVue
 = 0,

93 
	gtVue
,

94 
	gutVue
,

95 
	gVue
,

96 
	grgVue
,

97 
	gboޗnVue
,

98 
	gyVue
,

99 
	gobjeVue


102 
	eCommtPmt
 {

103 
	gcommtBefe
 = 0,

104 
	gcommtAOnSameLe
,

105 
	gcommtA
,

107 
	gnumbOfCommtPmt


129 as
	cJSON_API
 
	gSticSg
 {

130 
	gpublic
:

131 
exic
 
SticSg
(cڡ * 
czrg
: 
c_r_
(czstring) {}

133 
ݔ
 cڡ *(cڡ {  
c_r_
; }

135 cڡ * 
c_r
(cڡ {  
	gc_r_
; }

137 
	give
:

138 cڡ * 
c_r_
;

175 as
	cJSON_API
 
	gVue
 {

176 
nd
 
ass
 
	gVueItBa
;

177 
	gpublic
:

178 
d
::
	tve
<
	tJSONCPP_STRING
> 
	tMembs
;

179 
VueIt
 
	t
;

180 
VueCڡIt
 
	tcڡ_
;

181 
	gJs
::
	tUI
 UInt;

182 
	gJs
::
	tI
 Int;

183 #i
defed
(
JSON_HAS_INT64
)

184 
	gJs
::
	tUI64
 UInt64;

185 
	gJs
::
	tI64
 Int64;

187 
	gJs
::
	tLgeI
 LargestInt;

188 
	gJs
::
	tLgeUI
 LargestUInt;

189 
	gJs
::
	tAayIndex
 ArrayIndex;

191 cڡ 
	gVue
& 
	gnu
;

192 cڡ 
	gVue
& 
	gnuRef
;

194 cڡ 
LgeI
 
	gmLgeI
;

196 cڡ 
LgeI
 
	gmaxLgeI
;

198 cڡ 
LgeUI
 
	gmaxLgeUI
;

201 cڡ 
I
 
	gmI
;

203 cڡ 
I
 
	gmaxI
;

205 cڡ 
UI
 
	gmaxUI
;

207 #i
defed
(
JSON_HAS_INT64
)

209 cڡ 
I64
 
	gmI64
;

211 cڡ 
I64
 
	gmaxI64
;

213 cڡ 
UI64
 
	gmaxUI64
;

216 
	give
:

217 #ide
JSONCPP_DOC_EXCLUDE_IMPLEMENTATION


218 as
	cCZSg
 {

219 
public
:

220 
	eDuitiPicy
 {

221 
noDuiti
 = 0,

222 
	gdui
,

223 
	gduiOnCy


225 
CZSg
(
AayIndex
 
dex
);

226 
CZSg
(cڡ* 
r
, 
ngth
, 
DuitiPicy
 
lo
);

227 
CZSg
(CZSg cڡ& 
h
);

228 #i
JSON_HAS_RVALUE_REFERENCES


229 
CZSg
(CZSg&& 
h
);

231 ~
CZSg
();

232 
	gCZSg
& 
	gݔ
=(
CZSg
 
h
);

233 
bo
 
	gݔ
<(
CZSg
 cڡ& 
	gh
) const;

234 
bo
 
	gݔ
==(
CZSg
 cڡ& 
h
) const;

235 
AayIndex
 
dex
() const;

237 cڡ* 
da
() const;

238 
ngth
() const;

239 
bo
 
isSticSg
() const;

241 
	give
:

242 
sw
(
CZSg
& 
h
);

244 
	sSgStage
 {

245 
	gpicy_
: 2;

246 
	gngth_
: 30;

249 cڡ* 
	gcr_
;

251 
AayIndex
 
	gdex_
;

252 
SgStage
 
	gage_
;

256 
	gpublic
:

257 #ide
JSON_USE_CPPTL_SMALLMAP


258 
d
::
	tm
<
	tCZSg
, 
	tVue
> 
	tObjeVues
;

260 
	gCTL
::
	tSmlM
<
	tCZSg
, 
	tVue
> 
	tObjeVues
;

264 
	gpublic
:

280 
Vue
(
VueTy
 
ty
 = 
nuVue
);

281 
Vue
(
I
 
vue
);

282 
Vue
(
UI
 
vue
);

283 #i
defed
(
JSON_HAS_INT64
)

284 
Vue
(
I64
 
vue
);

285 
Vue
(
UI64
 
vue
);

287 
Vue
(
vue
);

288 
Vue
(cڡ * 
vue
);

289 
Vue
(cڡ * 
beg
, cڡ * 
d
);

305 
Vue
(cڡ 
SticSg
& 
vue
);

306 
Vue
(cڡ 
JSONCPP_STRING
& 
vue
);

307 #ifde
JSON_USE_CPPTL


308 
Vue
(cڡ 
CTL
::
CڡSg
& 
vue
);

310 
Vue
(
bo
 
vue
);

312 
Vue
(cڡ Vue& 
h
);

313 #i
JSON_HAS_RVALUE_REFERENCES


315 
Vue
(Vue&& 
h
);

317 ~
Vue
();

321 
	gVue
& 
	gݔ
=(
Vue
 
h
);

323 
sw
(
Vue
& 
h
);

325 
swPayld
(
Vue
& 
h
);

327 
VueTy
 
ty
() const;

330 
bo
 
	gݔ
<(cڡ 
	gVue
& 
	gh
) const;

331 
bo
 
	gݔ
<=(cڡ 
Vue
& 
h
) const;

332 
bo
 
	gݔ
>=(cڡ 
Vue
& 
h
) const;

333 
bo
 
	gݔ
>(cڡ 
	gVue
& 
	gh
) const;

334 
bo
 
	gݔ
==(cڡ 
Vue
& 
h
) const;

335 
bo
 
	gݔ
!=(cڡ 
Vue
& 
h
) const;

336 
com
(cڡ 
Vue
& 
h
) const;

338 cڡ * 
asCSg
() const;

339 #i
JSONCPP_USING_SECURE_MEMORY


340 
gCSgLgth
() const;

342 
JSONCPP_STRING
 
asSg
() const;

346 
bo
 
gSg
(

347 cڡ** 
beg
, cڡ** 
d
) const;

348 #ifde
JSON_USE_CPPTL


349 
	gCTL
::
CڡSg
 
asCڡSg
() const;

351 
I
 
asI
() const;

352 
UI
 
asUI
() const;

353 #i
defed
(
JSON_HAS_INT64
)

354 
I64
 
asI64
() const;

355 
UI64
 
asUI64
() const;

357 
LgeI
 
asLgeI
() const;

358 
LgeUI
 
asLgeUI
() const;

359 
asFlt
() const;

360 
asDoub
() const;

361 
bo
 
asBo
() const;

363 
bo
 
isNu
() const;

364 
bo
 
isBo
() const;

365 
bo
 
isI
() const;

366 
bo
 
isI64
() const;

367 
bo
 
isUI
() const;

368 
bo
 
isUI64
() const;

369 
bo
 
isIegl
() const;

370 
bo
 
isDoub
() const;

371 
bo
 
isNumic
() const;

372 
bo
 
isSg
() const;

373 
bo
 
isAay
() const;

374 
bo
 
isObje
() const;

376 
bo
 
isCvtibTo
(
VueTy
 
h
) const;

379 
AayIndex
 
size
() const;

383 
bo
 
emy
() const;

386 
bo
 
	gݔ
!() const;

391 
r
();

398 
size
(
AayIndex
 
size
);

406 
	gVue
& 
	gݔ
[](
AayIndex
 
	gdex
);

414 
	gVue
& 
	gݔ
[](
	gdex
);

419 cڡ 
	gVue
& 
	gݔ
[](
AayIndex
 
	gdex
) const;

424 cڡ 
	gVue
& 
	gݔ
[](
	gdex
) const;

429 
Vue
 
g
(
AayIndex
 
dex
, cڡ Vue& 
deuVue
) const;

431 
bo
 
isVidIndex
(
AayIndex
 
dex
) const;

435 
	gVue
& 
nd
(cڡ 
Vue
& 
vue
);

440 
	gVue
& 
	gݔ
[](cڡ * 
	gkey
);

443 cڡ 
	gVue
& 
	gݔ
[](cڡ * 
	gkey
) const;

446 
	gVue
& 
	gݔ
[](cڡ 
	gJSONCPP_STRING
& 
	gkey
);

450 cڡ 
	gVue
& 
	gݔ
[](cڡ 
	gJSONCPP_STRING
& 
	gkey
) const;

463 
	gVue
& 
	gݔ
[](cڡ 
	gSticSg
& 
	gkey
);

464 #ifde
JSON_USE_CPPTL


466 
	gVue
& 
	gݔ
[](cڡ 
	gCTL
::
CڡSg
& 
key
);

469 cڡ 
	gVue
& 
	gݔ
[](cڡ 
	gCTL
::
CڡSg
& 
key
) const;

473 
Vue
 
g
(cڡ * 
key
, cڡ Vue& 
deuVue
) const;

477 
Vue
 
g
(cڡ * 
beg
, cڡ * 
d
, cڡ Vue& 
deuVue
) const;

481 
Vue
 
g
(cڡ 
JSONCPP_STRING
& 
key
, cڡ Vue& 
deuVue
) const;

482 #ifde
JSON_USE_CPPTL


485 
Vue
 
g
(cڡ 
CTL
::
CڡSg
& 
key
, cڡ Vue& 
deuVue
) const;

490 
Vue
 cڡ* 
fd
(cڡ* 
beg
, cڡ* 
d
) const;

494 
Vue
 cڡ* 
demd
(cڡ* 
beg
, cڡ* 
d
);

502 
Vue
 
moveMemb
(cڡ * 
key
);

506 
Vue
 
moveMemb
(cڡ 
JSONCPP_STRING
& 
key
);

509 
bo
 
moveMemb
(cڡ * 
key
, 
Vue
* 
moved
);

516 
bo
 
moveMemb
(
JSONCPP_STRING
 cڡ& 
key
, 
Vue
* 
moved
);

518 
bo
 
moveMemb
(cڡ * 
beg
, cڡ * 
d
, 
Vue
* 
moved
);

525 
bo
 
moveIndex
(
AayIndex
 
i
, 
Vue
* 
moved
);

529 
bo
 
isMemb
(cڡ * 
key
) const;

532 
bo
 
isMemb
(cڡ 
JSONCPP_STRING
& 
key
) const;

534 
bo
 
isMemb
(cڡ * 
beg
, cڡ * 
d
) const;

535 #ifde
JSON_USE_CPPTL


537 
bo
 
isMemb
(cڡ 
CTL
::
CڡSg
& 
key
) const;

545 
Membs
 
gMembNames
() const;

553 
JSONCPP_DEPRECATED
("Use setComment(JSONCPP_STRING const&) instead.")

554 
tCommt
(cڡ * 
commt
, 
CommtPmt
 
amt
);

556 
tCommt
(cڡ * 
commt
, 
size_t
 
n
, 
CommtPmt
 
amt
);

558 
tCommt
(cڡ 
JSONCPP_STRING
& 
commt
, 
CommtPmt
 
amt
);

559 
bo
 
hasCommt
(
CommtPmt
 
amt
) const;

561 
JSONCPP_STRING
 
gCommt
(
CommtPmt
 
amt
) const;

563 
JSONCPP_STRING
 
toStydSg
() const;

565 
cڡ_
 
beg
() const;

566 
cڡ_
 
d
() const;

568 

 
beg
();

569 

 
d
();

573 
tOfftS
(
rdiff_t
 
t
);

574 
tOfftLim
(
rdiff_t
 
lim
);

575 
rdiff_t
 
gOfftS
() const;

576 
rdiff_t
 
gOfftLim
() const;

578 
	give
:

579 
Basic
(
VueTy
 
ty
, 
bo
 
lod
 = 
l
);

581 
	gVue
& 
sveRen
(cڡ * 
key
);

582 
	gVue
& 
sveRen
(cڡ * 
key
, cڡ * 
d
);

584 
	sCommtInfo
 {

585 
CommtInfo
();

586 ~
CommtInfo
();

588 
tCommt
(cڡ * 
xt
, 
size_t
 
n
);

590 * 
	gcommt_
;

602 
	uVueHd
 {

603 
LgeI
 
	gt_
;

604 
LgeUI
 
	gut_
;

605 
	g_
;

606 
bo
 
	gbo_
;

607 * 
	grg_
;

608 
ObjeVues
* 
	gm_
;

609 } 
	gvue_
;

610 
VueTy
 
	gty_
 : 8;

611 
	glod_
 : 1;

613 
CommtInfo
* 
	gcommts_
;

617 
rdiff_t
 
	gt_
;

618 
rdiff_t
 
	glim_
;

624 as
	cJSON_API
 
	gPhArgumt
 {

625 
	gpublic
:

626 
nd
 
ass
 
Ph
;

628 
PhArgumt
();

629 
PhArgumt
(
AayIndex
 
dex
);

630 
PhArgumt
(cڡ * 
key
);

631 
PhArgumt
(cڡ 
JSONCPP_STRING
& 
key
);

633 
	give
:

634 
	eKd
 {

635 
kdNe
 = 0,

636 
	gkdIndex
,

637 
	gkdKey


639 
JSONCPP_STRING
 
	gkey_
;

640 
AayIndex
 
	gdex_
;

641 
Kd
 
	gkd_
;

655 as
	cJSON_API
 
	gPh
 {

656 
	gpublic
:

657 
Ph
(cڡ 
JSONCPP_STRING
& 
th
,

658 cڡ 
PhArgumt
& 
a1
 = PathArgument(),

659 cڡ 
PhArgumt
& 
a2
 = PathArgument(),

660 cڡ 
PhArgumt
& 
a3
 = PathArgument(),

661 cڡ 
PhArgumt
& 
a4
 = PathArgument(),

662 cڡ 
PhArgumt
& 
a5
 = PathArgument());

664 cڡ 
	gVue
& 
sve
(cڡ 
Vue
& 
ro
) const;

665 
Vue
 
sve
(cڡ Vue& 
ro
, cڡ Vue& 
deuVue
) const;

668 
	gVue
& 
make
(
Vue
& 
ro
) const;

670 
	give
:

671 
d
::
	tve
<cڡ 
	tPhArgumt
*> 
	tInArgs
;

672 
	gd
::
	tve
<
	tPhArgumt
> 
	tArgs
;

674 
makePh
(cڡ 
JSONCPP_STRING
& 
th
, cڡ 
InArgs
& 

);

675 
addPhInArg
(cڡ 
JSONCPP_STRING
& 
th
,

676 cڡ 
InArgs
& 

,

677 
InArgs
::
cڡ_
& 
InArg
,

678 
PhArgumt
::
Kd
 
kd
);

679 
vidPh
(cڡ 
JSONCPP_STRING
& 
th
, 
loti
);

681 
Args
 
	ggs_
;

687 as
	cJSON_API
 
	gVueItBa
 {

688 
	gpublic
:

689 
d
::
	tbideiڮ__g
 
	t_gy
;

690 
	tsize_t
;

691 
	tdifn_ty
;

692 
VueItBa
 
	tSfTy
;

694 
bo
 
	gݔ
==(cڡ 
SfTy
& 
h
cڡ {  
isEqu
(other); }

696 
bo
 
	gݔ
!=(cڡ 
SfTy
& 
h
cڡ {  !
isEqu
(other); }

698 
difn_ty
 
	gݔ
-(cڡ 
	gSfTy
& 
	gh
) const {

699  
	gh
.
compuDi
(*
this
);

704 
Vue
 
key
() const;

707 
UI
 
dex
() const;

712 
JSONCPP_STRING
 
me
() const;

717 
JSONCPP_DEPRECATED
("Use `key =ame();` instead.")

718 cڡ* 
membName
() const;

722 cڡ* 
membName
(cڡ** 
d
) const;

724 
	geed
:

725 
Vue
& 
def
() const;

727 
emt
();

729 
deemt
();

731 
difn_ty
 
compuDi
(cڡ 
SfTy
& 
h
) const;

733 
bo
 
isEqu
(cڡ 
SfTy
& 
h
) const;

735 
cy
(cڡ 
SfTy
& 
h
);

737 
	give
:

738 
Vue
::
ObjeVues
::

 
cut_
;

740 
bo
 
	gisNu_
;

742 
	gpublic
:

745 
VueItBa
();

746 
exic
 
VueItBa
(cڡ 
Vue
::
ObjeVues
::

& 
cut
);

752 as
	cJSON_API
 
	gVueCڡIt
 : 
public
 
VueItBa
 {

753 
nd
 
ass
 
Vue
;

755 
	gpublic
:

756 cڡ 
	tVue
 
	tvue_ty
;

759 cڡ 
	tVue
& 
	tn
;

760 cڡ 
	tVue
* 
	tpor
;

761 
VueCڡIt
 
	tSfTy
;

763 
VueCڡIt
();

764 
VueCڡIt
(
VueIt
 cڡ& 
h
);

766 
	give
:

769 
exic
 
VueCڡIt
(cڡ 
Vue
::
ObjeVues
::

& 
cut
);

770 
	gpublic
:

771 
SfTy
& 
ݔ
=(cڡ 
VueItBa
& 
h
);

773 
SfTy
 
	gݔ
++() {

774 
SfTy
 
mp
(*
this
);

775 ++*
	gthis
;

776  
	gmp
;

779 
SfTy
 
	gݔ
--() {

780 
SfTy
 
mp
(*
this
);

781 --*
	gthis
;

782  
	gmp
;

785 
	gSfTy
& 
	gݔ
--() {

786 
deemt
();

787  *
	gthis
;

790 
	gSfTy
& 
	gݔ
++() {

791 
emt
();

792  *
	gthis
;

795 
n
 
	gݔ
*(cڡ {  
def
(); }

797 
por
 
	gݔ
->(cڡ {  &
def
(); }

802 as
	cJSON_API
 
	gVueIt
 : 
public
 
VueItBa
 {

803 
nd
 
ass
 
Vue
;

805 
	gpublic
:

806 
Vue
 
	tvue_ty
;

807 
	tsize_t
;

808 
	tdifn_ty
;

809 
	gVue
& 
	tn
;

810 
Vue
* 
	tpor
;

811 
VueIt
 
	tSfTy
;

813 
VueIt
();

814 
exic
 
VueIt
(cڡ 
VueCڡIt
& 
h
);

815 
VueIt
(cڡ VueIt& 
h
);

817 
	give
:

820 
exic
 
VueIt
(cڡ 
Vue
::
ObjeVues
::

& 
cut
);

821 
	gpublic
:

822 
SfTy
& 
ݔ
=(cڡ SfTy& 
h
);

824 
SfTy
 
	gݔ
++() {

825 
SfTy
 
mp
(*
this
);

826 ++*
	gthis
;

827  
	gmp
;

830 
SfTy
 
	gݔ
--() {

831 
SfTy
 
mp
(*
this
);

832 --*
	gthis
;

833  
	gmp
;

836 
	gSfTy
& 
	gݔ
--() {

837 
deemt
();

838  *
	gthis
;

841 
	gSfTy
& 
	gݔ
++() {

842 
emt
();

843  *
	gthis
;

846 
n
 
	gݔ
*(cڡ {  
def
(); }

848 
por
 
	gݔ
->(cڡ {  &
def
(); }

854 
mea
 
	gd
 {

856 
	gme
<>

857 
le
 
sw
(
Js
::
Vue
& 
a
, Js::Vue& 
b
) {.swap(b); }

861 #i
defed
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)

862 #agm
wng
(
p
)

	@open_source/jsoncpp-1.7.2.no-abi/include/json/version.h

3 #ide
JSON_VERSION_H_INCLUDED


4 
	#JSON_VERSION_H_INCLUDED


	)

6 
	#JSONCPP_VERSION_STRING
 "1.7.2"

	)

7 
	#JSONCPP_VERSION_MAJOR
 1

	)

8 
	#JSONCPP_VERSION_MINOR
 7

	)

9 
	#JSONCPP_VERSION_PATCH
 2

	)

10 
	#JSONCPP_VERSION_QUALIFIER


	)

11 
	#JSONCPP_VERSION_HEXA
 ((
JSONCPP_VERSION_MAJOR
 << 24| (
JSONCPP_VERSION_MINOR
 << 16| (
JSONCPP_VERSION_PATCH
 << 8))

	)

13 #ifde
JSONCPP_USING_SECURE_MEMORY


14 #unde
JSONCPP_USING_SECURE_MEMORY


16 
	#JSONCPP_USING_SECURE_MEMORY
 0

	)

	@open_source/jsoncpp-1.7.2.no-abi/include/json/writer.h

6 #ide
JSON_WRITER_H_INCLUDED


7 
	#JSON_WRITER_H_INCLUDED


	)

9 #i!
defed
(
JSON_IS_AMALGAMATION
)

10 
	~"vue.h
"

12 
	~<ve
>

13 
	~<rg
>

14 
	~<oam
>

18 #i
defed
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)

19 #agm
wng
(
push
)

20 #agm
wng
(
dib
 : 4251)

23 
mea
 
	gJs
 {

25 
ass
 
	gVue
;

40 as
	cJSON_API
 
	gSmWr
 {

41 
	geed
:

42 
JSONCPP_OSTREAM
* 
sout_
;

43 
	gpublic
:

44 
SmWr
();

45 
	gvtu
 ~
SmWr
();

52 
vtu
 
wre
(
Vue
 cڡ& 
ro
, 
JSONCPP_OSTREAM
* 
sout
) = 0;

56 as
	cJSON_API
 
	gFay
 {

57 
	gpublic
:

58 
vtu
 ~
Fay
();

62 
vtu
 
SmWr
* 
wSmWr
() const = 0;

69 
JSONCPP_STRING
 
JSON_API
 
wreSg
(
SmWr
::
Fay
 cڡ& 
y
, 
Vue
 cڡ& 
ro
);

87 as
	cJSON_API
 
	gSmWrBud
 : 
public
 
SmWr
::
Fay
 {

88 
public
:

112 
Js
::
Vue
 
gs_
;

114 
SmWrBud
();

115 ~
SmWrBud
(
	gJSONCPP_OVERRIDE
;

120 
SmWr
* 
wSmWr
(cڡ 
	gJSONCPP_OVERRIDE
;

125 
bo
 
vide
(
Js
::
Vue
* 
vid
) const;

128 
	gVue
& 
	gݔ
[](
JSONCPP_STRING
 
	gkey
);

135 
tDeus
(
Js
::
Vue
* 
gs
);

141 as
	cJSON_API
 
	gWr
 {

142 
	gpublic
:

143 
vtu
 ~
Wr
();

145 
vtu
 
JSONCPP_STRING
 
wre
(cڡ 
Vue
& 
ro
) = 0;

157 as
	cJSON_API
 
	gFaWr
 : 
public
 
Wr
 {

159 
public
:

160 
FaWr
();

161 ~
FaWr
(
	gJSONCPP_OVERRIDE
 {}

163 
abYAMLComtiby
();

170 
drNuPhds
();

172 
omEndgLeFd
();

174 
	gpublic
:

175 
JSONCPP_STRING
 
wre
(cڡ 
Vue
& 
ro

JSONCPP_OVERRIDE
;

177 
	give
:

178 
wreVue
(cڡ 
Vue
& 
vue
);

180 
JSONCPP_STRING
 
	gdocumt_
;

181 
bo
 
	gyamlComtiblyEbd_
;

182 
bo
 
	gdrNuPhds_
;

183 
bo
 
	gomEndgLeFd_
;

210 as
	cJSON_API
 
	gStydWr
 : 
public
 
Wr
 {

211 
public
:

212 
StydWr
();

213 ~
StydWr
(
	gJSONCPP_OVERRIDE
 {}

215 
	gpublic
:

220 
JSONCPP_STRING
 
wre
(cڡ 
Vue
& 
ro

JSONCPP_OVERRIDE
;

222 
	give
:

223 
wreVue
(cڡ 
Vue
& 
vue
);

224 
wreAayVue
(cڡ 
Vue
& 
vue
);

225 
bo
 
isMuɚeAay
(cڡ 
Vue
& 
vue
);

226 
pushVue
(cڡ 
JSONCPP_STRING
& 
vue
);

227 
wreIndt
();

228 
wreWhIndt
(cڡ 
JSONCPP_STRING
& 
vue
);

229 
dt
();

230 
undt
();

231 
wreCommtBefeVue
(cڡ 
Vue
& 
ro
);

232 
wreCommtAVueOnSameLe
(cڡ 
Vue
& 
ro
);

233 
bo
 
hasCommtFVue
(cڡ 
Vue
& 
vue
);

234 
JSONCPP_STRING
 
nmizeEOL
(cڡ JSONCPP_STRING& 
xt
);

236 
	gd
::
	tve
<
	tJSONCPP_STRING
> 
	tChdVues
;

238 
ChdVues
 
	gchdVues_
;

239 
JSONCPP_STRING
 
	gdocumt_
;

240 
JSONCPP_STRING
 
	gdtSg_
;

241 
	grightMg_
;

242 
	gdtSize_
;

243 
bo
 
	gaddChdVues_
;

272 as
	cJSON_API
 
	gStydSmWr
 {

273 
	gpublic
:

274 
StydSmWr
(
JSONCPP_STRING
 
dti
 = "\t");

275 ~
StydSmWr
() {}

277 
	gpublic
:

284 
wre
(
JSONCPP_OSTREAM
& 
out
, cڡ 
Vue
& 
ro
);

286 
	give
:

287 
wreVue
(cڡ 
Vue
& 
vue
);

288 
wreAayVue
(cڡ 
Vue
& 
vue
);

289 
bo
 
isMuɚeAay
(cڡ 
Vue
& 
vue
);

290 
pushVue
(cڡ 
JSONCPP_STRING
& 
vue
);

291 
wreIndt
();

292 
wreWhIndt
(cڡ 
JSONCPP_STRING
& 
vue
);

293 
dt
();

294 
undt
();

295 
wreCommtBefeVue
(cڡ 
Vue
& 
ro
);

296 
wreCommtAVueOnSameLe
(cڡ 
Vue
& 
ro
);

297 
bo
 
hasCommtFVue
(cڡ 
Vue
& 
vue
);

298 
JSONCPP_STRING
 
nmizeEOL
(cڡ JSONCPP_STRING& 
xt
);

300 
	gd
::
	tve
<
	tJSONCPP_STRING
> 
	tChdVues
;

302 
ChdVues
 
	gchdVues_
;

303 
JSONCPP_OSTREAM
* 
	gdocumt_
;

304 
JSONCPP_STRING
 
	gdtSg_
;

305 
	grightMg_
;

306 
JSONCPP_STRING
 
	gdti_
;

307 
bo
 
	gaddChdVues_
 : 1;

308 
bo
 
	gdd_
 : 1;

311 #i
	$defed
(
JSON_HAS_INT64
)

312 
JSONCPP_STRING
 
JSON_API
 
	`vueToSg
(
I
 
vue
);

313 
JSONCPP_STRING
 
JSON_API
 
	`vueToSg
(
UI
 
vue
);

315 
JSONCPP_STRING
 
JSON_API
 
	`vueToSg
(
LgeI
 
vue
);

316 
JSONCPP_STRING
 
JSON_API
 
	`vueToSg
(
LgeUI
 
vue
);

317 
JSONCPP_STRING
 
JSON_API
 
	`vueToSg
(
vue
);

318 
JSONCPP_STRING
 
JSON_API
 
	`vueToSg
(
bo
 
vue
);

319 
JSONCPP_STRING
 
JSON_API
 
	`vueToQuedSg
(cڡ * 
vue
);

323 
JSON_API
 
JSONCPP_OSTREAM
& 
ݔ
<<(JSONCPP_OSTREAM&, cڡ 
Vue
& 
ro
);

325 
	}
}

327 #i
defed
(
JSONCPP_DISABLE_DLL_INTERFACE_WARNING
)

328 #agm
wng
(
p
)

	@open_source/jsoncpp-1.7.2.no-abi/src/jsontestrunner/main.cpp

9 
	~<js/js.h
>

10 
	~<gܙhm
>

11 
	~<sam
>

12 
	~<dio.h
>

14 #i
defed
(
_MSC_VER
) && _MSC_VER >= 1310

15 #agm
wng
(
dib
 : 4996)

18 
	sOis


20 
JSONCPP_STRING
 
	mth
;

21 
	mJs
::
Ftus
 
us
;

22 
bo
 
	mrOy
;

23 
JSONCPP_STRING
 (*
	twreFuncTy
)(
	tJs
::
	tVue
 const&);

24 
wreFuncTy
 
	mwre
;

27 
JSONCPP_STRING
 
	$nmizeFltgPotS
(
vue
) {

28 
bufr
[32];

29 #i
	`defed
(
_MSC_VER
&& defed(
__STDC_SECURE_LIB__
)

30 
	`rtf_s
(
bufr
, (bufr), "%.16g", 
vue
);

32 
	`tf
(
bufr
, (bufr), "%.16g", 
vue
);

34 
bufr
[(buffer) - 1] = 0;

35 
JSONCPP_STRING
 
	`s
(
bufr
);

36 
JSONCPP_STRING
::
size_ty
 
dex
 = 
s
.
	`fd_ϡ_of
("eE");

37 i(
dex
 !
JSONCPP_STRING
::
os
) {

38 
JSONCPP_STRING
::
size_ty
 
hasSign
 =

39 (
s
[
dex
 + 1] == '+' || s[index + 1] == '-') ? 1 : 0;

40 
JSONCPP_STRING
::
size_ty
 
expڒtSIndex
 = 
dex
 + 1 + 
hasSign
;

41 
JSONCPP_STRING
 
nmized
 = 
s
.
	`subr
(0, 
expڒtSIndex
);

42 
JSONCPP_STRING
::
size_ty
 
dexDig
 =

43 
s
.
	`fd_f_n_of
('0', 
expڒtSIndex
);

44 
JSONCPP_STRING
 
expڒt
 = "0";

45 i(
dexDig
 !=

46 
JSONCPP_STRING
::
os
)

48 
expڒt
 = 
s
.
	`subr
(
dexDig
);

50  
nmized
 + 
expڒt
;

52  
s
;

53 
	}
}

55 
JSONCPP_STRING
 
	$adIutTeFe
(cڡ * 
th
) {

56 
FILE
* 
fe
 = 
	`fݒ
(
th
, "rb");

57 i(!
fe
)

58  
	`JSONCPP_STRING
("");

59 
	`fek
(
fe
, 0, 
SEEK_END
);

60 cڡ 
size
 = 
	`l
(
fe
);

61 cڡ 
usize
 = 
ic_
<cڡ>(
size
);

62 
	`fek
(
fe
, 0, 
SEEK_SET
);

63 
JSONCPP_STRING
 
xt
;

64 * 
bufr
 = 
w
 [
size
 + 1];

65 
bufr
[
size
] = 0;

66 i(
	`d
(
bufr
, 1, 
usize
, 
fe
) == usize)

67 
xt
 = 
bufr
;

68 
	`fo
(
fe
);

69 
de
[] 
bufr
;

70  
xt
;

71 
	}
}

74 
tVueTe
(
FILE
* 
fout
, 
Js
::
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
th
 = ".") {

75 i(
vue
.
hasCommt
(
Js
::
commtBefe
)) {

76 
rtf
(
fout
, "%s\n", 
vue
.
gCommt
(
Js
::
commtBefe
).
c_r
());

78 
	gvue
.
ty
()) {

79 
	gJs
::
nuVue
:

80 
rtf
(
fout
, "%su\n", 
th
.
c_r
());

82 
	gJs
::
tVue
:

83 
rtf
(
fout
,

85 
th
.
c_r
(),

86 
Js
::
vueToSg
(
vue
.
asLgeI
()).
c_r
());

88 
	gJs
::
utVue
:

89 
rtf
(
fout
,

91 
th
.
c_r
(),

92 
Js
::
vueToSg
(
vue
.
asLgeUI
()).
c_r
());

94 
	gJs
::
Vue
:

95 
rtf
(
fout
,

97 
th
.
c_r
(),

98 
nmizeFltgPotS
(
vue
.
asDoub
()).
c_r
());

100 
	gJs
::
rgVue
:

101 
rtf
(
fout
, "%s=\"%s\"\n", 
th
.
c_r
(), 
vue
.
asSg
().c_str());

103 
	gJs
::
boޗnVue
:

104 
rtf
(
fout
, "%s=%s\n", 
th
.
c_r
(), 
vue
.
asBo
() ? "true" : "false");

106 
	gJs
::
yVue
: {

107 
rtf
(
fout
, "%s=[]\n", 
th
.
c_r
());

108 
	gJs
::
AayIndex
 
size
 = 
vue
.size();

109 
	gJs
::
AayIndex
 
dex
 = 0; 
	gdex
 < 
	gsize
; ++index) {

110 
	gbufr
[16];

111 #i
defed
(
_MSC_VER
&& defed(
__STDC_SECURE_LIB__
)

112 
rtf_s
(
bufr
, (bufr), "[%d]", 
dex
);

114 
tf
(
bufr
, (bufr), "[%d]", 
dex
);

116 
tVueTe
(
fout
, 
vue
[
dex
], 
th
 + 
bufr
);

119 
	gJs
::
objeVue
: {

120 
rtf
(
fout
, "%s={}\n", 
th
.
c_r
());

121 
	gJs
::
Vue
::
Membs
 
membs
(
vue
.
gMembNames
());

122 
	gd
::
st
(
membs
.
beg
(), membs.
d
());

123 
JSONCPP_STRING
 
	gsuffix
 = *(
th
.
d
() - 1) == '.' ? "" : ".";

124 
	gJs
::
Vue
::
Membs
::

 

 = 
membs
.
beg
();

125 
	g
 !
membs
.
d
();

126 ++
	g
) {

127 cڡ 
JSONCPP_STRING
 
	gme
 = *

;

128 
tVueTe
(
fout
, 
vue
[
me
], 
th
 + 
suffix
 +ame);

135 i(
	gvue
.
hasCommt
(
Js
::
commtA
)) {

136 
rtf
(
fout
, "%s\n", 
vue
.
gCommt
(
Js
::
commtA
).
c_r
());

140 
	$rAndSaveVueTe
(cڡ 
JSONCPP_STRING
& 
put
,

141 cڡ 
JSONCPP_STRING
& 
au
,

142 cڡ 
JSONCPP_STRING
& 
kd
,

143 cڡ 
Js
::
Ftus
& 
us
,

144 
bo
 
rOy
,

145 
Js
::
Vue
* 
ro
)

147 
Js
::
Rd
 
	`ad
(
us
);

148 
bo
 
rsgSucssful
 = 
ad
.
	`r
(
put
.
	`da
(), iut.da(+ iut.
	`size
(), *
ro
);

149 i(!
rsgSucssful
) {

150 
	`tf
("Failedoarse %s file: \n%s\n",

151 
kd
.
	`c_r
(),

152 
ad
.
	`gFmdEMesges
().
	`c_r
());

155 i(!
rOy
) {

156 
FILE
* 
u
 = 
	`fݒ
(
au
.
	`c_r
(), "wt");

157 i(!
u
) {

158 
	`tf
("Faed %au fe.\n", 
kd
.
	`c_r
());

161 
	`tVueTe
(
u
, *
ro
);

162 
	`fo
(
u
);

165 
	}
}

171 
JSONCPP_STRING
 
	$uStydWr
(

172 
Js
::
Vue
 cڡ& 
ro
)

174 
Js
::
StydWr
 
wr
;

175  
wr
.
	`wre
(
ro
);

176 
	}
}

177 
JSONCPP_STRING
 
	$uStydSmWr
(

178 
Js
::
Vue
 cڡ& 
ro
)

180 
Js
::
StydSmWr
 
wr
;

181 
JSONCPP_OSTRINGSTREAM
 
sout
;

182 
wr
.
	`wre
(
sout
, 
ro
);

183  
sout
.
	`r
();

184 
	}
}

185 
JSONCPP_STRING
 
	$uButStydSmWr
(

186 
Js
::
Vue
 cڡ& 
ro
)

188 
Js
::
SmWrBud
 
bud
;

189  
Js
::
	`wreSg
(
bud
, 
ro
);

190 
	}
}

191 
	$wreVueTe
(

192 cڡ 
JSONCPP_STRING
& 
wrePh
,

193 cڡ 
Js
::
Vue
& 
ro
,

194 
Ois
::
wreFuncTy
 
wre
,

195 
JSONCPP_STRING
* 
wre
)

197 *
wre
 = 
	`wre
(
ro
);

198 
FILE
* 
fout
 = 
	`fݒ
(
wrePh
.
	`c_r
(), "wt");

199 i(!
fout
) {

200 
	`tf
("Faedewrfe: %s\n", 
wrePh
.
	`c_r
());

203 
	`rtf
(
fout
, "%s\n", 
wre
->
	`c_r
());

204 
	`fo
(
fout
);

206 
	}
}

208 
JSONCPP_STRING
 
	$moveSuffix
(cڡ 
JSONCPP_STRING
& 
th
,

209 cڡ 
JSONCPP_STRING
& 
exnsi
) {

210 i(
exnsi
.
	`ngth
(>
th
.length())

211  
	`JSONCPP_STRING
("");

212 
JSONCPP_STRING
 
suffix
 = 
th
.
	`subr
թh.
	`ngth
(- 
exnsi
.length());

213 i(
suffix
 !
exnsi
)

214  
	`JSONCPP_STRING
("");

215  
th
.
	`subr
(0,h.
	`ngth
(- 
exnsi
.length());

216 
	}
}

218 
	$tCfig
() {

220 #i
	`defed
(
JSON_NO_INT64
)

221 
	`tf
("JSON_NO_INT64=1\n");

223 
	`tf
("JSON_NO_INT64=0\n");

225 
	}
}

227 
	$tUge
(cڡ * 
gv
[]) {

228 
	`tf
("Uge: %[--ri] iut-js-fe", 
gv
[0]);

230 
	}
}

232 
	$rCommdLe
(

233 
gc
, cڡ * 
gv
[], 
Ois
* 
ts
)

235 
ts
->
rOy
 = 
l
;

236 
ts
->
wre
 = &
uStydWr
;

237 i(
gc
 < 2) {

238  
	`tUge
(
gv
);

240 
dex
 = 1;

241 i(
	`JSONCPP_STRING
(
gv
[
dex
]) == "--json-checker") {

242 
ts
->
us
 = 
Js
::
Ftus
::
	`riMode
();

243 
ts
->
rOy
 = 
ue
;

244 ++
dex
;

246 i(
	`JSONCPP_STRING
(
gv
[
dex
]) == "--json-config") {

247 
	`tCfig
();

250 i(
	`JSONCPP_STRING
(
gv
[
dex
]) == "--json-writer") {

251 ++
dex
;

252 
JSONCPP_STRING
 cڡ 
	`wrName
(
gv
[
dex
++]);

253 i(
wrName
 == "StyledWriter") {

254 
ts
->
wre
 = &
uStydWr
;

255 } i(
wrName
 == "StyledStreamWriter") {

256 
ts
->
wre
 = &
uStydSmWr
;

257 } i(
wrName
 == "BuiltStyledStreamWriter") {

258 
ts
->
wre
 = &
uButStydSmWr
;

260 
	`tf
("Unknow'--js-wr %s'\n", 
wrName
.
	`c_r
());

264 i(
dex
 =
gc
 || index + 1 <rgc) {

265  
	`tUge
(
gv
);

267 
ts
->
th
 = 
gv
[
dex
];

269 
	}
}

270 
	$runTe
(
Ois
 cڡ& 
ts
)

272 
exCode
 = 0;

274 
JSONCPP_STRING
 
put
 = 
	`adIutTeFe
(
ts
.
th
.
	`c_r
());

275 i(
put
.
	`emy
()) {

276 
	`tf
("Faedػad iu܃my iut: %s\n", 
ts
.
th
.
	`c_r
());

280 
JSONCPP_STRING
 
baPh
 = 
	`moveSuffix
(
ts
.
th
, ".json");

281 i(!
ts
.
rOy
 && 
baPh
.
	`emy
()) {

282 
	`tf
("Bad inputath. Path doesotnd with '.expected':\n%s\n",

283 
ts
.
th
.
	`c_r
());

287 
JSONCPP_STRING
 cڡ 
auPh
 = 
baPh
 + ".actual";

288 
JSONCPP_STRING
 cڡ 
wrePh
 = 
baPh
 + ".rewrite";

289 
JSONCPP_STRING
 cڡ 
wreAuPh
 = 
baPh
 + ".actual-rewrite";

291 
Js
::
Vue
 
ro
;

292 
exCode
 = 
	`rAndSaveVueTe
(

293 
put
, 
auPh
, "input",

294 
ts
.
us
, os.
rOy
, &
ro
);

295 i(
exCode
 || 
ts
.
rOy
) {

296  
exCode
;

298 
JSONCPP_STRING
 
wre
;

299 
exCode
 = 
	`wreVueTe
(
wrePh
, 
ro
, 
ts
.
wre
, &
wre
);

300 i(
exCode
) {

301  
exCode
;

303 
Js
::
Vue
 
wreRo
;

304 
exCode
 = 
	`rAndSaveVueTe
(

305 
wre
, 
wreAuPh
, "rewrite",

306 
ts
.
us
, os.
rOy
, &
wreRo
);

307 i(
exCode
) {

308  
exCode
;

311 
	}
}

312 
	$ma
(
gc
, cڡ * 
gv
[]) {

313 
Ois
 
ts
;

314 
y
 {

315 
exCode
 = 
	`rCommdLe
(
gc
, 
gv
, &
ts
);

316 i(
exCode
 != 0) {

317 
	`tf
("Failedoarse command-line.");

318  
exCode
;

320  
	`runTe
(
ts
);

322 
	`tch
 (cڡ 
d
::
exi
& 
e
) {

323 
	`tf
("Unhddxi:\n%s\n", 
e
.
	`wh
());

326 
	}
}

	@open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_reader.cpp

6 #i!
defed
(
JSON_IS_AMALGAMATION
)

7 
	~<js/asis.h
>

8 
	~<js/ad.h
>

9 
	~<js/vue.h
>

10 
	~"js_to.h
"

12 
	~<uty
>

13 
	~<cdio
>

14 
	~<s
>

15 
	~<crg
>

16 
	~<iam
>

17 
	~<sam
>

18 
	~<memy
>

19 
	~<t
>

20 
	~<lims
>

22 #i
defed
(
_MSC_VER
)

23 #i!
defed
(
WINCE
&& defed(
__STDC_SECURE_LIB__
&& 
_MSC_VER
 >= 1500

24 
	#tf
 
rtf_s


	)

25 #i
_MSC_VER
 >= 1900

26 
	#tf
 
d
::
tf


	)

28 
	#tf
 
_tf


	)

30 #i
defed
(
__ANDROID__
|| defed(
__QNXNTO__
)

31 
	#tf
 
tf


	)

32 #i
__lulus
 >= 201103L

33 #i!
defed
(
__MINGW32__
&& !defed(
__CYGWIN__
)

34 
	#tf
 
d
::
tf


	)

38 #i
defed
(
__QNXNTO__
)

39 
	#ssnf
 
d
::
ssnf


	)

42 #i
defed
(
_MSC_VER
) && _MSC_VER >= 1400

44 #agm
wng
(
dib
 : 4996)

47 cڡ 
	gackLim_g
 = 1000;

48 
	gackDth_g
 = 0;

50 
mea
 
	gJs
 {

52 #i
__lulus
 >201103L || (
defed
(
_CPPLIB_VER
) && _CPPLIB_VER >= 520)

53 
	gd
::
	tunique_r
<
	tChRd
> 
	tChRdP
;

55 
	gd
::
	tauto_r
<
	tChRd
> 
	tChRdP
;

61 
	gFtus
::
Ftus
()

62 : 
lowCommts_
(
ue
), 
riRo_
(
l
),

63 
lowDrݳdNuPhds_
(
l
), 
lowNumicKeys_
(false) {}

65 
Ftus
 
	gFtus
::
l
() {  Features(); }

67 
Ftus
 
	gFtus
::
riMode
() {

68 
Ftus
 
us
;

69 
	gus
.
	glowCommts_
 = 
l
;

70 
	gus
.
	griRo_
 = 
ue
;

71 
	gus
.
	glowDrݳdNuPhds_
 = 
l
;

72 
	gus
.
	glowNumicKeys_
 = 
l
;

73  
	gus
;

79 
bo
 
cڏsNewLe
(
Rd
::
Loti
 
beg
, Rd::Loti 
d
) {

80 ; 
	gbeg
 < 
	gd
; ++begin)

81 i(*
	gbeg
 ='\n' || *
beg
 == '\r')

82  
ue
;

83  
	gl
;

89 
	gRd
::
Rd
()

90 : 
rs_
(), 
documt_
(), 
beg_
(), 
d_
(), 
cut_
(), 
ϡVueEnd_
(),

91 
ϡVue_
(), 
commtsBefe_
(), 
us_
(
Ftus
::
l
()),

92 
cCommts_
() {}

94 
	gRd
::
Rd
(cڡ 
Ftus
& 
us
)

95 : 
rs_
(), 
documt_
(), 
beg_
(), 
d_
(), 
cut_
(), 
ϡVueEnd_
(),

96 
ϡVue_
(), 
commtsBefe_
(), 
us_
(
us
), 
cCommts_
() {

99 
bo


100 
	gRd
::
r
(cڡ 
d
::
rg
& 
documt
, 
Vue
& 
ro
, 
bo
 
cCommts
) {

101 
JSONCPP_STRING
 
documtCy
(
documt
.
da
(), documt.da(+ documt.
cy
());

102 
	gd
::
sw
(
documtCy
, 
documt_
);

103 cڡ * 
	gbeg
 = 
documt_
.
c_r
();

104 cڡ * 
	gd
 = 
beg
 + 
documt_
.
ngth
();

105  
r
(
beg
, 
d
, 
ro
, 
cCommts
);

108 
bo
 
	gRd
::
r
(
d
::
iam
& 
s
, 
Vue
& 
ro
, bo 
cCommts
) {

116 
JSONCPP_STRING
 
	gdoc
;

117 
	gd
::
gle
(
s
, 
doc
, ()
EOF
);

118  
r
(
doc
.
da
(), doc.da(+ doc.
size
(), 
ro
, 
cCommts
);

121 
bo
 
	gRd
::
r
(cڡ * 
begDoc
,

122 cڡ * 
dDoc
,

123 
Vue
& 
ro
,

124 
bo
 
cCommts
) {

125 i(!
	gus_
.
	glowCommts_
) {

126 
	gcCommts
 = 
l
;

129 
	gbeg_
 = 
begDoc
;

130 
	gd_
 = 
dDoc
;

131 
	gcCommts_
 = 
cCommts
;

132 
	gcut_
 = 
beg_
;

133 
	gϡVueEnd_
 = 0;

134 
	gϡVue_
 = 0;

135 
	gcommtsBefe_
 = "";

136 
	grs_
.
r
();

137 !
	gnodes_
.
emy
())

138 
	gnodes_
.
p
();

139 
	gnodes_
.
push
(&
ro
);

141 
	gackDth_g
 = 0;

142 
bo
 
	gsucssful
 = 
adVue
();

143 
Tok
 
	gtok
;

144 
skCommtToks
(
tok
);

145 i(
	gcCommts_
 && !
	gcommtsBefe_
.
emy
())

146 
	gro
.
tCommt
(
commtsBefe_
, 
commtA
);

147 i(
	gus_
.
	griRo_
) {

148 i(!
	gro
.
isAay
(&& !ro.
isObje
()) {

151 
	gtok
.
	gty_
 = 
tokE
;

152 
	gtok
.
	gt_
 = 
begDoc
;

153 
	gtok
.
	gd_
 = 
dDoc
;

154 
addE
(

156 
tok
);

157  
	gl
;

160  
	gsucssful
;

163 
bo
 
	gRd
::
adVue
() {

168 i(
ackDth_g
 >
ackLim_g

throwRuimeE
("Exceeded stackLimit ineadValue().");

169 ++
	gackDth_g
;

171 
Tok
 
	gtok
;

172 
skCommtToks
(
tok
);

173 
bo
 
	gsucssful
 = 
ue
;

175 i(
	gcCommts_
 && !
	gcommtsBefe_
.
emy
()) {

176 
cutVue
().
tCommt
(
commtsBefe_
, 
commtBefe
);

177 
	gcommtsBefe_
 = "";

180 
	gtok
.
	gty_
) {

181 
	gtokObjeBeg
:

182 
sucssful
 = 
adObje
(
tok
);

183 
cutVue
().
tOfftLim
(
cut_
 - 
beg_
);

185 
	gtokAayBeg
:

186 
sucssful
 = 
adAay
(
tok
);

187 
cutVue
().
tOfftLim
(
cut_
 - 
beg_
);

189 
	gtokNumb
:

190 
sucssful
 = 
decodeNumb
(
tok
);

192 
	gtokSg
:

193 
sucssful
 = 
decodeSg
(
tok
);

195 
	gtokTrue
:

197 
Vue
 
v
(
ue
);

198 
cutVue
().
swPayld
(
v
);

199 
cutVue
().
tOfftS
(
tok
.
t_
 - 
beg_
);

200 
cutVue
().
tOfftLim
(
tok
.
d_
 - 
beg_
);

203 
	gtokF
:

205 
Vue
 
v
(
l
);

206 
cutVue
().
swPayld
(
v
);

207 
cutVue
().
tOfftS
(
tok
.
t_
 - 
beg_
);

208 
cutVue
().
tOfftLim
(
tok
.
d_
 - 
beg_
);

211 
	gtokNu
:

213 
Vue
 
v
;

214 
cutVue
().
swPayld
(
v
);

215 
cutVue
().
tOfftS
(
tok
.
t_
 - 
beg_
);

216 
cutVue
().
tOfftLim
(
tok
.
d_
 - 
beg_
);

219 
	gtokAayS
:

220 
tokObjeEnd
:

221 
tokAayEnd
:

222 i(
us_
.
lowDrݳdNuPhds_
) {

225 
cut_
--;

226 
Vue
 
	gv
;

227 
cutVue
().
swPayld
(
v
);

228 
cutVue
().
tOfftS
(
cut_
 - 
beg_
 - 1);

229 
cutVue
().
tOfftLim
(
cut_
 - 
beg_
);

233 
cutVue
().
tOfftS
(
tok
.
t_
 - 
beg_
);

234 
cutVue
().
tOfftLim
(
tok
.
d_
 - 
beg_
);

235  
addE
("Syax: vue, obje oyxed.", 
tok
);

238 i(
	gcCommts_
) {

239 
	gϡVueEnd_
 = 
cut_
;

240 
	gϡVue_
 = &
cutVue
();

243 --
	gackDth_g
;

244  
	gsucssful
;

247 
	gRd
::
skCommtToks
(
Tok
& 
tok
) {

248 i(
us_
.
lowCommts_
) {

250 
adTok
(
tok
);

251 } 
	gtok
.
	gty_
 =
tokCommt
);

253 
adTok
(
tok
);

257 
bo
 
	gRd
::
adTok
(
Tok
& 
tok
) {

258 
skSs
();

259 
	gtok
.
	gt_
 = 
cut_
;

260 
Ch
 
	gc
 = 
gNextCh
();

261 
bo
 
	gok
 = 
ue
;

262 
	gc
) {

264 
tok
.
ty_
 = 
tokObjeBeg
;

267 
tok
.
ty_
 = 
tokObjeEnd
;

270 
tok
.
ty_
 = 
tokAayBeg
;

273 
tok
.
ty_
 = 
tokAayEnd
;

276 
tok
.
ty_
 = 
tokSg
;

277 
	gok
 = 
adSg
();

280 
tok
.
ty_
 = 
tokCommt
;

281 
	gok
 = 
adCommt
();

294 
tok
.
ty_
 = 
tokNumb
;

295 
adNumb
();

298 
tok
.
ty_
 = 
tokTrue
;

299 
	gok
 = 
mch
("rue", 3);

302 
tok
.
ty_
 = 
tokF
;

303 
	gok
 = 
mch
("alse", 4);

306 
tok
.
ty_
 = 
tokNu
;

307 
	gok
 = 
mch
("ull", 3);

310 
tok
.
ty_
 = 
tokAayS
;

313 
tok
.
ty_
 = 
tokMembS
;

316 
tok
.
ty_
 = 
tokEndOfSm
;

319 
ok
 = 
l
;

322 i(!
	gok
)

323 
	gtok
.
	gty_
 = 
tokE
;

324 
	gtok
.
	gd_
 = 
cut_
;

325  
	gue
;

328 
	gRd
::
skSs
() {

329 
cut_
 !
d_
) {

330 
Ch
 
c
 = *
cut_
;

331 i(
	gc
 =' ' || 
c
 == '\t' || c == '\r' || c == '\n')

332 ++
cut_
;

338 
bo
 
	gRd
::
mch
(
Loti
 
n
, 
nLgth
) {

339 i(
	gd_
 - 
	gcut_
 < 
	gnLgth
)

340  
	gl
;

341 
	gdex
 = 
nLgth
;

342 
	gdex
--)

343 i(
	gcut_
[
dex
] !
n
[index])

344  
l
;

345 
	gcut_
 +
nLgth
;

346  
	gue
;

349 
bo
 
	gRd
::
adCommt
() {

350 
Loti
 
commtBeg
 = 
cut_
 - 1;

351 
Ch
 
	gc
 = 
gNextCh
();

352 
bo
 
	gsucssful
 = 
l
;

353 i(
	gc
 == '*')

354 
sucssful
 = 
adCStyCommt
();

355 i(
	gc
 == '/')

356 
sucssful
 = 
adCStyCommt
();

357 i(!
	gsucssful
)

358  
	gl
;

360 i(
	gcCommts_
) {

361 
CommtPmt
 
	gamt
 = 
commtBefe
;

362 i(
	gϡVueEnd_
 && !
cڏsNewLe
(
ϡVueEnd_
, 
commtBeg
)) {

363 i(
	gc
 !'*' || !
cڏsNewLe
(
commtBeg
, 
cut_
))

364 
	gamt
 = 
commtAOnSameLe
;

367 
addCommt
(
commtBeg
, 
cut_
, 
amt
);

369  
	gue
;

372 
JSONCPP_STRING
 
nmizeEOL
(
Rd
::
Loti
 
beg
, Rd::Loti 
d
) {

373 
JSONCPP_STRING
 
nmized
;

374 
	gnmized
.
rve
(
ic_
<
size_t
>(
d
 - 
beg
));

375 
	gRd
::
Loti
 
cut
 = 
beg
;

376 
	gcut
 !
d
) {

377 
c
 = *
cut
++;

378 i(
	gc
 == '\r') {

379 i(
cut
 !
d
 && *current == '\n')

381 ++
cut
;

383 
	gnmized
 += '\n';

385 
	gnmized
 +
c
;

388  
	gnmized
;

392 
	gRd
::
addCommt
(
Loti
 
beg
, Loti 
d
, 
CommtPmt
 
amt
) {

393 
as
(
cCommts_
);

394 cڡ 
	gJSONCPP_STRING
& 
	gnmized
 = 
nmizeEOL
(
beg
, 
d
);

395 i(
	gamt
 =
commtAOnSameLe
) {

396 
as
(
ϡVue_
 != 0);

397 
	gϡVue_
->
tCommt
(
nmized
, 
amt
);

399 
	gcommtsBefe_
 +
nmized
;

403 
bo
 
	gRd
::
adCStyCommt
() {

404 
cut_
 !
d_
) {

405 
Ch
 
c
 = 
gNextCh
();

406 i(
	gc
 ='*' && *
cut_
 == '/')

409  
gNextCh
() == '/';

412 
bo
 
	gRd
::
adCStyCommt
() {

413 
cut_
 !
d_
) {

414 
Ch
 
c
 = 
gNextCh
();

415 i(
	gc
 == '\n')

417 i(
	gc
 == '\r') {

419 i(
cut_
 !
d_
 && *current_ == '\n')

420 
gNextCh
();

425  
	gue
;

428 
	gRd
::
adNumb
() {

429 cڡ *
p
 = 
cut_
;

430 
	gc
 = '0';

432 
	gc
 >'0' && 
c
 <= '9')

433 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

435 i(
	gc
 == '.') {

436 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

437 
	gc
 >'0' && 
c
 <= '9')

438 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

441 i(
	gc
 ='e' || 
c
 == 'E') {

442 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

443 i(
	gc
 ='+' || 
c
 == '-')

444 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

445 
	gc
 >'0' && 
c
 <= '9')

446 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

450 
bo
 
	gRd
::
adSg
() {

451 
Ch
 
c
 = 0;

452 
	gcut_
 !
d_
) {

453 
c
 = 
gNextCh
();

454 i(
	gc
 == '\\')

455 
gNextCh
();

456 i(
	gc
 == '"')

459  
	gc
 == '"';

462 
bo
 
	gRd
::
adObje
(
Tok
& 
tokS
) {

463 
Tok
 
tokName
;

464 
JSONCPP_STRING
 
	gme
;

465 
Vue
 

(
objeVue
);

466 
cutVue
().
swPayld
(

);

467 
cutVue
().
tOfftS
(
tokS
.
t_
 - 
beg_
);

468 
adTok
(
tokName
)) {

469 
bo
 
	glTokOk
 = 
ue
;

470 
	gtokName
.
	gty_
 =
tokCommt
 && 
lTokOk
)

471 
lTokOk
 = 
adTok
(
tokName
);

472 i(!
	glTokOk
)

474 i(
	gtokName
.
	gty_
 =
tokObjeEnd
 && 
me
.
emy
())

475  
ue
;

476 
	gme
 = "";

477 i(
	gtokName
.
	gty_
 =
tokSg
) {

478 i(!
decodeSg
(
tokName
, 
me
))

479  
covFromE
(
tokObjeEnd
);

480 } i(
	gtokName
.
	gty_
 =
tokNumb
 && 
us_
.
lowNumicKeys_
) {

481 
Vue
 
numbName
;

482 i(!
decodeNumb
(
tokName
, 
numbName
))

483  
covFromE
(
tokObjeEnd
);

484 
	gme
 = 
JSONCPP_STRING
(
numbName
.
asCSg
());

489 
Tok
 
	gc
;

490 i(!
adTok
(
c
|| 
	gc
.
	gty_
 !
tokMembS
) {

491  
addEAndRecov
(

492 "Missg ':' obje membame", 
c
, 
tokObjeEnd
);

494 
	gVue
& 
	gvue
 = 
cutVue
()[
me
];

495 
	gnodes_
.
push
(&
vue
);

496 
bo
 
	gok
 = 
adVue
();

497 
	gnodes_
.
p
();

498 i(!
	gok
)

499  
covFromE
(
tokObjeEnd
);

501 
Tok
 
	gcomma
;

502 i(!
adTok
(
comma
) ||

503 (
	gcomma
.
	gty_
 !
tokObjeEnd
 && 
comma
.
ty_
 !
tokAayS
 &&

504 
comma
.
ty_
 !
tokCommt
)) {

505  
addEAndRecov
(

506 "Missg ',' o'}' iobje dei", 
comma
, 
tokObjeEnd
);

508 
bo
 
	gfizeTokOk
 = 
ue
;

509 
	gcomma
.
	gty_
 =
tokCommt
 && 
fizeTokOk
)

510 
fizeTokOk
 = 
adTok
(
comma
);

511 i(
	gcomma
.
	gty_
 =
tokObjeEnd
)

512  
ue
;

514  
addEAndRecov
(

515 "Missg '}' oobje membame", 
tokName
, 
tokObjeEnd
);

518 
bo
 
	gRd
::
adAay
(
Tok
& 
tokS
) {

519 
Vue
 

(
yVue
);

520 
cutVue
().
swPayld
(

);

521 
cutVue
().
tOfftS
(
tokS
.
t_
 - 
beg_
);

522 
skSs
();

523 i(*
	gcut_
 == ']')

525 
Tok
 
dAay
;

526 
adTok
(
dAay
);

527  
	gue
;

529 
	gdex
 = 0;

531 
	gVue
& 
	gvue
 = 
cutVue
()[
dex
++];

532 
	gnodes_
.
push
(&
vue
);

533 
bo
 
	gok
 = 
adVue
();

534 
	gnodes_
.
p
();

535 i(!
	gok
)

536  
covFromE
(
tokAayEnd
);

538 
Tok
 
	gtok
;

540 
	gok
 = 
adTok
(
tok
);

541 
	gtok
.
	gty_
 =
tokCommt
 && 
ok
) {

542 
ok
 = 
adTok
(
tok
);

544 
bo
 
	gbadTokTy
 =

545 (
tok
.
ty_
 !
tokAayS
 &&ok.ty_ !
tokAayEnd
);

546 i(!
	gok
 || 
	gbadTokTy
) {

547  
addEAndRecov
(

548 "Missg ',' o']' iy dei", 
tok
, 
tokAayEnd
);

550 i(
	gtok
.
	gty_
 =
tokAayEnd
)

553  
	gue
;

556 
bo
 
	gRd
::
decodeNumb
(
Tok
& 
tok
) {

557 
Vue
 
decoded
;

558 i(!
decodeNumb
(
tok
, 
decoded
))

559  
	gl
;

560 
cutVue
().
swPayld
(
decoded
);

561 
cutVue
().
tOfftS
(
tok
.
t_
 - 
beg_
);

562 
cutVue
().
tOfftLim
(
tok
.
d_
 - 
beg_
);

563  
	gue
;

566 
bo
 
	gRd
::
decodeNumb
(
Tok
& 
tok
, 
Vue
& 
decoded
) {

570 
Loti
 
	gcut
 = 
tok
.
t_
;

571 
bo
 
	gisNegive
 = *
cut
 == '-';

572 i(
	gisNegive
)

573 ++
	gcut
;

575 
	gVue
::
LgeUI
 
maxIegVue
 =

576 
isNegive
 ? 
Vue
::
LgeUI
(Vue::
maxLgeI
) + 1

577 : 
Vue
::
maxLgeUI
;

578 
	gVue
::
LgeUI
 
thshd
 = 
maxIegVue
 / 10;

579 
	gVue
::
LgeUI
 
vue
 = 0;

580 
	gcut
 < 
	gtok
.
	gd_
) {

581 
Ch
 
	gc
 = *
cut
++;

582 i(
	gc
 < '0' || c > '9')

583  
decodeDoub
(
tok
, 
decoded
);

584 
	gVue
::
UI
 
dig
(
ic_
<
Vue
::UI>(
c
 - '0'));

585 i(
	gvue
 >
thshd
) {

590 i(
vue
 > 
thshd
 || 
cut
 !
tok
.
d_
 ||

591 
dig
 > 
maxIegVue
 % 10) {

592  
decodeDoub
(
tok
, 
decoded
);

595 
	gvue
 = 
vue
 * 10 + 
dig
;

597 i(
	gisNegive
 && 
	gvue
 =
maxIegVue
)

598 
decoded
 = 
Vue
::
mLgeI
;

599 i(
	gisNegive
)

600 
	gdecoded
 = -
Vue
::
LgeI
(
vue
);

601 i(
	gvue
 <
Vue
::
LgeUI
(Vue::
maxI
))

602 
decoded
 = 
Vue
::
LgeI
(
vue
);

604 
	gdecoded
 = 
vue
;

605  
	gue
;

608 
bo
 
	gRd
::
decodeDoub
(
Tok
& 
tok
) {

609 
Vue
 
decoded
;

610 i(!
decodeDoub
(
tok
, 
decoded
))

611  
	gl
;

612 
cutVue
().
swPayld
(
decoded
);

613 
cutVue
().
tOfftS
(
tok
.
t_
 - 
beg_
);

614 
cutVue
().
tOfftLim
(
tok
.
d_
 - 
beg_
);

615  
	gue
;

618 
bo
 
	gRd
::
decodeDoub
(
Tok
& 
tok
, 
Vue
& 
decoded
) {

619 
	gvue
 = 0;

620 
JSONCPP_STRING
 
bufr
(
tok
.
t_
,ok.
d_
);

621 
JSONCPP_ISTRINGSTREAM
 
is
(
bufr
);

622 i(!(
	gis
 >> 
	gvue
))

623  
addE
("'" + 
JSONCPP_STRING
(
tok
.
t_
,ok.
d_
) +

625 
tok
);

626 
	gdecoded
 = 
vue
;

627  
	gue
;

630 
bo
 
	gRd
::
decodeSg
(
Tok
& 
tok
) {

631 
JSONCPP_STRING
 
decoded_rg
;

632 i(!
decodeSg
(
tok
, 
decoded_rg
))

633  
	gl
;

634 
Vue
 
decoded
(
decoded_rg
);

635 
cutVue
().
swPayld
(
decoded
);

636 
cutVue
().
tOfftS
(
tok
.
t_
 - 
beg_
);

637 
cutVue
().
tOfftLim
(
tok
.
d_
 - 
beg_
);

638  
	gue
;

641 
bo
 
	gRd
::
decodeSg
(
Tok
& 
tok
, 
JSONCPP_STRING
& 
decoded
) {

642 
	gdecoded
.
rve
(
ic_
<
size_t
>(
tok
.
d_
 -ok.
t_
 - 2));

643 
Loti
 
	gcut
 = 
tok
.
t_
 + 1;

644 
Loti
 
	gd
 = 
tok
.
d_
 - 1;

645 
	gcut
 !
d
) {

646 
Ch
 
c
 = *
cut
++;

647 i(
	gc
 == '"')

649 i(
	gc
 == '\\') {

650 i(
cut
 =
d
)

651  
addE
("Emys sequ irg", 
tok
, 
cut
);

652 
Ch
 
	ges
 = *
cut
++;

653 
	ges
) {

655 
decoded
 += '"';

658 
decoded
 += '/';

661 
decoded
 += '\\';

664 
decoded
 += '\b';

667 
decoded
 += '\f';

670 
decoded
 += '\n';

673 
decoded
 += '\r';

676 
decoded
 += '\t';

679 
unicode
;

680 i(!
decodeUnicodeCodePot
(
tok
, 
cut
, 
d
, 
unicode
))

681  
	gl
;

682 
	gdecoded
 +
codePotToUTF8
(
unicode
);

685  
addE
("Bads sequ irg", 
tok
, 
cut
);

688 
	gdecoded
 +
c
;

691  
	gue
;

694 
bo
 
	gRd
::
decodeUnicodeCodePot
(
Tok
& 
tok
,

695 
Loti
& 
cut
,

696 
Loti
 
d
,

697 & 
unicode
) {

699 i(!
decodeUnicodeEsSequ
(
tok
, 
cut
, 
d
, 
unicode
))

700  
	gl
;

701 i(
	gunicode
 >0xD800 && 
unicode
 <= 0xDBFF) {

703 i(
d
 - 
cut
 < 6)

704  
addE
(

706 
tok
,

707 
cut
);

708 
	gsuogePa
;

709 i(*(
	gcut
++='\\' && *(
cut
++) == 'u') {

710 i(
decodeUnicodeEsSequ
(
tok
, 
cut
, 
d
, 
suogePa
)) {

711 
unicode
 = 0x10000 + ((unicod& 0x3FF<< 10+ (
suogePa
 & 0x3FF);

713  
	gl
;

715  
addE
("expectingnother \\uokeno beginhe second half of "

717 
tok
,

718 
cut
);

720  
	gue
;

723 
bo
 
	gRd
::
decodeUnicodeEsSequ
(
Tok
& 
tok
,

724 
Loti
& 
cut
,

725 
Loti
 
d
,

726 & 
t_unicode
) {

727 i(
	gd
 - 
	gcut
 < 4)

728  
addE
(

730 
tok
,

731 
cut
);

732 
	gunicode
 = 0;

733 
	gdex
 = 0; index < 4; ++index) {

734 
Ch
 
	gc
 = *
cut
++;

735 
	gunicode
 *= 16;

736 i(
	gc
 >'0' && 
c
 <= '9')

737 
unicode
 +
c
 - '0';

738 i(
	gc
 >'a' && 
c
 <= 'f')

739 
unicode
 +
c
 - 'a' + 10;

740 i(
	gc
 >'A' && 
c
 <= 'F')

741 
unicode
 +
c
 - 'A' + 10;

743  
addE
(

745 
tok
,

746 
cut
);

748 
	gt_unicode
 = 
ic_
<>(
unicode
);

749  
	gue
;

752 
bo


753 
	gRd
::
addE
(cڡ 
JSONCPP_STRING
& 
mesge
, 
Tok
& 
tok
, 
Loti
 
exa
) {

754 
EInfo
 
	gfo
;

755 
	gfo
.
	gtok_
 = 
tok
;

756 
	gfo
.
	gmesge_
 = 
mesge
;

757 
	gfo
.
	gexa_
 = 
exa
;

758 
	grs_
.
push_back
(
fo
);

759  
	gl
;

762 
bo
 
	gRd
::
covFromE
(
TokTy
 
skUTok
) {

763 
size_t
 cڡ 
rCou
 = 
rs_
.
size
();

764 
Tok
 
	gsk
;

766 i(!
adTok
(
sk
))

767 
	grs_
.
size
(
rCou
);

768 i(
	gsk
.
	gty_
 =
skUTok
 || 
sk
.
ty_
 =
tokEndOfSm
)

771 
	grs_
.
size
(
rCou
);

772  
	gl
;

775 
bo
 
	gRd
::
addEAndRecov
(cڡ 
JSONCPP_STRING
& 
mesge
,

776 
Tok
& 
tok
,

777 
TokTy
 
skUTok
) {

778 
addE
(
mesge
, 
tok
);

779  
covFromE
(
skUTok
);

782 
	gVue
& 
	gRd
::
cutVue
({  *(
nodes_
.
t
()); }

784 
	gRd
::
Ch
 
Rd
::
gNextCh
() {

785 i(
cut_
 =
d_
)

787  *
	gcut_
++;

790 
	gRd
::
gLotiLeAndCumn
(
Loti
 
loti
,

791 & 
le
,

792 & 
cumn
) const {

793 
Loti
 
	gcut
 = 
beg_
;

794 
Loti
 
	gϡLeS
 = 
cut
;

795 
	gle
 = 0;

796 
	gcut
 < 
	gloti
 && cu!
d_
) {

797 
Ch
 
c
 = *
cut
++;

798 i(
	gc
 == '\r') {

799 i(*
cut
 == '\n')

800 ++
cut
;

801 
	gϡLeS
 = 
cut
;

802 ++
	gle
;

803 } i(
	gc
 == '\n') {

804 
ϡLeS
 = 
cut
;

805 ++
	gle
;

809 
	gcumn
 = (
loti
 - 
ϡLeS
) + 1;

810 ++
	gle
;

813 
JSONCPP_STRING
 
	gRd
::
gLotiLeAndCumn
(
Loti
 
loti
) const {

814 
le
, 
	gcumn
;

815 
gLotiLeAndCumn
(
loti
, 
le
, 
cumn
);

816 
	gbufr
[18 + 16 + 16 + 1];

817 
tf
(
bufr
, (bufr), "L%d, Cum%d", 
le
, 
cumn
);

818  
	gbufr
;

822 
JSONCPP_STRING
 
	gRd
::
gFmedEMesges
() const {

823  
gFmdEMesges
();

826 
JSONCPP_STRING
 
	gRd
::
gFmdEMesges
() const {

827 
JSONCPP_STRING
 
fmdMesge
;

828 
	gEs
::
cڡ_
 
E
 = 
rs_
.
beg
();

829 
	gE
 !
rs_
.
d
();

830 ++
	gE
) {

831 cڡ 
	gEInfo
& 
	gr
 = *
E
;

832 
	gfmdMesge
 +=

833 "* " + 
gLotiLeAndCumn
(
r
.
tok_
.
t_
) + "\n";

834 
	gfmdMesge
 +" " + 
r
.
mesge_
 + "\n";

835 i(
	gr
.
	gexa_
)

836 
	gfmdMesge
 +=

837 "S " + 
gLotiLeAndCumn
(
r
.
exa_
) + " for detail.\n";

839  
	gfmdMesge
;

842 
	gd
::
ve
<
Rd
::
SuudE
> Rd::
gSuudEs
() const {

843 
d
::
ve
<
Rd
::
SuudE
> 
lEs
;

844 
	gEs
::
cڡ_
 
E
 = 
rs_
.
beg
();

845 
	gE
 !
rs_
.
d
();

846 ++
	gE
) {

847 cڡ 
	gEInfo
& 
	gr
 = *
E
;

848 
	gRd
::
SuudE
 
ruud
;

849 
	gruud
.
	gofft_t
 = 
r
.
tok_
.
t_
 - 
beg_
;

850 
	gruud
.
	gofft_lim
 = 
r
.
tok_
.
d_
 - 
beg_
;

851 
	gruud
.
	gmesge
 = 
r
.
mesge_
;

852 
	glEs
.
push_back
(
ruud
);

854  
	glEs
;

857 
bo
 
	gRd
::
pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
) {

858 
rdiff_t
 cڡ 
	gngth
 = 
d_
 - 
beg_
;

859 if(
	gvue
.
gOfftS
(> 
	gngth


860 || 
	gvue
.
gOfftLim
(> 
	gngth
)

861  
	gl
;

862 
Tok
 
	gtok
;

863 
	gtok
.
	gty_
 = 
tokE
;

864 
	gtok
.
	gt_
 = 
beg_
 + 
vue
.
gOfftS
();

865 
	gtok
.
	gd_
 = 
d_
 + 
vue
.
gOfftLim
();

866 
EInfo
 
	gfo
;

867 
	gfo
.
	gtok_
 = 
tok
;

868 
	gfo
.
	gmesge_
 = 
mesge
;

869 
	gfo
.
	gexa_
 = 0;

870 
	grs_
.
push_back
(
fo
);

871  
	gue
;

874 
bo
 
	gRd
::
pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
, cڡ Vue& 
exa
) {

875 
rdiff_t
 cڡ 
	gngth
 = 
d_
 - 
beg_
;

876 if(
	gvue
.
gOfftS
(> 
	gngth


877 || 
	gvue
.
gOfftLim
(> 
	gngth


878 || 
	gexa
.
gOfftLim
(> 
	gngth
)

879  
	gl
;

880 
Tok
 
	gtok
;

881 
	gtok
.
	gty_
 = 
tokE
;

882 
	gtok
.
	gt_
 = 
beg_
 + 
vue
.
gOfftS
();

883 
	gtok
.
	gd_
 = 
beg_
 + 
vue
.
gOfftLim
();

884 
EInfo
 
	gfo
;

885 
	gfo
.
	gtok_
 = 
tok
;

886 
	gfo
.
	gmesge_
 = 
mesge
;

887 
	gfo
.
	gexa_
 = 
beg_
 + 
exa
.
gOfftS
();

888 
	grs_
.
push_back
(
fo
);

889  
	gue
;

892 
bo
 
	gRd
::
good
() const {

893  !
rs_
.
size
();

897 as
	cOurFtus
 {

898 
	gpublic
:

899 
OurFtus
 
l
();

900 
bo
 
	glowCommts_
;

901 
bo
 
	griRo_
;

902 
bo
 
	glowDrݳdNuPhds_
;

903 
bo
 
	glowNumicKeys_
;

904 
bo
 
	glowSgQues_
;

905 
bo
 
	gIfExa_
;

906 
bo
 
	gjeDupKeys_
;

907 
bo
 
	glowSclFlts_
;

908 
	gackLim_
;

914 
OurFtus
 
	gOurFtus
::
	$l
({  
	`OurFtus
(); 
	}
}

920 as
	cOurRd
 {

921 
	gpublic
:

922 
	tCh
;

923 cڡ 
	tCh
* 
	tLoti
;

924 
	sSuudE
 {

925 
rdiff_t
 
	gofft_t
;

926 
rdiff_t
 
	gofft_lim
;

927 
JSONCPP_STRING
 
	gmesge
;

930 
OurRd
(
OurFtus
 cڡ& 
us
);

931 
bo
 
r
(cڡ * 
begDoc
,

932 cڡ * 
dDoc
,

933 
Vue
& 
ro
,

934 
bo
 
cCommts
 = 
ue
);

935 
JSONCPP_STRING
 
gFmdEMesges
() const;

936 
	gd
::
ve
<
SuudE
> 
gSuudEs
() const;

937 
bo
 
pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
);

938 
bo
 
pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
, cڡ Vue& 
exa
);

939 
bo
 
good
() const;

941 
	give
:

942 
OurRd
(OurReader const&);

943 
	gݔ
=(
OurRd
 const&);

945 
	eTokTy
 {

946 
	gtokEndOfSm
 = 0,

947 
	gtokObjeBeg
,

948 
	gtokObjeEnd
,

949 
	gtokAayBeg
,

950 
	gtokAayEnd
,

951 
	gtokSg
,

952 
	gtokNumb
,

953 
	gtokTrue
,

954 
	gtokF
,

955 
	gtokNu
,

956 
	gtokNaN
,

957 
	gtokPosInf
,

958 
	gtokNegInf
,

959 
	gtokAayS
,

960 
	gtokMembS
,

961 
	gtokCommt
,

962 
	gtokE


965 as
	cTok
 {

966 
	gpublic
:

967 
TokTy
 
ty_
;

968 
Loti
 
	gt_
;

969 
Loti
 
	gd_
;

972 as
	cEInfo
 {

973 
	gpublic
:

974 
Tok
 
tok_
;

975 
JSONCPP_STRING
 
	gmesge_
;

976 
Loti
 
	gexa_
;

979 
	gd
::
	tdeque
<
	tEInfo
> 
	tEs
;

981 
bo
 
adTok
(
Tok
& 
tok
);

982 
skSs
();

983 
bo
 
mch
(
Loti
 
n
, 
nLgth
);

984 
bo
 
adCommt
();

985 
bo
 
adCStyCommt
();

986 
bo
 
adCStyCommt
();

987 
bo
 
adSg
();

988 
bo
 
adSgSgQue
();

989 
bo
 
adNumb
(bo 
checkInf
);

990 
bo
 
adVue
();

991 
bo
 
adObje
(
Tok
& 
tok
);

992 
bo
 
adAay
(
Tok
& 
tok
);

993 
bo
 
decodeNumb
(
Tok
& 
tok
);

994 
bo
 
decodeNumb
(
Tok
& 
tok
, 
Vue
& 
decoded
);

995 
bo
 
decodeSg
(
Tok
& 
tok
);

996 
bo
 
decodeSg
(
Tok
& 
tok
, 
JSONCPP_STRING
& 
decoded
);

997 
bo
 
decodeDoub
(
Tok
& 
tok
);

998 
bo
 
decodeDoub
(
Tok
& 
tok
, 
Vue
& 
decoded
);

999 
bo
 
decodeUnicodeCodePot
(
Tok
& 
tok
,

1000 
Loti
& 
cut
,

1001 
Loti
 
d
,

1002 & 
unicode
);

1003 
bo
 
decodeUnicodeEsSequ
(
Tok
& 
tok
,

1004 
Loti
& 
cut
,

1005 
Loti
 
d
,

1006 & 
unicode
);

1007 
bo
 
addE
(cڡ 
JSONCPP_STRING
& 
mesge
, 
Tok
& 
tok
, 
Loti
 
exa
 = 0);

1008 
bo
 
covFromE
(
TokTy
 
skUTok
);

1009 
bo
 
addEAndRecov
(cڡ 
JSONCPP_STRING
& 
mesge
,

1010 
Tok
& 
tok
,

1011 
TokTy
 
skUTok
);

1012 
skUS
();

1013 
	gVue
& 
cutVue
();

1014 
Ch
 
gNextCh
();

1016 
gLotiLeAndCumn
(
Loti
 
loti
, & 
le
, & 
cumn
) const;

1017 
JSONCPP_STRING
 
gLotiLeAndCumn
(
Loti
 
loti
) const;

1018 
addCommt
(
Loti
 
beg
, Loti 
d
, 
CommtPmt
 
amt
);

1019 
skCommtToks
(
Tok
& 
tok
);

1021 
	gd
::
	tack
<
	tVue
*> 
	tNodes
;

1022 
Nodes
 
	gnodes_
;

1023 
Es
 
	grs_
;

1024 
JSONCPP_STRING
 
	gdocumt_
;

1025 
Loti
 
	gbeg_
;

1026 
Loti
 
	gd_
;

1027 
Loti
 
	gcut_
;

1028 
Loti
 
	gϡVueEnd_
;

1029 
Vue
* 
	gϡVue_
;

1030 
JSONCPP_STRING
 
	gcommtsBefe_
;

1031 
	gackDth_
;

1033 
OurFtus
 cڡ 
	gus_
;

1034 
bo
 
	gcCommts_
;

1039 
	gOurRd
::
	$OurRd
(
OurFtus
 cڡ& 
us
)

1040 : 
	`rs_
(), 
	`documt_
(), 
	`beg_
(), 
	`d_
(), 
	`cut_
(), 
	`ϡVueEnd_
(),

1041 
	`ϡVue_
(), 
	`commtsBefe_
(),

1042 
	`ackDth_
(0),

1043 
	`us_
(
us
), 
	$cCommts_
() {

1044 
	}
}

1046 
bo
 
	gOurRd
::
	$r
(cڡ * 
begDoc
,

1047 cڡ * 
dDoc
,

1048 
Vue
& 
ro
,

1049 
bo
 
cCommts
) {

1050 i(!
us_
.
lowCommts_
) {

1051 
cCommts
 = 
l
;

1054 
beg_
 = 
begDoc
;

1055 
d_
 = 
dDoc
;

1056 
cCommts_
 = 
cCommts
;

1057 
cut_
 = 
beg_
;

1058 
ϡVueEnd_
 = 0;

1059 
ϡVue_
 = 0;

1060 
commtsBefe_
 = "";

1061 
rs_
.
	`r
();

1062 !
nodes_
.
	`emy
())

1063 
nodes_
.
	`p
();

1064 
nodes_
.
	`push
(&
ro
);

1066 
ackDth_
 = 0;

1067 
bo
 
sucssful
 = 
	`adVue
();

1068 
Tok
 
tok
;

1069 
	`skCommtToks
(
tok
);

1070 i(
us_
.
IfExa_
) {

1071 i(
tok
.
ty_
 !
tokE
 &&ok.ty_ !
tokEndOfSm
) {

1072 
	`addE
("Exn-whea JSON vue.", 
tok
);

1073  
l
;

1076 i(
cCommts_
 && !
commtsBefe_
.
	`emy
())

1077 
ro
.
	`tCommt
(
commtsBefe_
, 
commtA
);

1078 i(
us_
.
riRo_
) {

1079 i(!
ro
.
	`isAay
(&& !ro.
	`isObje
()) {

1082 
tok
.
ty_
 = 
tokE
;

1083 
tok
.
t_
 = 
begDoc
;

1084 
tok
.
d_
 = 
dDoc
;

1085 
	`addE
(

1087 
tok
);

1088  
l
;

1091  
sucssful
;

1092 
	}
}

1094 
bo
 
	gOurRd
::
	$adVue
() {

1095 i(
ackDth_
 >
us_
.
ackLim_

	`throwRuimeE
("Exceeded stackLimit ineadValue().");

1096 ++
ackDth_
;

1097 
Tok
 
tok
;

1098 
	`skCommtToks
(
tok
);

1099 
bo
 
sucssful
 = 
ue
;

1101 i(
cCommts_
 && !
commtsBefe_
.
	`emy
()) {

1102 
	`cutVue
().
	`tCommt
(
commtsBefe_
, 
commtBefe
);

1103 
commtsBefe_
 = "";

1106 
tok
.
ty_
) {

1107 
tokObjeBeg
:

1108 
sucssful
 = 
	`adObje
(
tok
);

1109 
	`cutVue
().
	`tOfftLim
(
cut_
 - 
beg_
);

1111 
tokAayBeg
:

1112 
sucssful
 = 
	`adAay
(
tok
);

1113 
	`cutVue
().
	`tOfftLim
(
cut_
 - 
beg_
);

1115 
tokNumb
:

1116 
sucssful
 = 
	`decodeNumb
(
tok
);

1118 
tokSg
:

1119 
sucssful
 = 
	`decodeSg
(
tok
);

1121 
tokTrue
:

1123 
Vue
 
	`v
(
ue
);

1124 
	`cutVue
().
	`swPayld
(
v
);

1125 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1126 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1129 
tokF
:

1131 
Vue
 
	`v
(
l
);

1132 
	`cutVue
().
	`swPayld
(
v
);

1133 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1134 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1137 
tokNu
:

1139 
Vue
 
v
;

1140 
	`cutVue
().
	`swPayld
(
v
);

1141 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1142 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1145 
tokNaN
:

1147 
Vue
 
	`v
(
d
::
numic_lims
<>::
	`qut_NaN
());

1148 
	`cutVue
().
	`swPayld
(
v
);

1149 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1150 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1153 
tokPosInf
:

1155 
Vue
 
	`v
(
d
::
numic_lims
<>::
	`fy
());

1156 
	`cutVue
().
	`swPayld
(
v
);

1157 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1158 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1161 
tokNegInf
:

1163 
Vue
 
	`v
(-
d
::
numic_lims
<>::
	`fy
());

1164 
	`cutVue
().
	`swPayld
(
v
);

1165 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1166 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1169 
tokAayS
:

1170 
tokObjeEnd
:

1171 
tokAayEnd
:

1172 i(
us_
.
lowDrݳdNuPhds_
) {

1175 
cut_
--;

1176 
Vue
 
v
;

1177 
	`cutVue
().
	`swPayld
(
v
);

1178 
	`cutVue
().
	`tOfftS
(
cut_
 - 
beg_
 - 1);

1179 
	`cutVue
().
	`tOfftLim
(
cut_
 - 
beg_
);

1183 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1184 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1185  
	`addE
("Syax: vue, obje oyxed.", 
tok
);

1188 i(
cCommts_
) {

1189 
ϡVueEnd_
 = 
cut_
;

1190 
ϡVue_
 = &
	`cutVue
();

1193 --
ackDth_
;

1194  
sucssful
;

1195 
	}
}

1197 
	gOurRd
::
	$skCommtToks
(
Tok
& 
tok
) {

1198 i(
us_
.
lowCommts_
) {

1200 
	`adTok
(
tok
);

1201 } 
tok
.
ty_
 =
tokCommt
);

1203 
	`adTok
(
tok
);

1205 
	}
}

1207 
bo
 
	gOurRd
::
	$adTok
(
Tok
& 
tok
) {

1208 
	`skSs
();

1209 
tok
.
t_
 = 
cut_
;

1210 
Ch
 
c
 = 
	`gNextCh
();

1211 
bo
 
ok
 = 
ue
;

1212 
c
) {

1214 
tok
.
ty_
 = 
tokObjeBeg
;

1217 
tok
.
ty_
 = 
tokObjeEnd
;

1220 
tok
.
ty_
 = 
tokAayBeg
;

1223 
tok
.
ty_
 = 
tokAayEnd
;

1226 
tok
.
ty_
 = 
tokSg
;

1227 
ok
 = 
	`adSg
();

1230 i(
us_
.
lowSgQues_
) {

1231 
tok
.
ty_
 = 
tokSg
;

1232 
ok
 = 
	`adSgSgQue
();

1236 
tok
.
ty_
 = 
tokCommt
;

1237 
ok
 = 
	`adCommt
();

1249 
tok
.
ty_
 = 
tokNumb
;

1250 
	`adNumb
(
l
);

1253 i(
	`adNumb
(
ue
)) {

1254 
tok
.
ty_
 = 
tokNumb
;

1256 
tok
.
ty_
 = 
tokNegInf
;

1257 
ok
 = 
us_
.
lowSclFlts_
 && 
	`mch
("nfinity", 7);

1261 
tok
.
ty_
 = 
tokTrue
;

1262 
ok
 = 
	`mch
("rue", 3);

1265 
tok
.
ty_
 = 
tokF
;

1266 
ok
 = 
	`mch
("alse", 4);

1269 
tok
.
ty_
 = 
tokNu
;

1270 
ok
 = 
	`mch
("ull", 3);

1273 i(
us_
.
lowSclFlts_
) {

1274 
tok
.
ty_
 = 
tokNaN
;

1275 
ok
 = 
	`mch
("aN", 2);

1277 
ok
 = 
l
;

1281 i(
us_
.
lowSclFlts_
) {

1282 
tok
.
ty_
 = 
tokPosInf
;

1283 
ok
 = 
	`mch
("nfinity", 7);

1285 
ok
 = 
l
;

1289 
tok
.
ty_
 = 
tokAayS
;

1292 
tok
.
ty_
 = 
tokMembS
;

1295 
tok
.
ty_
 = 
tokEndOfSm
;

1298 
ok
 = 
l
;

1301 i(!
ok
)

1302 
tok
.
ty_
 = 
tokE
;

1303 
tok
.
d_
 = 
cut_
;

1304  
ue
;

1305 
	}
}

1307 
	gOurRd
::
	$skSs
() {

1308 
cut_
 !
d_
) {

1309 
Ch
 
c
 = *
cut_
;

1310 i(
c
 == ' ' || c == '\t' || c == '\r' || c == '\n')

1311 ++
cut_
;

1315 
	}
}

1317 
bo
 
	gOurRd
::
	$mch
(
Loti
 
n
, 
nLgth
) {

1318 i(
d_
 - 
cut_
 < 
nLgth
)

1319  
l
;

1320 
dex
 = 
nLgth
;

1321 
dex
--)

1322 i(
cut_
[
dex
] !
n
[index])

1323  
l
;

1324 
cut_
 +
nLgth
;

1325  
ue
;

1326 
	}
}

1328 
bo
 
	gOurRd
::
	$adCommt
() {

1329 
Loti
 
commtBeg
 = 
cut_
 - 1;

1330 
Ch
 
c
 = 
	`gNextCh
();

1331 
bo
 
sucssful
 = 
l
;

1332 i(
c
 == '*')

1333 
sucssful
 = 
	`adCStyCommt
();

1334 i(
c
 == '/')

1335 
sucssful
 = 
	`adCStyCommt
();

1336 i(!
sucssful
)

1337  
l
;

1339 i(
cCommts_
) {

1340 
CommtPmt
 
amt
 = 
commtBefe
;

1341 i(
ϡVueEnd_
 && !
	`cڏsNewLe
aVueEnd_, 
commtBeg
)) {

1342 i(
c
 !'*' || !
	`cڏsNewLe
(
commtBeg
, 
cut_
))

1343 
amt
 = 
commtAOnSameLe
;

1346 
	`addCommt
(
commtBeg
, 
cut_
, 
amt
);

1348  
ue
;

1349 
	}
}

1352 
	gOurRd
::
	$addCommt
(
Loti
 
beg
, Loti 
d
, 
CommtPmt
 
amt
) {

1353 
	`as
(
cCommts_
);

1354 cڡ 
JSONCPP_STRING
& 
nmized
 = 
	`nmizeEOL
(
beg
, 
d
);

1355 i(
amt
 =
commtAOnSameLe
) {

1356 
	`as
(
ϡVue_
 != 0);

1357 
ϡVue_
->
	`tCommt
(
nmized
, 
amt
);

1359 
commtsBefe_
 +
nmized
;

1361 
	}
}

1363 
bo
 
	gOurRd
::
	$adCStyCommt
() {

1364 
cut_
 !
d_
) {

1365 
Ch
 
c
 = 
	`gNextCh
();

1366 i(
c
 ='*' && *
cut_
 == '/')

1369  
	`gNextCh
() == '/';

1370 
	}
}

1372 
bo
 
	gOurRd
::
	$adCStyCommt
() {

1373 
cut_
 !
d_
) {

1374 
Ch
 
c
 = 
	`gNextCh
();

1375 i(
c
 == '\n')

1377 i(
c
 == '\r') {

1379 i(
cut_
 !
d_
 && *current_ == '\n')

1380 
	`gNextCh
();

1385  
ue
;

1386 
	}
}

1388 
bo
 
	gOurRd
::
	$adNumb
(
bo
 
checkInf
) {

1389 cڡ *
p
 = 
cut_
;

1390 i(
checkInf
 && 
p
 !
d_
 && *p == 'I') {

1391 
cut_
 = ++
p
;

1392  
l
;

1394 
c
 = '0';

1396 
c
 >= '0' && c <= '9')

1397 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

1399 i(
c
 == '.') {

1400 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

1401 
c
 >= '0' && c <= '9')

1402 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

1405 i(
c
 == 'e' || c == 'E') {

1406 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

1407 i(
c
 == '+' || c == '-')

1408 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

1409 
c
 >= '0' && c <= '9')

1410 
c
 = (
cut_
 = 
p
< 
d_
 ? *p++ : 0;

1412  
ue
;

1413 
	}
}

1414 
bo
 
	gOurRd
::
	$adSg
() {

1415 
Ch
 
c
 = 0;

1416 
cut_
 !
d_
) {

1417 
c
 = 
	`gNextCh
();

1418 i(
c
 == '\\')

1419 
	`gNextCh
();

1420 i(
c
 == '"')

1423  
c
 == '"';

1424 
	}
}

1427 
bo
 
	gOurRd
::
	$adSgSgQue
() {

1428 
Ch
 
c
 = 0;

1429 
cut_
 !
d_
) {

1430 
c
 = 
	`gNextCh
();

1431 i(
c
 == '\\')

1432 
	`gNextCh
();

1433 i(
c
 == '\'')

1436  
c
 == '\'';

1437 
	}
}

1439 
bo
 
	gOurRd
::
	$adObje
(
Tok
& 
tokS
) {

1440 
Tok
 
tokName
;

1441 
JSONCPP_STRING
 
me
;

1442 
Vue
 
	`
(
objeVue
);

1443 
	`cutVue
().
	`swPayld
(

);

1444 
	`cutVue
().
	`tOfftS
(
tokS
.
t_
 - 
beg_
);

1445 
	`adTok
(
tokName
)) {

1446 
bo
 
lTokOk
 = 
ue
;

1447 
tokName
.
ty_
 =
tokCommt
 && 
lTokOk
)

1448 
lTokOk
 = 
	`adTok
(
tokName
);

1449 i(!
lTokOk
)

1451 i(
tokName
.
ty_
 =
tokObjeEnd
 && 
me
.
	`emy
())

1452  
ue
;

1453 
me
 = "";

1454 i(
tokName
.
ty_
 =
tokSg
) {

1455 i(!
	`decodeSg
(
tokName
, 
me
))

1456  
	`covFromE
(
tokObjeEnd
);

1457 } i(
tokName
.
ty_
 =
tokNumb
 && 
us_
.
lowNumicKeys_
) {

1458 
Vue
 
numbName
;

1459 i(!
	`decodeNumb
(
tokName
, 
numbName
))

1460  
	`covFromE
(
tokObjeEnd
);

1461 
me
 = 
numbName
.
	`asSg
();

1466 
Tok
 
c
;

1467 i(!
	`adTok
(
c
|| c.
ty_
 !
tokMembS
) {

1468  
	`addEAndRecov
(

1469 "Missg ':' obje membame", 
c
, 
tokObjeEnd
);

1471 i(
me
.
	`ngth
(>(1U<<30)
	`throwRuimeE
("keylength >= 2^30");

1472 i(
us_
.
jeDupKeys_
 && 
	`cutVue
().
	`isMemb
(
me
)) {

1473 
JSONCPP_STRING
 
msg
 = "Dui key: '" + 
me
 + "'";

1474  
	`addEAndRecov
(

1475 
msg
, 
tokName
, 
tokObjeEnd
);

1477 
Vue
& 
vue
 = 
	`cutVue
()[
me
];

1478 
nodes_
.
	`push
(&
vue
);

1479 
bo
 
ok
 = 
	`adVue
();

1480 
nodes_
.
	`p
();

1481 i(!
ok
)

1482  
	`covFromE
(
tokObjeEnd
);

1484 
Tok
 
comma
;

1485 i(!
	`adTok
(
comma
) ||

1486 (
comma
.
ty_
 !
tokObjeEnd
 && comma.ty_ !
tokAayS
 &&

1487 
comma
.
ty_
 !
tokCommt
)) {

1488  
	`addEAndRecov
(

1489 "Missg ',' o'}' iobje dei", 
comma
, 
tokObjeEnd
);

1491 
bo
 
fizeTokOk
 = 
ue
;

1492 
comma
.
ty_
 =
tokCommt
 && 
fizeTokOk
)

1493 
fizeTokOk
 = 
	`adTok
(
comma
);

1494 i(
comma
.
ty_
 =
tokObjeEnd
)

1495  
ue
;

1497  
	`addEAndRecov
(

1498 "Missg '}' oobje membame", 
tokName
, 
tokObjeEnd
);

1499 
	}
}

1501 
bo
 
	gOurRd
::
	$adAay
(
Tok
& 
tokS
) {

1502 
Vue
 
	`
(
yVue
);

1503 
	`cutVue
().
	`swPayld
(

);

1504 
	`cutVue
().
	`tOfftS
(
tokS
.
t_
 - 
beg_
);

1505 
	`skSs
();

1506 i(*
cut_
 == ']')

1508 
Tok
 
dAay
;

1509 
	`adTok
(
dAay
);

1510  
ue
;

1512 
dex
 = 0;

1514 
Vue
& 
vue
 = 
	`cutVue
()[
dex
++];

1515 
nodes_
.
	`push
(&
vue
);

1516 
bo
 
ok
 = 
	`adVue
();

1517 
nodes_
.
	`p
();

1518 i(!
ok
)

1519  
	`covFromE
(
tokAayEnd
);

1521 
Tok
 
tok
;

1523 
ok
 = 
	`adTok
(
tok
);

1524 
tok
.
ty_
 =
tokCommt
 && 
ok
) {

1525 
ok
 = 
	`adTok
(
tok
);

1527 
bo
 
badTokTy
 =

1528 (
tok
.
ty_
 !
tokAayS
 &&ok.ty_ !
tokAayEnd
);

1529 i(!
ok
 || 
badTokTy
) {

1530  
	`addEAndRecov
(

1531 "Missg ',' o']' iy dei", 
tok
, 
tokAayEnd
);

1533 i(
tok
.
ty_
 =
tokAayEnd
)

1536  
ue
;

1537 
	}
}

1539 
bo
 
	gOurRd
::
	$decodeNumb
(
Tok
& 
tok
) {

1540 
Vue
 
decoded
;

1541 i(!
	`decodeNumb
(
tok
, 
decoded
))

1542  
l
;

1543 
	`cutVue
().
	`swPayld
(
decoded
);

1544 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1545 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1546  
ue
;

1547 
	}
}

1549 
bo
 
	gOurRd
::
	$decodeNumb
(
Tok
& 
tok
, 
Vue
& 
decoded
) {

1553 
Loti
 
cut
 = 
tok
.
t_
;

1554 
bo
 
isNegive
 = *
cut
 == '-';

1555 i(
isNegive
)

1556 ++
cut
;

1558 
Vue
::
LgeUI
 
maxIegVue
 =

1559 
isNegive
 ? 
Vue
::
	`LgeUI
(-Vue::
mLgeI
)

1560 : 
Vue
::
maxLgeUI
;

1561 
Vue
::
LgeUI
 
thshd
 = 
maxIegVue
 / 10;

1562 
Vue
::
LgeUI
 
vue
 = 0;

1563 
cut
 < 
tok
.
d_
) {

1564 
Ch
 
c
 = *
cut
++;

1565 i(
c
 < '0' || c > '9')

1566  
	`decodeDoub
(
tok
, 
decoded
);

1567 
Vue
::
UI
 
	`dig
(
ic_
<Vue::UI>(
c
 - '0'));

1568 i(
vue
 >
thshd
) {

1573 i(
vue
 > 
thshd
 || 
cut
 !
tok
.
d_
 ||

1574 
dig
 > 
maxIegVue
 % 10) {

1575  
	`decodeDoub
(
tok
, 
decoded
);

1578 
vue
 = vu* 10 + 
dig
;

1580 i(
isNegive
)

1581 
decoded
 = -
Vue
::
	`LgeI
(
vue
);

1582 i(
vue
 <
Vue
::
	`LgeUI
(Vue::
maxI
))

1583 
decoded
 = 
Vue
::
	`LgeI
(
vue
);

1585 
decoded
 = 
vue
;

1586  
ue
;

1587 
	}
}

1589 
bo
 
	gOurRd
::
	$decodeDoub
(
Tok
& 
tok
) {

1590 
Vue
 
decoded
;

1591 i(!
	`decodeDoub
(
tok
, 
decoded
))

1592  
l
;

1593 
	`cutVue
().
	`swPayld
(
decoded
);

1594 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1595 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1596  
ue
;

1597 
	}
}

1599 
bo
 
	gOurRd
::
	$decodeDoub
(
Tok
& 
tok
, 
Vue
& 
decoded
) {

1600 
vue
 = 0;

1601 cڡ 
bufrSize
 = 32;

1602 
cou
;

1603 
rdiff_t
 cڡ 
ngth
 = 
tok
.
d_
 -ok.
t_
;

1606 i(
ngth
 < 0) {

1607  
	`addE
("Ubˁطrokgth", 
tok
);

1609 
size_t
 cڡ 
ungth
 = 
ic_
<size_t>(
ngth
);

1616 
fm
[] = "%lf";

1618 i(
ngth
 <
bufrSize
) {

1619 
Ch
 
bufr
[
bufrSize
 + 1];

1620 
	`memy
(
bufr
, 
tok
.
t_
, 
ungth
);

1621 
bufr
[
ngth
] = 0;

1622 
cou
 = 
	`ssnf
(
bufr
, 
fm
, &
vue
);

1624 
JSONCPP_STRING
 
	`bufr
(
tok
.
t_
,ok.
d_
);

1625 
cou
 = 
	`ssnf
(
bufr
.
	`c_r
(), 
fm
, &
vue
);

1628 i(
cou
 != 1)

1629  
	`addE
("'" + 
	`JSONCPP_STRING
(
tok
.
t_
,ok.
d_
) +

1631 
tok
);

1632 
decoded
 = 
vue
;

1633  
ue
;

1634 
	}
}

1636 
bo
 
	gOurRd
::
	$decodeSg
(
Tok
& 
tok
) {

1637 
JSONCPP_STRING
 
decoded_rg
;

1638 i(!
	`decodeSg
(
tok
, 
decoded_rg
))

1639  
l
;

1640 
Vue
 
	`decoded
(
decoded_rg
);

1641 
	`cutVue
().
	`swPayld
(
decoded
);

1642 
	`cutVue
().
	`tOfftS
(
tok
.
t_
 - 
beg_
);

1643 
	`cutVue
().
	`tOfftLim
(
tok
.
d_
 - 
beg_
);

1644  
ue
;

1645 
	}
}

1647 
bo
 
	gOurRd
::
	$decodeSg
(
Tok
& 
tok
, 
JSONCPP_STRING
& 
decoded
) {

1648 
decoded
.
	`rve
(
ic_
<
size_t
>(
tok
.
d_
 -ok.
t_
 - 2));

1649 
Loti
 
cut
 = 
tok
.
t_
 + 1;

1650 
Loti
 
d
 = 
tok
.
d_
 - 1;

1651 
cut
 !
d
) {

1652 
Ch
 
c
 = *
cut
++;

1653 i(
c
 == '"')

1655 i(
c
 == '\\') {

1656 i(
cut
 =
d
)

1657  
	`addE
("Emys sequ irg", 
tok
, 
cut
);

1658 
Ch
 
es
 = *
cut
++;

1659 
es
) {

1661 
decoded
 += '"';

1664 
decoded
 += '/';

1667 
decoded
 += '\\';

1670 
decoded
 += '\b';

1673 
decoded
 += '\f';

1676 
decoded
 += '\n';

1679 
decoded
 += '\r';

1682 
decoded
 += '\t';

1685 
unicode
;

1686 i(!
	`decodeUnicodeCodePot
(
tok
, 
cut
, 
d
, 
unicode
))

1687  
l
;

1688 
decoded
 +
	`codePotToUTF8
(
unicode
);

1691  
	`addE
("Bads sequ irg", 
tok
, 
cut
);

1694 
decoded
 +
c
;

1697  
ue
;

1698 
	}
}

1700 
bo
 
	gOurRd
::
	$decodeUnicodeCodePot
(
Tok
& 
tok
,

1701 
Loti
& 
cut
,

1702 
Loti
 
d
,

1703 & 
unicode
) {

1705 i(!
	`decodeUnicodeEsSequ
(
tok
, 
cut
, 
d
, 
unicode
))

1706  
l
;

1707 i(
unicode
 >= 0xD800 && unicode <= 0xDBFF) {

1709 i(
d
 - 
cut
 < 6)

1710  
	`addE
(

1712 
tok
,

1713 
cut
);

1714 
suogePa
;

1715 i(*(
cut
++) == '\\' && *(current++) == 'u') {

1716 i(
	`decodeUnicodeEsSequ
(
tok
, 
cut
, 
d
, 
suogePa
)) {

1717 
unicode
 = 0x10000 + ((unicod& 0x3FF<< 10+ (
suogePa
 & 0x3FF);

1719  
l
;

1721  
	`addE
("expectingnother \\uokeno beginhe second half of "

1723 
tok
,

1724 
cut
);

1726  
ue
;

1727 
	}
}

1729 
bo
 
	gOurRd
::
	$decodeUnicodeEsSequ
(
Tok
& 
tok
,

1730 
Loti
& 
cut
,

1731 
Loti
 
d
,

1732 & 
t_unicode
) {

1733 i(
d
 - 
cut
 < 4)

1734  
	`addE
(

1736 
tok
,

1737 
cut
);

1738 
unicode
 = 0;

1739 
dex
 = 0; index < 4; ++index) {

1740 
Ch
 
c
 = *
cut
++;

1741 
unicode
 *= 16;

1742 i(
c
 >= '0' && c <= '9')

1743 
unicode
 +
c
 - '0';

1744 i(
c
 >= 'a' && c <= 'f')

1745 
unicode
 +
c
 - 'a' + 10;

1746 i(
c
 >= 'A' && c <= 'F')

1747 
unicode
 +
c
 - 'A' + 10;

1749  
	`addE
(

1751 
tok
,

1752 
cut
);

1754 
t_unicode
 = 
ic_
<>(
unicode
);

1755  
ue
;

1756 
	}
}

1758 
bo


1759 
	gOurRd
::
	$addE
(cڡ 
JSONCPP_STRING
& 
mesge
, 
Tok
& 
tok
, 
Loti
 
exa
) {

1760 
EInfo
 
fo
;

1761 
fo
.
tok_
 = 
tok
;

1762 
fo
.
mesge_
 = 
mesge
;

1763 
fo
.
exa_
 = 
exa
;

1764 
rs_
.
	`push_back
(
fo
);

1765  
l
;

1766 
	}
}

1768 
bo
 
	gOurRd
::
	$covFromE
(
TokTy
 
skUTok
) {

1769 
size_t
 
rCou
 = 
rs_
.
	`size
();

1770 
Tok
 
sk
;

1772 i(!
	`adTok
(
sk
))

1773 
rs_
.
	`size
(
rCou
);

1774 i(
sk
.
ty_
 =
skUTok
 || sk.ty_ =
tokEndOfSm
)

1777 
rs_
.
	`size
(
rCou
);

1778  
l
;

1779 
	}
}

1781 
bo
 
	gOurRd
::
	$addEAndRecov
(cڡ 
JSONCPP_STRING
& 
mesge
,

1782 
Tok
& 
tok
,

1783 
TokTy
 
skUTok
) {

1784 
	`addE
(
mesge
, 
tok
);

1785  
	`covFromE
(
skUTok
);

1786 
	}
}

1788 
	gVue
& 
	gOurRd
::
	$cutVue
({  *(
nodes_
.
	`t
()); 
	}
}

1790 
	gOurRd
::
Ch
 
OurRd
::
	$gNextCh
() {

1791 i(
cut_
 =
d_
)

1793  *
cut_
++;

1794 
	}
}

1796 
	gOurRd
::
	$gLotiLeAndCumn
(
Loti
 
loti
,

1797 & 
le
,

1798 & 
cumn
) const {

1799 
Loti
 
cut
 = 
beg_
;

1800 
Loti
 
ϡLeS
 = 
cut
;

1801 
le
 = 0;

1802 
cut
 < 
loti
 && cu!
d_
) {

1803 
Ch
 
c
 = *
cut
++;

1804 i(
c
 == '\r') {

1805 i(*
cut
 == '\n')

1806 ++
cut
;

1807 
ϡLeS
 = 
cut
;

1808 ++
le
;

1809 } i(
c
 == '\n') {

1810 
ϡLeS
 = 
cut
;

1811 ++
le
;

1815 
cumn
 = (
loti
 - 
ϡLeS
) + 1;

1816 ++
le
;

1817 
	}
}

1819 
JSONCPP_STRING
 
	gOurRd
::
	$gLotiLeAndCumn
(
Loti
 
loti
) const {

1820 
le
, 
cumn
;

1821 
	`gLotiLeAndCumn
(
loti
, 
le
, 
cumn
);

1822 
bufr
[18 + 16 + 16 + 1];

1823 
	`tf
(
bufr
, (bufr), "L%d, Cum%d", 
le
, 
cumn
);

1824  
bufr
;

1825 
	}
}

1827 
JSONCPP_STRING
 
	gOurRd
::
	$gFmdEMesges
() const {

1828 
JSONCPP_STRING
 
fmdMesge
;

1829 
Es
::
cڡ_
 
E
 = 
rs_
.
	`beg
();

1830 
E
 !
rs_
.
	`d
();

1831 ++
E
) {

1832 cڡ 
EInfo
& 
r
 = *
E
;

1833 
fmdMesge
 +=

1834 "* " + 
	`gLotiLeAndCumn
(
r
.
tok_
.
t_
) + "\n";

1835 
fmdMesge
 +" " + 
r
.
mesge_
 + "\n";

1836 i(
r
.
exa_
)

1837 
fmdMesge
 +=

1838 "S " + 
	`gLotiLeAndCumn
(
r
.
exa_
) + " for detail.\n";

1840  
fmdMesge
;

1841 
	}
}

1843 
	gd
::
ve
<
OurRd
::
SuudE
> OurRd::
	$gSuudEs
() const {

1844 
d
::
ve
<
OurRd
::
SuudE
> 
lEs
;

1845 
Es
::
cڡ_
 
E
 = 
rs_
.
	`beg
();

1846 
E
 !
rs_
.
	`d
();

1847 ++
E
) {

1848 cڡ 
EInfo
& 
r
 = *
E
;

1849 
OurRd
::
SuudE
 
ruud
;

1850 
ruud
.
offt_t
 = 
r
.
tok_
.
t_
 - 
beg_
;

1851 
ruud
.
offt_lim
 = 
r
.
tok_
.
d_
 - 
beg_
;

1852 
ruud
.
mesge
 = 
r
.
mesge_
;

1853 
lEs
.
	`push_back
(
ruud
);

1855  
lEs
;

1856 
	}
}

1858 
bo
 
	gOurRd
::
	$pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
) {

1859 
rdiff_t
 
ngth
 = 
d_
 - 
beg_
;

1860 if(
vue
.
	`gOfftS
(> 
ngth


1861 || 
vue
.
	`gOfftLim
(> 
ngth
)

1862  
l
;

1863 
Tok
 
tok
;

1864 
tok
.
ty_
 = 
tokE
;

1865 
tok
.
t_
 = 
beg_
 + 
vue
.
	`gOfftS
();

1866 
tok
.
d_
 =nd_ + 
vue
.
	`gOfftLim
();

1867 
EInfo
 
fo
;

1868 
fo
.
tok_
 = 
tok
;

1869 
fo
.
mesge_
 = 
mesge
;

1870 
fo
.
exa_
 = 0;

1871 
rs_
.
	`push_back
(
fo
);

1872  
ue
;

1873 
	}
}

1875 
bo
 
	gOurRd
::
	$pushE
(cڡ 
Vue
& 
vue
, cڡ 
JSONCPP_STRING
& 
mesge
, cڡ Vue& 
exa
) {

1876 
rdiff_t
 
ngth
 = 
d_
 - 
beg_
;

1877 if(
vue
.
	`gOfftS
(> 
ngth


1878 || 
vue
.
	`gOfftLim
(> 
ngth


1879 || 
exa
.
	`gOfftLim
(> 
ngth
)

1880  
l
;

1881 
Tok
 
tok
;

1882 
tok
.
ty_
 = 
tokE
;

1883 
tok
.
t_
 = 
beg_
 + 
vue
.
	`gOfftS
();

1884 
tok
.
d_
 = 
beg_
 + 
vue
.
	`gOfftLim
();

1885 
EInfo
 
fo
;

1886 
fo
.
tok_
 = 
tok
;

1887 
fo
.
mesge_
 = 
mesge
;

1888 
fo
.
exa_
 = 
beg_
 + 
exa
.
	`gOfftS
();

1889 
rs_
.
	`push_back
(
fo
);

1890  
ue
;

1891 
	}
}

1893 
bo
 
	gOurRd
::
	$good
() const {

1894  !
rs_
.
	`size
();

1895 
	}
}

1898 as
	cOurChRd
 : 
public
 
ChRd
 {

1899 
bo
 cڡ 
cCommts_
;

1900 
OurRd
 
	gad_
;

1901 
	gpublic
:

1902 
OurChRd
(

1903 
bo
 
cCommts
,

1904 
OurFtus
 cڡ& 
us
)

1905 : 
cCommts_
(
cCommts
)

1906 , 
ad_
(
us
)

1908 
bo
 
r
(

1909 cڡ* 
begDoc
, cڡ* 
dDoc
,

1910 
Vue
* 
ro
, 
JSONCPP_STRING
* 
rs

	gJSONCPP_OVERRIDE
 {

1911 
bo
 
	gok
 = 
ad_
.
r
(
begDoc
, 
dDoc
, *
ro
, 
cCommts_
);

1912 i(
	grs
) {

1913 *
	grs
 = 
ad_
.
gFmdEMesges
();

1915  
	gok
;

1919 
	gChRdBud
::
	$ChRdBud
()

1921 
	`tDeus
(&
gs_
);

1922 
	}
}

1923 
	gChRdBud
::~
	$ChRdBud
()

1924 {
	}
}

1925 
ChRd
* 
ChRdBud
::
	$wChRd
() const

1927 
bo
 
cCommts
 = 
gs_
["cCommts"].
	`asBo
();

1928 
OurFtus
 
us
 = OurFtus::
	`l
();

1929 
us
.
lowCommts_
 = 
gs_
["lowCommts"].
	`asBo
();

1930 
us
.
riRo_
 = 
gs_
["riRo"].
	`asBo
();

1931 
us
.
lowDrݳdNuPhds_
 = 
gs_
["lowDrݳdNuPhds"].
	`asBo
();

1932 
us
.
lowNumicKeys_
 = 
gs_
["lowNumicKeys"].
	`asBo
();

1933 
us
.
lowSgQues_
 = 
gs_
["lowSgQues"].
	`asBo
();

1934 
us
.
ackLim_
 = 
gs_
["ackLim"].
	`asI
();

1935 
us
.
IfExa_
 = 
gs_
["IfExa"].
	`asBo
();

1936 
us
.
jeDupKeys_
 = 
gs_
["jeDupKeys"].
	`asBo
();

1937 
us
.
lowSclFlts_
 = 
gs_
["lowSclFlts"].
	`asBo
();

1938  
w
 
	`OurChRd
(
cCommts
, 
us
);

1939 
	}
}

1940 
gVidRdKeys
(
d
::
t
<
JSONCPP_STRING
>* 
vid_keys
)

1942 
vid_keys
->
r
();

1943 
	gvid_keys
->

("collectComments");

1944 
	gvid_keys
->

("allowComments");

1945 
	gvid_keys
->

("strictRoot");

1946 
	gvid_keys
->

("allowDroppedNullPlaceholders");

1947 
	gvid_keys
->

("allowNumericKeys");

1948 
	gvid_keys
->

("allowSingleQuotes");

1949 
	gvid_keys
->

("stackLimit");

1950 
	gvid_keys
->

("failIfExtra");

1951 
	gvid_keys
->

("rejectDupKeys");

1952 
	gvid_keys
->

("allowSpecialFloats");

1954 
bo
 
	gChRdBud
::
	$vide
(
Js
::
Vue
* 
vid
) const

1956 
Js
::
Vue
 
my_vid
;

1957 i(!
vid
vid = &
my_vid
;

1958 
Js
::
Vue
& 
v
 = *
vid
;

1959 
d
::
t
<
JSONCPP_STRING
> 
vid_keys
;

1960 
	`gVidRdKeys
(&
vid_keys
);

1961 
Vue
::
Membs
 
keys
 = 
gs_
.
	`gMembNames
();

1962 
size_t
 
n
 = 
keys
.
	`size
();

1963 
size_t
 
i
 = 0; i < 
n
; ++i) {

1964 
JSONCPP_STRING
 cڡ& 
key
 = 
keys
[
i
];

1965 i(
vid_keys
.
	`fd
(
key
=vid_keys.
	`d
()) {

1966 
v
[
key
] = 
gs_
[key];

1969  0u =
v
.
	`size
();

1970 
	}
}

1971 
	gVue
& 
	gChRdBud
::
ݔ
[](
JSONCPP_STRING
 
key
)

1973  
gs_
[
key
];

1976 
	gChRdBud
::
	$riMode
(
Js
::
Vue
* 
gs
)

1979 (*
gs
)["lowCommts"] = 
l
;

1980 (*
gs
)["riRo"] = 
ue
;

1981 (*
gs
)["lowDrݳdNuPhds"] = 
l
;

1982 (*
gs
)["lowNumicKeys"] = 
l
;

1983 (*
gs
)["lowSgQues"] = 
l
;

1984 (*
gs
)["stackLimit"] = 1000;

1985 (*
gs
)["IfExa"] = 
ue
;

1986 (*
gs
)["jeDupKeys"] = 
ue
;

1987 (*
gs
)["lowSclFlts"] = 
l
;

1989 
	}
}

1991 
	gChRdBud
::
	$tDeus
(
Js
::
Vue
* 
gs
)

1994 (*
gs
)["cCommts"] = 
ue
;

1995 (*
gs
)["lowCommts"] = 
ue
;

1996 (*
gs
)["riRo"] = 
l
;

1997 (*
gs
)["lowDrݳdNuPhds"] = 
l
;

1998 (*
gs
)["lowNumicKeys"] = 
l
;

1999 (*
gs
)["lowSgQues"] = 
l
;

2000 (*
gs
)["stackLimit"] = 1000;

2001 (*
gs
)["IfExa"] = 
l
;

2002 (*
gs
)["jeDupKeys"] = 
l
;

2003 (*
gs
)["lowSclFlts"] = 
l
;

2005 
	}
}

2010 
bo
 
	$rFromSm
(

2011 
ChRd
::
Fay
 cڡ& 

, 
JSONCPP_ISTREAM
& 
s
,

2012 
Vue
* 
ro
, 
JSONCPP_STRING
* 
rs
)

2014 
JSONCPP_OSTRINGSTREAM
 
ss
;

2015 
ss
 << 
s
.
	`rdbuf
();

2016 
JSONCPP_STRING
 
doc
 = 
ss
.
	`r
();

2017 cڡ* 
beg
 = 
doc
.
	`da
();

2018 cڡ* 
d
 = 
beg
 + 
doc
.
	`size
();

2020 
ChRdP
 cڡ 
	`ad
(

.
	`wChRd
());

2021  
ad
->
	`r
(
beg
, 
d
, 
ro
, 
rs
);

2022 
	}
}

2024 
	gJSONCPP_ISTREAM
& 
	gݔ
>>(JSONCPP_ISTREAM& 
	gs
, 
	gVue
& 
	gro
) {

2025 
ChRdBud
 
	gb
;

2026 
JSONCPP_STRING
 
	grs
;

2027 
bo
 
	gok
 = 
rFromSm
(
b
, 
s
, &
ro
, &
rs
);

2028 i(!
	gok
) {

2029 
rtf
(
dr
,

2031 
rs
.
c_r
());

2033 
throwRuimeE
(
rs
);

2035  
	gs
;

	@open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_tool.h

6 #ide
LIB_JSONCPP_JSON_TOOL_H_INCLUDED


7 
	#LIB_JSONCPP_JSON_TOOL_H_INCLUDED


	)

15 
mea
 
	gJs
 {

18 
le
 
JSONCPP_STRING
 
codePotToUTF8
(

) {

19 
JSONCPP_STRING
 
	gsu
;

23 i(
	g
 <= 0x7f) {

24 
su
.
size
(1);

25 
	gsu
[0] = 
ic_
<>(

);

26 } i(
	g
 <= 0x7FF) {

27 
su
.
size
(2);

28 
	gsu
[1] = 
ic_
<>(0x80 | (0x3& 

));

29 
	gsu
[0] = 
ic_
<>(0xC0 | (0x1& (

 >> 6)));

30 } i(
	g
 <= 0xFFFF) {

31 
su
.
size
(3);

32 
	gsu
[2] = 
ic_
<>(0x80 | (0x3& 

));

33 
	gsu
[1] = 
ic_
<>(0x80 | (0x3& (

 >> 6)));

34 
	gsu
[0] = 
ic_
<>(0xE0 | (0x& (

 >> 12)));

35 } i(
	g
 <= 0x10FFFF) {

36 
su
.
size
(4);

37 
	gsu
[3] = 
ic_
<>(0x80 | (0x3& 

));

38 
	gsu
[2] = 
ic_
<>(0x80 | (0x3& (

 >> 6)));

39 
	gsu
[1] = 
ic_
<>(0x80 | (0x3& (

 >> 12)));

40 
	gsu
[0] = 
ic_
<>(0xF0 | (0x7 & (

 >> 18)));

43  
	gsu
;

47 
le
 
bo
 
isCڌCha
(
ch
{  
	gch
 > 0 && ch <= 0x1F; }

52 
	gutToSgBufrSize
 = 3 * (
LgeUI
) + 1

56 
	tUIToSgBufr
[
utToSgBufrSize
];

63 
le
 
utToSg
(
LgeUI
 
vue
, *& 
cut
) {

64 *--
	gcut
 = 0;

66 *--
	gcut
 = 
ic_
<>(
vue
 % 10U + static_cast<>('0'));

67 
	gvue
 /= 10;

68 } 
	gvue
 != 0);

76 
le
 
fixNumicLo
(* 
beg
, * 
d
) {

77 
	gbeg
 < 
	gd
) {

78 i(*
	gbeg
 == ',') {

79 *
beg
 = '.';

81 ++
	gbeg
;

	@open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_value.cpp

6 #i!
defed
(
JSON_IS_AMALGAMATION
)

7 
	~<js/asis.h
>

8 
	~<js/vue.h
>

9 
	~<js/wr.h
>

11 
	~<mh.h
>

12 
	~<sam
>

13 
	~<uty
>

14 
	~<crg
>

15 
	~<s
>

16 #ifde
JSON_USE_CPPTL


17 
	~<l/cڡrg.h
>

19 
	~<cddef
>

20 
	~<gܙhm
>

22 
	#JSON_ASSERT_UNREACHABLE
 
	`as
(
l
)

	)

24 
mea
 
	gJs
 {

29 #i
defed
(
__ARMEL__
)

30 
	#ALIGNAS
(
by_ignmt

	`__ibu__
((
	`igd
(by_ignmt)))

	)

32 
	#ALIGNAS
(
by_ignmt
)

	)

34 cڡ 
ALIGNAS
(8
	gkNu
[(
Vue
)] = { 0 };

35 cڡ & 
	gkNuRef
 = 
kNu
[0];

36 cڡ 
	gVue
& Vue::
nu
 = 
t_
<cڡ 
Vue
&>(
kNuRef
);

37 cڡ 
	gVue
& Vue::
nuRef
 = 
nu
;

39 cڡ 
I
 
	gVue
::
mI
 = I(~(
UI
(-1) / 2));

40 cڡ 
I
 
	gVue
::
maxI
 = I(
UI
(-1) / 2);

41 cڡ 
UI
 
	gVue
::
maxUI
 = UInt(-1);

42 #i
defed
(
JSON_HAS_INT64
)

43 cڡ 
I64
 
	gVue
::
mI64
 = I64(~(
UI64
(-1) / 2));

44 cڡ 
I64
 
	gVue
::
maxI64
 = I64(
UI64
(-1) / 2);

45 cڡ 
UI64
 
	gVue
::
maxUI64
 = UInt64(-1);

49 cڡ 
	gmaxUI64AsDoub
 = 18446744073709551615.0;

51 cڡ 
LgeI
 
	gVue
::
mLgeI
 = LgeI(~(
LgeUI
(-1) / 2));

52 cڡ 
LgeI
 
	gVue
::
maxLgeI
 = LgeI(
LgeUI
(-1) / 2);

53 cڡ 
LgeUI
 
	gVue
::
maxLgeUI
 = LargestUInt(-1);

55 #i!
defed
(
JSON_USE_INT64_DOUBLE_CONVERSION
)

56 
	gme
 <
tyme
 
	gT
,ym
	gU
>

57 
le
 
bo
 
InRge
(
d
, 
T
 
m
, 
U
 
max
) {

61  
	gd
 >
m
 && 
d
 <
max
;

64 
le
 
gToDoub
(
Js
::
UI64
 
vue
) {

65  
ic_
<>(
I64
(
vue
 / 2)) * 2.0 + static_cast<>(Int64(value & 1));

68 
	gme
 <
tyme
 
	gT
> 
le
 
gToDoub
(
T
 
vue
) {

69  
	gic_
<>(
	gvue
);

72 
	gme
 <
tyme
 
	gT
,ym
	gU
>

73 
le
 
bo
 
InRge
(
d
, 
T
 
m
, 
U
 
max
) {

74  
	gd
 >
gToDoub
(
m
&& 
d
 <gToDoub(
max
);

85 
le
 * 
duiSgVue
(cڡ * 
vue
,

86 
size_t
 
ngth
)

90 i(
	gngth
 >
ic_
<
size_t
>(
Vue
::
maxI
))

91 
ngth
 = 
Vue
::
maxI
 - 1;

93 * 
	gwSg
 = 
ic_
<*>(
mloc
(
ngth
 + 1));

94 i(
	gwSg
 =
NULL
) {

95 
throwRuimeE
(

99 
memy
(
wSg
, 
vue
, 
ngth
);

100 
	gwSg
[
ngth
] = 0;

101  
	gwSg
;

106 
le
 * 
duiAndPfixSgVue
(

107 cڡ * 
vue
,

108 
ngth
)

112 
JSON_ASSERT_MESSAGE
(
ngth
 <
ic_
<>(
Vue
::
maxI
) - () - 1U,

115 
	gauLgth
 = 
ngth
 + 
ic_
<>(()) + 1U;

116 * 
	gwSg
 = 
ic_
<*>(
mloc
(
auLgth
));

117 i(
	gwSg
 == 0) {

118 
throwRuimeE
(

122 *
	gt_
<*>(
	gwSg

ngth
;

123 
memy
(
wSg
 + (), 
vue
, 
ngth
);

124 
	gwSg
[
auLgth
 - 1U] = 0;

125  
	gwSg
;

127 
le
 
decodePfixedSg
(

128 
bo
 
isPfixed
, cڡ* 
efixed
,

129 * 
ngth
, cڡ** 
vue
)

131 i(!
	gisPfixed
) {

132 *
	gngth
 = 
ic_
<>(

(
efixed
));

133 *
	gvue
 = 
efixed
;

135 *
	gngth
 = *
t_
<cڡ*>(
efixed
);

136 *
	gvue
 = 
efixed
 + ();

141 #i
JSONCPP_USING_SECURE_MEMORY


142 
le
 
aPfixedSgVue
(* 
vue
) {

143 
	gngth
 = 0;

144 cڡ* 
	gvueDecoded
;

145 
decodePfixedSg
(
ue
, 
vue
, &
ngth
, &
vueDecoded
);

146 
size_t
 cڡ 
	gsize
 = (+ 
ngth
 + 1U;

147 
memt
(
vue
, 0, 
size
);

148 

(
vue
);

150 
le
 
aSgVue
(* 
vue
, 
ngth
) {

152 
size_t
 
	gsize
 = (
ngth
==0? 

(
vue
) :ength;

153 
memt
(
vue
, 0, 
size
);

154 

(
vue
);

157 
le
 
aPfixedSgVue
(* 
vue
) {

158 

(
vue
);

160 
le
 
aSgVue
(* 
vue
, 
ngth
) {

161 

(
vue
);

174 #i!
defed
(
JSON_IS_AMALGAMATION
)

176 
	~"js_vue.l
"

179 
mea
 
	gJs
 {

181 
	gExi
::
Exi
(
JSONCPP_STRING
 cڡ& 
msg
)

182 : 
msg_
(
msg
)

184 
Exi
::~Exi(
throw
()

186 cڡ* 
Exi
::
wh
(cڡ 
throw
()

188  
msg_
.
c_r
();

190 
	gRuimeE
::
RuimeE
(
JSONCPP_STRING
 cڡ& 
msg
)

191 : 
Exi
(
msg
)

193 
LogicE
::LogicE(
JSONCPP_STRING
 cڡ& 
msg
)

194 : 
Exi
(
msg
)

196 
JSONCPP_NORETURN
 
throwRuimeE
(
JSONCPP_STRING
 cڡ& 
msg
)

198 
throw
 
RuimeE
(
msg
);

200 
JSONCPP_NORETURN
 
throwLogicE
(
JSONCPP_STRING
 cڡ& 
msg
)

202 
throw
 
LogicE
(
msg
);

213 
	gVue
::
CommtInfo
::CommtInfo(: 
commt_
(0)

216 
Vue
::
CommtInfo
::~CommentInfo() {

217 i(
commt_
)

218 
aSgVue
(
commt_
, 0u);

221 
	gVue
::
CommtInfo
::
tCommt
(cڡ * 
xt
, 
size_t
 
n
) {

222 i(
	gcommt_
) {

223 
aSgVue
(
commt_
, 0u);

224 
	gcommt_
 = 0;

226 
JSON_ASSERT
(
xt
 != 0);

227 
JSON_ASSERT_MESSAGE
(

228 
xt
[0] == '\0' ||ext[0] == '/',

231 
	gcommt_
 = 
duiSgVue
(
xt
, 
n
);

245 
	gVue
::
CZSg
::CZSg(
AayIndex
 
adex
: 
cr_
(0), 
dex_
(aindex) {}

247 
	gVue
::
CZSg
::CZSg(cڡ* 
r
, 
ungth
, 
DuitiPicy
 
lo
)

248 : 
cr_
(
r
) {

250 
age_
.
picy_
 = 
lo
 & 0x3;

251 
	gage_
.
	gngth_
 = 
ungth
 & 0x3FFFFFFF;

254 
	gVue
::
CZSg
::CZSg(cڡ CZSg& 
h
) {

255 
cr_
 = (
h
.
age_
.
picy_
 !
noDuiti
 && other.cstr_ != 0

256 ? 
duiSgVue
(
h
.
cr_
, oth.
age_
.
ngth_
)

257 : 
h
.
cr_
);

258 
	gage_
.
	gpicy_
 = 
ic_
<>(
h
.
cr_


259 ? (
ic_
<
DuitiPicy
>(
h
.
age_
.
picy_
=
noDuiti


260 ? 
noDuiti
 : 
dui
)

261 : 
ic_
<
DuitiPicy
>(
h
.
age_
.
picy_
)) & 3U;

262 
	gage_
.
	gngth_
 = 
h
.
age_
.
ngth_
;

265 #i
JSON_HAS_RVALUE_REFERENCES


266 
	gVue
::
CZSg
::CZSg(CZSg&& 
h
)

267 : 
cr_
(
h
.cr_), 
dex_
(other.index_) {

268 
	gh
.
	gcr_
 = 
nuαr
;

272 
	gVue
::
CZSg
::~CZString() {

273 i(
cr_
 && 
age_
.
picy_
 =
dui
) {

274 
aSgVue
(
cڡ_
<*>(
cr_
), 
age_
.
ngth_
 + 1u);

278 
	gVue
::
CZSg
::
sw
(CZSg& 
h
) {

279 
d
::
sw
(
cr_
, 
h
.cstr_);

280 
	gd
::
sw
(
dex_
, 
h
.index_);

283 
	gVue
::
CZSg
& 
Vue
::CZSg::
ݔ
=(CZSg 
h
) {

284 
sw
(
h
);

285  *
	gthis
;

288 
bo
 
	gVue
::
CZSg
::
ݔ
<(cڡ CZSg& 
h
) const {

289 i(!
cr_
 
dex_
 < 
h
.index_;

292 
	gthis_n
 = 
this
->
age_
.
ngth_
;

293 
	gh_n
 = 
h
.
age_
.
ngth_
;

294 
	gm_n
 = 
d
::
m
(
this_n
, 
h_n
);

295 
JSON_ASSERT
(
this
->
cr_
 && 
h
.cstr_);

296 
	gcomp
 = 
memcmp
(
this
->
cr_
, 
h
.cr_, 
m_n
);

297 i(
	gcomp
 < 0 
	gue
;

298 i(
	gcomp
 > 0 
	gl
;

299  (
	gthis_n
 < 
	gh_n
);

302 
bo
 
	gVue
::
CZSg
::
ݔ
==(cڡ CZSg& 
h
) const {

303 i(!
cr_
 
dex_
 =
h
.index_;

306 
	gthis_n
 = 
this
->
age_
.
ngth_
;

307 
	gh_n
 = 
h
.
age_
.
ngth_
;

308 i(
	gthis_n
 !
h_n
 
l
;

309 
JSON_ASSERT
(
this
->
cr_
 && 
h
.cstr_);

310 
	gcomp
 = 
memcmp
(
this
->
cr_
, 
h
.cr_, 
this_n
);

311  
	gcomp
 == 0;

314 
AayIndex
 
	gVue
::
CZSg
::
dex
(cڡ {  
dex_
; }

317 cڡ * 
	gVue
::
CZSg
::
da
(cڡ {  
cr_
; }

318 
	gVue
::
CZSg
::
ngth
(cڡ {  
age_
.
ngth_
; }

319 
bo
 
	gVue
::
CZSg
::
isSticSg
(cڡ {  
age_
.
picy_
 =
noDuiti
; }

333 
	gVue
::
Vue
(
VueTy
 
vty
) {

334 
Basic
(
vty
);

335 
	gvty
) {

336 
	gnuVue
:

338 
	gtVue
:

339 
utVue
:

340 
vue_
.
t_
 = 0;

342 
	gVue
:

343 
vue_
.
_
 = 0.0;

345 
	grgVue
:

346 
vue_
.
rg_
 = 0;

348 
	gyVue
:

349 
objeVue
:

350 
vue_
.
m_
 = 
w
 
ObjeVues
();

352 
	gboޗnVue
:

353 
vue_
.
bo_
 = 
l
;

356 
JSON_ASSERT_UNREACHABLE
;

360 
	gVue
::
Vue
(
I
 
vue
) {

361 
Basic
(
tVue
);

362 
	gvue_
.
	gt_
 = 
vue
;

365 
	gVue
::
Vue
(
UI
 
vue
) {

366 
Basic
(
utVue
);

367 
	gvue_
.
	gut_
 = 
vue
;

369 #i
defed
(
JSON_HAS_INT64
)

370 
	gVue
::
Vue
(
I64
 
vue
) {

371 
Basic
(
tVue
);

372 
	gvue_
.
	gt_
 = 
vue
;

374 
	gVue
::
Vue
(
UI64
 
vue
) {

375 
Basic
(
utVue
);

376 
	gvue_
.
	gut_
 = 
vue
;

380 
	gVue
::
Vue
(
vue
) {

381 
Basic
(
Vue
);

382 
	gvue_
.
	g_
 = 
vue
;

385 
	gVue
::
Vue
(cڡ * 
vue
) {

386 
Basic
(
rgVue
, 
ue
);

387 
	gvue_
.
	grg_
 = 
duiAndPfixSgVue
(
vue
, 
ic_
<>(

(value)));

390 
	gVue
::
Vue
(cڡ * 
begVue
, cڡ * 
dVue
) {

391 
Basic
(
rgVue
, 
ue
);

392 
	gvue_
.
	grg_
 =

393 
duiAndPfixSgVue
(
begVue
, 
ic_
<>(
dVue
 - beginValue));

396 
	gVue
::
Vue
(cڡ 
JSONCPP_STRING
& 
vue
) {

397 
Basic
(
rgVue
, 
ue
);

398 
	gvue_
.
	grg_
 =

399 
duiAndPfixSgVue
(
vue
.
da
(), 
ic_
<>(vue.
ngth
()));

402 
	gVue
::
Vue
(cڡ 
SticSg
& 
vue
) {

403 
Basic
(
rgVue
);

404 
	gvue_
.
	grg_
 = 
cڡ_
<*>(
vue
.
c_r
());

407 #ifde
JSON_USE_CPPTL


408 
	gVue
::
Vue
(cڡ 
CTL
::
CڡSg
& 
vue
) {

409 
Basic
(
rgVue
, 
ue
);

410 
	gvue_
.
	grg_
 = 
duiAndPfixSgVue
(
vue
, 
ic_
<>(vue.
ngth
()));

414 
	gVue
::
Vue
(
bo
 
vue
) {

415 
Basic
(
boޗnVue
);

416 
	gvue_
.
	gbo_
 = 
vue
;

419 
	gVue
::
Vue
(Vucڡ& 
h
)

420 : 
ty_
(
h
.ty_), 
lod_
(
l
)

422 
commts_
(0), 
t_
(
h
.t_), 
lim_
(other.limit_)

424 
	gty_
) {

425 
	gnuVue
:

426 
tVue
:

427 
utVue
:

428 
Vue
:

429 
boޗnVue
:

430 
vue_
 = 
h
.value_;

432 
	grgVue
:

433 i(
h
.
vue_
.
rg_
 && oth.
lod_
) {

434 
n
;

435 cڡ* 
	gr
;

436 
decodePfixedSg
(
h
.
lod_
, oth.
vue_
.
rg_
,

437 &
n
, &
r
);

438 
	gvue_
.
	grg_
 = 
duiAndPfixSgVue
(
r
, 
n
);

439 
	glod_
 = 
ue
;

441 
	gvue_
.
	grg_
 = 
h
.
vue_
.
rg_
;

442 
	glod_
 = 
l
;

445 
	gyVue
:

446 
objeVue
:

447 
vue_
.
m_
 = 
w
 
ObjeVues
(*
h
.value_.map_);

450 
JSON_ASSERT_UNREACHABLE
;

452 i(
	gh
.
	gcommts_
) {

453 
	gcommts_
 = 
w
 
CommtInfo
[
numbOfCommtPmt
];

454 
	gcommt
 = 0; comm< 
	gnumbOfCommtPmt
; ++comment) {

455 cڡ 
	gCommtInfo
& 
	ghCommt
 = 
h
.
commts_
[
commt
];

456 i(
	ghCommt
.
	gcommt_
)

457 
	gcommts_
[
commt
].
tCommt
(

458 
hCommt
.
commt_
, 

(otherComment.comment_));

463 #i
JSON_HAS_RVALUE_REFERENCES


465 
	gVue
::
Vue
(Vue&& 
h
) {

466 
Basic
(
nuVue
);

467 
sw
(
h
);

471 
	gVue
::~
Vue
() {

472 
ty_
) {

473 
nuVue
:

474 
tVue
:

475 
utVue
:

476 
Vue
:

477 
boޗnVue
:

479 
	grgVue
:

480 i(
lod_
)

481 
aPfixedSgVue
(
vue_
.
rg_
);

483 
	gyVue
:

484 
objeVue
:

485 
de
 
vue_
.
m_
;

488 
JSON_ASSERT_UNREACHABLE
;

491 i(
	gcommts_
)

492 
	gde
[] 
	gcommts_
;

494 
	gvue_
.
	gut_
 = 0;

497 
	gVue
& Vue::
ݔ
=(
Vue
 
h
) {

498 
sw
(
h
);

499  *
	gthis
;

502 
	gVue
::
swPayld
(
Vue
& 
h
) {

503 
VueTy
 
mp
 = 
ty_
;

504 
	gty_
 = 
h
.
ty_
;

505 
	gh
.
	gty_
 = 
mp
;

506 
	gd
::
sw
(
vue_
, 
h
.value_);

507 
	gmp2
 = 
lod_
;

508 
	glod_
 = 
h
.
lod_
;

509 
	gh
.
	glod_
 = 
mp2
 & 0x1;

512 
	gVue
::
sw
(
Vue
& 
h
) {

513 
swPayld
(
h
);

514 
	gd
::
sw
(
commts_
, 
h
.comments_);

515 
	gd
::
sw
(
t_
, 
h
.start_);

516 
	gd
::
sw
(
lim_
, 
h
.limit_);

519 
VueTy
 
	gVue
::
ty
(cڡ {  
ty_
; }

521 
	gVue
::
com
(cڡ 
Vue
& 
h
) const {

522 i(*
this
 < 
h
)

524 i(*
	gthis
 > 
	gh
)

529 
bo
 
	gVue
::
ݔ
<(cڡ 
Vue
& 
h
) const {

530 
tyD
 = 
ty_
 - 
h
.type_;

531 i(
	gtyD
)

532  
	gtyD
 < 0 ? 
	gue
 : 
l
;

533 
	gty_
) {

534 
	gnuVue
:

535  
l
;

536 
	gtVue
:

537  
vue_
.
t_
 < 
h
.value_.int_;

538 
	gutVue
:

539  
vue_
.
ut_
 < 
h
.value_.uint_;

540 
	gVue
:

541  
vue_
.
_
 < 
h
.value_.real_;

542 
	gboޗnVue
:

543  
vue_
.
bo_
 < 
h
.value_.bool_;

544 
	grgVue
:

546 i((
vue_
.
rg_
 =0|| (
h
.value_.string_ == 0)) {

547 i(
h
.
vue_
.
rg_
 
ue
;

548  
	gl
;

550 
	gthis_n
;

551 
	gh_n
;

552 cڡ* 
	gthis_r
;

553 cڡ* 
	gh_r
;

554 
decodePfixedSg
(
this
->
lod_
,his->
vue_
.
rg_
, &
this_n
, &
this_r
);

555 
decodePfixedSg
(
h
.
lod_
, oth.
vue_
.
rg_
, &
h_n
, &
h_r
);

556 
	gm_n
 = 
d
::
m
(
this_n
, 
h_n
);

557 
JSON_ASSERT
(
this_r
 && 
h_r
);

558 
	gcomp
 = 
memcmp
(
this_r
, 
h_r
, 
m_n
);

559 i(
	gcomp
 < 0 
	gue
;

560 i(
	gcomp
 > 0 
	gl
;

561  (
	gthis_n
 < 
	gh_n
);

563 
	gyVue
:

564 
objeVue
: {

565 
d
 = (
vue_
.
m_
->
size
(- 
h
.value_.map_->size());

566 i(
	gd
)

567  
	gd
 < 0;

568  (*
	gvue_
.
	gm_
< (*
	gh
.value_.map_);

571 
JSON_ASSERT_UNREACHABLE
;

573  
	gl
;

576 
bo
 
	gVue
::
ݔ
<=(cڡ 
Vue
& 
h
cڡ {  !(h < *
this
); }

578 
bo
 
	gVue
::
ݔ
>=(cڡ 
Vue
& 
h
cڡ {  !(*
this
 < other); }

580 
bo
 
	gVue
::
ݔ
>(cڡ 
Vue
& 
h
cڡ {  oth < *
this
; }

582 
bo
 
	gVue
::
ݔ
==(cڡ 
Vue
& 
h
) const {

587 
mp
 = 
h
.
ty_
;

588 i(
	gty_
 !
mp
)

589  
l
;

590 
	gty_
) {

591 
	gnuVue
:

592  
ue
;

593 
	gtVue
:

594  
vue_
.
t_
 =
h
.value_.int_;

595 
	gutVue
:

596  
vue_
.
ut_
 =
h
.value_.uint_;

597 
	gVue
:

598  
vue_
.
_
 =
h
.value_.real_;

599 
	gboޗnVue
:

600  
vue_
.
bo_
 =
h
.value_.bool_;

601 
	grgVue
:

603 i((
vue_
.
rg_
 =0|| (
h
.value_.string_ == 0)) {

604  (
vue_
.
rg_
 =
h
.value_.string_);

606 
	gthis_n
;

607 
	gh_n
;

608 cڡ* 
	gthis_r
;

609 cڡ* 
	gh_r
;

610 
decodePfixedSg
(
this
->
lod_
,his->
vue_
.
rg_
, &
this_n
, &
this_r
);

611 
decodePfixedSg
(
h
.
lod_
, oth.
vue_
.
rg_
, &
h_n
, &
h_r
);

612 i(
	gthis_n
 !
h_n
 
l
;

613 
JSON_ASSERT
(
this_r
 && 
h_r
);

614 
	gcomp
 = 
memcmp
(
this_r
, 
h_r
, 
this_n
);

615  
	gcomp
 == 0;

617 
	gyVue
:

618 
objeVue
:

619  
vue_
.
m_
->
size
(=
h
.value_.map_->size() &&

620 (*
vue_
.
m_
=(*
h
.value_.map_);

622 
JSON_ASSERT_UNREACHABLE
;

624  
	gl
;

627 
bo
 
	gVue
::
ݔ
!=(cڡ 
Vue
& 
h
cڡ {  !(*
this
 == other); }

629 cڡ * 
	gVue
::
asCSg
() const {

630 
JSON_ASSERT_MESSAGE
(
ty_
 =
rgVue
,

632 i(
	gvue_
.
	grg_
 == 0)  0;

633 
	gthis_n
;

634 cڡ* 
	gthis_r
;

635 
decodePfixedSg
(
this
->
lod_
,his->
vue_
.
rg_
, &
this_n
, &
this_r
);

636  
	gthis_r
;

639 #i
JSONCPP_USING_SECURE_MEMORY


640 
	gVue
::
gCSgLgth
() const {

641 
JSON_ASSERT_MESSAGE
(
ty_
 =
rgVue
,

643 i(
	gvue_
.
	grg_
 == 0)  0;

644 
	gthis_n
;

645 cڡ* 
	gthis_r
;

646 
decodePfixedSg
(
this
->
lod_
,his->
vue_
.
rg_
, &
this_n
, &
this_r
);

647  
	gthis_n
;

651 
bo
 
	gVue
::
gSg
(cڡ** 
r
, cڡ** 
nd
) const {

652 i(
	gty_
 !
rgVue
 
l
;

653 i(
	gvue_
.
	grg_
 =0 
l
;

654 
	gngth
;

655 
decodePfixedSg
(
this
->
lod_
,his->
vue_
.
rg_
, &
ngth
, 
r
);

656 *
	gnd
 = *
r
 + 
ngth
;

657  
	gue
;

660 
JSONCPP_STRING
 
	gVue
::
asSg
() const {

661 
ty_
) {

662 
nuVue
:

664 
	grgVue
:

666 i(
vue_
.
rg_
 == 0)  "";

667 
	gthis_n
;

668 cڡ* 
	gthis_r
;

669 
decodePfixedSg
(
this
->
lod_
,his->
vue_
.
rg_
, &
this_n
, &
this_r
);

670  
JSONCPP_STRING
(
this_r
, 
this_n
);

672 
	gboޗnVue
:

673  
vue_
.
bo_
 ? "true" : "false";

674 
	gtVue
:

675  
vueToSg
(
vue_
.
t_
);

676 
	gutVue
:

677  
vueToSg
(
vue_
.
ut_
);

678 
	gVue
:

679  
vueToSg
(
vue_
.
_
);

681 
JSON_FAIL_MESSAGE
("Type isot convertibleo string");

685 #ifde
JSON_USE_CPPTL


686 
	gCTL
::
CڡSg
 
Vue
::
asCڡSg
() const {

687 
n
;

688 cڡ* 
	gr
;

689 
decodePfixedSg
(
lod_
, 
vue_
.
rg_
,

690 &
n
, &
r
);

691  
	gCTL
::
CڡSg
(
r
, 
n
);

695 
	gVue
::
I
 
Vue
::
asI
() const {

696 
ty_
) {

697 
tVue
:

698 
JSON_ASSERT_MESSAGE
(
isI
(), "LargestInt out of Intange");

699  
I
(
vue_
.
t_
);

700 
	gutVue
:

701 
JSON_ASSERT_MESSAGE
(
isI
(), "LargestUInt out of Intange");

702  
I
(
vue_
.
ut_
);

703 
	gVue
:

704 
JSON_ASSERT_MESSAGE
(
InRge
(
vue_
.
_
, 
mI
, 
maxI
),

706  
I
(
vue_
.
_
);

707 
	gnuVue
:

709 
	gboޗnVue
:

710  
vue_
.
bo_
 ? 1 : 0;

714 
JSON_FAIL_MESSAGE
("Value isot convertibleo Int.");

717 
	gVue
::
UI
 
Vue
::
asUI
() const {

718 
ty_
) {

719 
tVue
:

720 
JSON_ASSERT_MESSAGE
(
isUI
(), "LargestInt out of UIntange");

721  
UI
(
vue_
.
t_
);

722 
	gutVue
:

723 
JSON_ASSERT_MESSAGE
(
isUI
(), "LargestUInt out of UIntange");

724  
UI
(
vue_
.
ut_
);

725 
	gVue
:

726 
JSON_ASSERT_MESSAGE
(
InRge
(
vue_
.
_
, 0, 
maxUI
),

728  
UI
(
vue_
.
_
);

729 
	gnuVue
:

731 
	gboޗnVue
:

732  
vue_
.
bo_
 ? 1 : 0;

736 
JSON_FAIL_MESSAGE
("Value isot convertibleo UInt.");

739 #i
defed
(
JSON_HAS_INT64
)

741 
	gVue
::
I64
 
Vue
::
asI64
() const {

742 
ty_
) {

743 
tVue
:

744  
I64
(
vue_
.
t_
);

745 
	gutVue
:

746 
JSON_ASSERT_MESSAGE
(
isI64
(), "LargestUInt out of Int64ange");

747  
I64
(
vue_
.
ut_
);

748 
	gVue
:

749 
JSON_ASSERT_MESSAGE
(
InRge
(
vue_
.
_
, 
mI64
, 
maxI64
),

751  
I64
(
vue_
.
_
);

752 
	gnuVue
:

754 
	gboޗnVue
:

755  
vue_
.
bo_
 ? 1 : 0;

759 
JSON_FAIL_MESSAGE
("Value isot convertibleo Int64.");

762 
	gVue
::
UI64
 
Vue
::
asUI64
() const {

763 
ty_
) {

764 
tVue
:

765 
JSON_ASSERT_MESSAGE
(
isUI64
(), "LargestInt out of UInt64ange");

766  
UI64
(
vue_
.
t_
);

767 
	gutVue
:

768  
UI64
(
vue_
.
ut_
);

769 
	gVue
:

770 
JSON_ASSERT_MESSAGE
(
InRge
(
vue_
.
_
, 0, 
maxUI64
),

772  
UI64
(
vue_
.
_
);

773 
	gnuVue
:

775 
	gboޗnVue
:

776  
vue_
.
bo_
 ? 1 : 0;

780 
JSON_FAIL_MESSAGE
("Value isot convertibleo UInt64.");

784 
LgeI
 
	gVue
::
asLgeI
() const {

785 #i
defed
(
JSON_NO_INT64
)

786  
asI
();

788  
asI64
();

792 
LgeUI
 
	gVue
::
asLgeUI
() const {

793 #i
defed
(
JSON_NO_INT64
)

794  
asUI
();

796  
asUI64
();

800 
	gVue
::
asDoub
() const {

801 
ty_
) {

802 
tVue
:

803  
ic_
<>(
vue_
.
t_
);

804 
	gutVue
:

805 #i!
defed
(
JSON_USE_INT64_DOUBLE_CONVERSION
)

806  
ic_
<>(
vue_
.
ut_
);

808  
gToDoub
(
vue_
.
ut_
);

810 
	gVue
:

811  
vue_
.
_
;

812 
	gnuVue
:

814 
	gboޗnVue
:

815  
vue_
.
bo_
 ? 1.0 : 0.0;

819 
JSON_FAIL_MESSAGE
("Value isot convertibleo double.");

822 
	gVue
::
asFlt
() const {

823 
ty_
) {

824 
tVue
:

825  
ic_
<>(
vue_
.
t_
);

826 
	gutVue
:

827 #i!
defed
(
JSON_USE_INT64_DOUBLE_CONVERSION
)

828  
ic_
<>(
vue_
.
ut_
);

831  
	gic_
<>(
gToDoub
(
vue_
.
ut_
));

833 
	gVue
:

834  
ic_
<>(
vue_
.
_
);

835 
	gnuVue
:

837 
	gboޗnVue
:

838  
vue_
.
bo_
 ? 1.0f : 0.0f;

842 
JSON_FAIL_MESSAGE
("Value isot convertibleo float.");

845 
bo
 
	gVue
::
asBo
() const {

846 
ty_
) {

847 
boޗnVue
:

848  
vue_
.
bo_
;

849 
	gnuVue
:

850  
l
;

851 
	gtVue
:

852  
vue_
.
t_
 ? 
ue
 : 
l
;

853 
	gutVue
:

854  
vue_
.
ut_
 ? 
ue
 : 
l
;

855 
	gVue
:

857  (
vue_
.
_
 !0.0? 
ue
 : 
l
;

861 
JSON_FAIL_MESSAGE
("Value isot convertibleo bool.");

864 
bo
 
	gVue
::
isCvtibTo
(
VueTy
 
h
) const {

865 
h
) {

866 
nuVue
:

867  (
isNumic
(&& 
asDoub
() == 0.0) ||

868 (
ty_
 =
boޗnVue
 && 
vue_
.
bo_
 =
l
) ||

869 (
ty_
 =
rgVue
 && 
asSg
() == "") ||

870 (
ty_
 =
yVue
 && 
vue_
.
m_
->
size
() == 0) ||

871 (
ty_
 =
objeVue
 && 
vue_
.
m_
->
size
() == 0) ||

872 
ty_
 =
nuVue
;

873 
	gtVue
:

874  
isI
() ||

875 (
ty_
 =
Vue
 && 
InRge
(
vue_
.
_
, 
mI
, 
maxI
)) ||

876 
	gty_
 =
boޗnVue
 || 
ty_
 =
nuVue
;

877 
	gutVue
:

878  
isUI
() ||

879 (
ty_
 =
Vue
 && 
InRge
(
vue_
.
_
, 0, 
maxUI
)) ||

880 
	gty_
 =
boޗnVue
 || 
ty_
 =
nuVue
;

881 
	gVue
:

882  
isNumic
(|| 
ty_
 =
boޗnVue
 ||y_ =
nuVue
;

883 
	gboޗnVue
:

884  
isNumic
(|| 
ty_
 =
boޗnVue
 ||y_ =
nuVue
;

885 
	grgVue
:

886  
isNumic
(|| 
ty_
 =
boޗnVue
 ||y_ =
rgVue
 ||

887 
ty_
 =
nuVue
;

888 
	gyVue
:

889  
ty_
 =
yVue
 ||y_ =
nuVue
;

890 
	gobjeVue
:

891  
ty_
 =
objeVue
 ||y_ =
nuVue
;

893 
	gJSON_ASSERT_UNREACHABLE
;

894  
	gl
;

898 
AayIndex
 
	gVue
::
size
() const {

899 
ty_
) {

900 
nuVue
:

901 
tVue
:

902 
utVue
:

903 
Vue
:

904 
boޗnVue
:

905 
rgVue
:

907 
	gyVue
:

908 i(!
vue_
.
m_
->
emy
()) {

909 
ObjeVues
::
cڡ_
 
La
 = 
vue_
.
m_
->
d
();

910 --
	gLa
;

911  (*
	gLa
).
	gf
.
dex
() + 1;

914 
	gobjeVue
:

915  
AayIndex
(
vue_
.
m_
->
size
());

917 
	gJSON_ASSERT_UNREACHABLE
;

921 
bo
 
	gVue
::
emy
() const {

922 i(
isNu
(|| 
isAay
(|| 
isObje
())

923  
size
() == 0u;

925  
	gl
;

928 
bo
 
	gVue
::
ݔ
!(cڡ {  
isNu
(); }

930 
	gVue
::
r
() {

931 
JSON_ASSERT_MESSAGE
(
ty_
 =
nuVue
 ||y_ =
yVue
 ||

932 
ty_
 =
objeVue
,

934 
	gt_
 = 0;

935 
	glim_
 = 0;

936 
	gty_
) {

937 
	gyVue
:

938 
objeVue
:

939 
vue_
.
m_
->
r
();

946 
	gVue
::
size
(
AayIndex
 
wSize
) {

947 
JSON_ASSERT_MESSAGE
(
ty_
 =
nuVue
 ||y_ =
yVue
,

949 i(
	gty_
 =
nuVue
)

950 *
this
 = 
Vue
(
yVue
);

951 
AayIndex
 
	gdSize
 = 
size
();

952 i(
	gwSize
 == 0)

953 
r
();

954 i(
	gwSize
 > 
	gdSize
)

955 (*
	gthis
)[
wSize
 - 1];

957 
AayIndex
 
	gdex
 = 
wSize
; index < 
	gdSize
; ++index) {

958 
	gvue_
.
	gm_
->
a
(
dex
);

960 
JSON_ASSERT
(
size
(=
wSize
);

964 
	gVue
& Vue::
ݔ
[](
AayIndex
 
dex
) {

965 
JSON_ASSERT_MESSAGE
(

966 
ty_
 =
nuVue
 ||y_ =
yVue
,

968 i(
	gty_
 =
nuVue
)

969 *
this
 = 
Vue
(
yVue
);

970 
CZSg
 
key
(
dex
);

971 
	gObjeVues
::

 

 = 
vue_
.
m_
->
low_bound
(
key
);

972 i(
	g
 !
vue_
.
m_
->
d
(&& (*

).
f
 =
key
)

973  (*

).
cd
;

975 
	gObjeVues
::
vue_ty
 
deuVue
(
key
, 
nuRef
);

976 
	g
 = 
vue_
.
m_
->

(

, 
deuVue
);

977  (*
	g
).
	gcd
;

980 
	gVue
& Vue::
ݔ
[](
dex
) {

981 
JSON_ASSERT_MESSAGE
(

982 
dex
 >= 0,

984  (*
	gthis
)[
AayIndex
(
dex
)];

987 cڡ 
	gVue
& Vue::
ݔ
[](
AayIndex
 
dex
) const {

988 
JSON_ASSERT_MESSAGE
(

989 
ty_
 =
nuVue
 ||y_ =
yVue
,

991 i(
	gty_
 =
nuVue
)

992  
nuRef
;

993 
CZSg
 
key
(
dex
);

994 
	gObjeVues
::
cڡ_
 

 = 
vue_
.
m_
->
fd
(
key
);

995 i(
	g
 =
vue_
.
m_
->
d
())

996  
nuRef
;

997  (*
	g
).
	gcd
;

1000 cڡ 
	gVue
& Vue::
ݔ
[](
dex
) const {

1001 
JSON_ASSERT_MESSAGE
(

1002 
dex
 >= 0,

1004  (*
	gthis
)[
AayIndex
(
dex
)];

1007 
	gVue
::
Basic
(
VueTy
 
vty
, 
bo
 
lod
) {

1008 
	gty_
 = 
vty
;

1009 
	glod_
 = 
lod
;

1010 
	gcommts_
 = 0;

1011 
	gt_
 = 0;

1012 
	glim_
 = 0;

1018 
	gVue
& Vue::
sveRen
(cڡ * 
key
) {

1019 
JSON_ASSERT_MESSAGE
(

1020 
ty_
 =
nuVue
 ||y_ =
objeVue
,

1022 i(
	gty_
 =
nuVue
)

1023 *
this
 = 
Vue
(
objeVue
);

1024 
CZSg
 
auKey
(

1025 
key
, 
ic_
<>(

(key)), 
CZSg
::
noDuiti
);

1026 
	gObjeVues
::

 

 = 
vue_
.
m_
->
low_bound
(
auKey
);

1027 i(
	g
 !
vue_
.
m_
->
d
(&& (*

).
f
 =
auKey
)

1028  (*

).
cd
;

1030 
	gObjeVues
::
vue_ty
 
deuVue
(
auKey
, 
nuRef
);

1031 
	g
 = 
vue_
.
m_
->

(

, 
deuVue
);

1032 
	gVue
& 
	gvue
 = (*

).
cd
;

1033  
	gvue
;

1037 
	gVue
& Vue::
sveRen
(cڡ* 
key
, cڡ* 
nd
)

1039 
JSON_ASSERT_MESSAGE
(

1040 
ty_
 =
nuVue
 ||y_ =
objeVue
,

1042 i(
	gty_
 =
nuVue
)

1043 *
this
 = 
Vue
(
objeVue
);

1044 
CZSg
 
auKey
(

1045 
key
, 
ic_
<>(
nd
-key), 
CZSg
::
duiOnCy
);

1046 
	gObjeVues
::

 

 = 
vue_
.
m_
->
low_bound
(
auKey
);

1047 i(
	g
 !
vue_
.
m_
->
d
(&& (*

).
f
 =
auKey
)

1048  (*

).
cd
;

1050 
	gObjeVues
::
vue_ty
 
deuVue
(
auKey
, 
nuRef
);

1051 
	g
 = 
vue_
.
m_
->

(

, 
deuVue
);

1052 
	gVue
& 
	gvue
 = (*

).
cd
;

1053  
	gvue
;

1056 
Vue
 
	gVue
::
g
(
AayIndex
 
dex
, cڡ Vue& 
deuVue
) const {

1057 cڡ 
Vue
* 
	gvue
 = &((*
this
)[
dex
]);

1058  
	gvue
 =&
nuRef
 ? 
deuVue
 : *
vue
;

1061 
bo
 
	gVue
::
isVidIndex
(
AayIndex
 
dex
cڡ {  index < 
size
(); }

1063 
Vue
 cڡ* 
	gVue
::
fd
(cڡ* 
key
, cڡ* 
nd
) const

1065 
JSON_ASSERT_MESSAGE
(

1066 
ty_
 =
nuVue
 ||y_ =
objeVue
,

1068 i(
	gty_
 =
nuVue
 
NULL
;

1069 
CZSg
 
auKey
(
key
, 
ic_
<>(
nd
-key), CZSg::
noDuiti
);

1070 
	gObjeVues
::
cڡ_
 

 = 
vue_
.
m_
->
fd
(
auKey
);

1071 i(
	g
 =
vue_
.
m_
->
d
() 
NULL
;

1072  &(*
	g
).
	gcd
;

1074 cڡ 
	gVue
& Vue::
ݔ
[](cڡ * 
key
) const

1076 
Vue
 cڡ* 
found
 = 
fd
(
key
, key + 

(key));

1077 i(!
	gfound
 
	gnuRef
;

1078  *
	gfound
;

1080 
Vue
 cڡ& 
	gVue
::
ݔ
[](
JSONCPP_STRING
 cڡ& 
key
) const

1082 
Vue
 cڡ* 
found
 = 
fd
(
key
.
da
(), key.da(+ key.
ngth
());

1083 i(!
	gfound
 
	gnuRef
;

1084  *
	gfound
;

1087 
	gVue
& Vue::
ݔ
[](cڡ * 
key
) {

1088  
sveRen
(
key
, key + 

(key));

1091 
	gVue
& Vue::
ݔ
[](cڡ 
JSONCPP_STRING
& 
key
) {

1092  
sveRen
(
key
.
da
(), key.da(+ key.
ngth
());

1095 
	gVue
& Vue::
ݔ
[](cڡ 
SticSg
& 
key
) {

1096  
sveRen
(
key
.
c_r
());

1099 #ifde
JSON_USE_CPPTL


1100 
	gVue
& Vue::
ݔ
[](cڡ 
CTL
::
CڡSg
& 
key
) {

1101  
sveRen
(
key
.
c_r
(), key.
d_c_r
());

1103 
Vue
 cڡ& 
	gVue
::
ݔ
[](
CTL
::
CڡSg
 cڡ& 
key
) const

1105 
Vue
 cڡ* 
found
 = 
fd
(
key
.
c_r
(), key.
d_c_r
());

1106 i(!
	gfound
 
	gnuRef
;

1107  *
	gfound
;

1111 
	gVue
& Vue::
nd
(cڡ 
Vue
& 
vue
{  (*
this
)[
size
()] = value; }

1113 
Vue
 
	gVue
::
g
(cڡ* 
key
, cڡ* 
nd
, Vucڡ& 
deuVue
) const

1115 
Vue
 cڡ* 
	gfound
 = 
fd
(
key
, 
nd
);

1116  !
	gfound
 ? 
	gdeuVue
 : *
found
;

1118 
Vue
 
	gVue
::
g
(cڡ* 
key
, Vucڡ& 
deuVue
) const

1120  
g
(
key
, key + 

(key), 
deuVue
);

1122 
Vue
 
	gVue
::
g
(
JSONCPP_STRING
 cڡ& 
key
, Vucڡ& 
deuVue
) const

1124  
g
(
key
.
da
(), key.da(+ key.
ngth
(), 
deuVue
);

1128 
bo
 
	gVue
::
moveMemb
(cڡ * 
key
, cڡ * 
nd
, 
Vue
* 
moved
)

1130 i(
	gty_
 !
objeVue
) {

1131  
l
;

1133 
CZSg
 
auKey
(
key
, 
ic_
<>(
nd
-key), CZSg::
noDuiti
);

1134 
	gObjeVues
::

 

 = 
vue_
.
m_
->
fd
(
auKey
);

1135 i(
	g
 =
vue_
.
m_
->
d
())

1136  
l
;

1137 *
	gmoved
 = 

->
cd
;

1138 
	gvue_
.
	gm_
->
a
(

);

1139  
	gue
;

1141 
bo
 
	gVue
::
moveMemb
(cڡ * 
key
, 
Vue
* 
moved
)

1143  
moveMemb
(
key
, key + 

(key), 
moved
);

1145 
bo
 
	gVue
::
moveMemb
(
JSONCPP_STRING
 cڡ& 
key
, 
Vue
* 
moved
)

1147  
moveMemb
(
key
.
da
(), key.da(+ key.
ngth
(), 
moved
);

1149 
Vue
 
	gVue
::
moveMemb
(cڡ * 
key
)

1151 
JSON_ASSERT_MESSAGE
(
ty_
 =
nuVue
 ||y_ =
objeVue
,

1153 i(
	gty_
 =
nuVue
)

1154  
nuRef
;

1156 
Vue
 
	gmoved
;

1157 
moveMemb
(
key
, key + 

(key), &
moved
);

1158  
	gmoved
;

1160 
Vue
 
	gVue
::
moveMemb
(cڡ 
JSONCPP_STRING
& 
key
)

1162  
moveMemb
(
key
.
c_r
());

1165 
bo
 
	gVue
::
moveIndex
(
AayIndex
 
dex
, 
Vue
* 
moved
) {

1166 i(
	gty_
 !
yVue
) {

1167  
l
;

1169 
CZSg
 
key
(
dex
);

1170 
	gObjeVues
::

 

 = 
vue_
.
m_
->
fd
(
key
);

1171 i(
	g
 =
vue_
.
m_
->
d
()) {

1172  
l
;

1174 *
	gmoved
 = 

->
cd
;

1175 
AayIndex
 
	gdSize
 = 
size
();

1177 
AayIndex
 
	gi
 = 
dex
; i < (
	gdSize
 - 1); ++i){

1178 
CZSg
 
ky
(
i
);

1179 (*
	gvue_
.
	gm_
)[
ky
] = (*
this
)[
i
 + 1];

1182 
CZSg
 
keyLa
(
dSize
 - 1);

1183 
	gObjeVues
::

 
La
 = 
vue_
.
m_
->
fd
(
keyLa
);

1184 
	gvue_
.
	gm_
->
a
(
La
);

1185  
	gue
;

1188 #ifde
JSON_USE_CPPTL


1189 
Vue
 
	gVue
::
g
(cڡ 
CTL
::
CڡSg
& 
key
,

1190 cڡ 
Vue
& 
deuVue
) const {

1191  
g
(
key
.
c_r
(), key.
d_c_r
(), 
deuVue
);

1195 
bo
 
	gVue
::
isMemb
(cڡ* 
key
, cڡ* 
nd
) const

1197 
Vue
 cڡ* 
	gvue
 = 
fd
(
key
, 
nd
);

1198  
	gNULL
 !
vue
;

1200 
bo
 
	gVue
::
isMemb
(cڡ* 
key
) const

1202  
isMemb
(
key
, key + 

(key));

1204 
bo
 
	gVue
::
isMemb
(
JSONCPP_STRING
 cڡ& 
key
) const

1206  
isMemb
(
key
.
da
(), key.da(+ key.
ngth
());

1209 #ifde
JSON_USE_CPPTL


1210 
bo
 
	gVue
::
isMemb
(cڡ 
CTL
::
CڡSg
& 
key
) const {

1211  
isMemb
(
key
.
c_r
(), key.
d_c_r
());

1215 
	gVue
::
Membs
 
Vue
::
gMembNames
() const {

1216 
JSON_ASSERT_MESSAGE
(

1217 
ty_
 =
nuVue
 ||y_ =
objeVue
,

1219 i(
	gty_
 =
nuVue
)

1220  
Vue
::
Membs
();

1221 
Membs
 
	gmembs
;

1222 
	gmembs
.
rve
(
vue_
.
m_
->
size
());

1223 
	gObjeVues
::
cڡ_
 

 = 
vue_
.
m_
->
beg
();

1224 
	gObjeVues
::
cڡ_
 
End
 = 
vue_
.
m_
->
d
();

1225 ; 
	g
 !
End
; ++it) {

1226 
	gmembs
.
push_back
(
JSONCPP_STRING
((*

).
f
.
da
(),

1227 (*

).
f
.
ngth
()));

1229  
	gmembs
;

1257 
bo
 
IsIegl
(
d
) {

1258 
	ggl_
;

1259  
modf
(
d
, &
gl_
) == 0.0;

1262 
bo
 
	gVue
::
isNu
(cڡ {  
ty_
 =
nuVue
; }

1264 
bo
 
	gVue
::
isBo
(cڡ {  
ty_
 =
boޗnVue
; }

1266 
bo
 
	gVue
::
isI
() const {

1267 
ty_
) {

1268 
tVue
:

1269  
vue_
.
t_
 >
mI
 && vue_.t_ <
maxI
;

1270 
	gutVue
:

1271  
vue_
.
ut_
 <
UI
(
maxI
);

1272 
	gVue
:

1273  
vue_
.
_
 >
mI
 && vue_._ <
maxI
 &&

1274 
IsIegl
(
vue_
.
_
);

1278  
	gl
;

1281 
bo
 
	gVue
::
isUI
() const {

1282 
ty_
) {

1283 
tVue
:

1284  
vue_
.
t_
 >0 && 
LgeUI
(vue_.t_<LgeUI(
maxUI
);

1285 
	gutVue
:

1286  
vue_
.
ut_
 <
maxUI
;

1287 
	gVue
:

1288  
vue_
.
_
 >0 && vue_._ <
maxUI
 &&

1289 
IsIegl
(
vue_
.
_
);

1293  
	gl
;

1296 
bo
 
	gVue
::
isI64
() const {

1297 #i
defed
(
JSON_HAS_INT64
)

1298 
ty_
) {

1299 
tVue
:

1300  
ue
;

1301 
	gutVue
:

1302  
vue_
.
ut_
 <
UI64
(
maxI64
);

1303 
	gVue
:

1307  
vue_
.
_
 >(
mI64
) &&

1308 
vue_
.
_
 < (
maxI64
&& 
IsIegl
(value_.real_);

1313  
	gl
;

1316 
bo
 
	gVue
::
isUI64
() const {

1317 #i
defed
(
JSON_HAS_INT64
)

1318 
ty_
) {

1319 
tVue
:

1320  
vue_
.
t_
 >= 0;

1321 
	gutVue
:

1322  
ue
;

1323 
	gVue
:

1327  
vue_
.
_
 >0 && vue_._ < 
maxUI64AsDoub
 &&

1328 
IsIegl
(
vue_
.
_
);

1333  
	gl
;

1336 
bo
 
	gVue
::
isIegl
() const {

1337 #i
defed
(
JSON_HAS_INT64
)

1338  
isI64
(|| 
isUI64
();

1340  
isI
(|| 
isUI
();

1344 
bo
 
	gVue
::
isDoub
(cڡ {  
ty_
 =
Vue
 || 
isIegl
(); }

1346 
bo
 
	gVue
::
isNumic
(cڡ {  
isIegl
(|| 
isDoub
(); }

1348 
bo
 
	gVue
::
isSg
(cڡ {  
ty_
 =
rgVue
; }

1350 
bo
 
	gVue
::
isAay
(cڡ {  
ty_
 =
yVue
; }

1352 
bo
 
	gVue
::
isObje
(cڡ {  
ty_
 =
objeVue
; }

1354 
	gVue
::
tCommt
(cڡ * 
commt
, 
size_t
 
n
, 
CommtPmt
 
amt
) {

1355 i(!
	gcommts_
)

1356 
	gcommts_
 = 
w
 
CommtInfo
[
numbOfCommtPmt
];

1357 i((
	gn
 > 0&& (
	gcommt
[
n
-1] == '\n')) {

1359 
n
 -= 1;

1361 
	gcommts_
[
amt
].
tCommt
(
commt
, 
n
);

1364 
	gVue
::
tCommt
(cڡ * 
commt
, 
CommtPmt
 
amt
) {

1365 
tCommt
(
commt
, 

(commt), 
amt
);

1368 
	gVue
::
tCommt
(cڡ 
JSONCPP_STRING
& 
commt
, 
CommtPmt
 
amt
) {

1369 
tCommt
(
commt
.
c_r
(), commt.
ngth
(), 
amt
);

1372 
bo
 
	gVue
::
hasCommt
(
CommtPmt
 
amt
) const {

1373  
commts_
 !0 && commts_[
amt
].
commt_
 != 0;

1376 
JSONCPP_STRING
 
	gVue
::
gCommt
(
CommtPmt
 
amt
) const {

1377 i(
hasCommt
(
amt
))

1378  
commts_
[
amt
].
commt_
;

1382 
	gVue
::
tOfftS
(
rdiff_t
 
t
{ 
t_
 = start; }

1384 
	gVue
::
tOfftLim
(
rdiff_t
 
lim
{ 
lim_
 =imit; }

1386 
rdiff_t
 
	gVue
::
gOfftS
(cڡ {  
t_
; }

1388 
rdiff_t
 
	gVue
::
gOfftLim
(cڡ {  
lim_
; }

1390 
JSONCPP_STRING
 
	gVue
::
toStydSg
() const {

1391 
StydWr
 
wr
;

1392  
	gwr
.
wre
(*
this
);

1395 
	gVue
::
cڡ_
 
Vue
::
beg
() const {

1396 
ty_
) {

1397 
yVue
:

1398 
objeVue
:

1399 i(
vue_
.
m_
)

1400  
cڡ_
(
vue_
.
m_
->
beg
());

1405  
cڡ_
();

1408 
	gVue
::
cڡ_
 
Vue
::
d
() const {

1409 
ty_
) {

1410 
yVue
:

1411 
objeVue
:

1412 i(
vue_
.
m_
)

1413  
cڡ_
(
vue_
.
m_
->
d
());

1418  
cڡ_
();

1421 
	gVue
::

 
Vue
::
beg
() {

1422 
ty_
) {

1423 
yVue
:

1424 
objeVue
:

1425 i(
vue_
.
m_
)

1426  

(
vue_
.
m_
->
beg
());

1431  

();

1434 
	gVue
::

 
Vue
::
d
() {

1435 
ty_
) {

1436 
yVue
:

1437 
objeVue
:

1438 i(
vue_
.
m_
)

1439  

(
vue_
.
m_
->
d
());

1444  

();

1450 
	gPhArgumt
::
PhArgumt
(: 
key_
(), 
dex_
(), 
kd_
(
kdNe
) {}

1452 
	gPhArgumt
::
PhArgumt
(
AayIndex
 
dex
)

1453 : 
key_
(), 
dex_
(
dex
), 
kd_
(
kdIndex
) {}

1455 
	gPhArgumt
::
PhArgumt
(cڡ * 
key
)

1456 : 
key_
(
key
), 
dex_
(), 
kd_
(
kdKey
) {}

1458 
	gPhArgumt
::
PhArgumt
(cڡ 
JSONCPP_STRING
& 
key
)

1459 : 
key_
(
key
.
c_r
()), 
dex_
(), 
kd_
(
kdKey
) {}

1464 
	gPh
::
Ph
(cڡ 
JSONCPP_STRING
& 
th
,

1465 cڡ 
PhArgumt
& 
a1
,

1466 cڡ 
PhArgumt
& 
a2
,

1467 cڡ 
PhArgumt
& 
a3
,

1468 cڡ 
PhArgumt
& 
a4
,

1469 cڡ 
PhArgumt
& 
a5
) {

1470 
InArgs
 
	g
;

1471 
	g
.
push_back
(&
a1
);

1472 
	g
.
push_back
(&
a2
);

1473 
	g
.
push_back
(&
a3
);

1474 
	g
.
push_back
(&
a4
);

1475 
	g
.
push_back
(&
a5
);

1476 
makePh
(
th
, 

);

1479 
	gPh
::
makePh
(cڡ 
JSONCPP_STRING
& 
th
, cڡ 
InArgs
& 

) {

1480 cڡ * 
	gcut
 = 
th
.
c_r
();

1481 cڡ * 
	gd
 = 
cut
 + 
th
.
ngth
();

1482 
	gInArgs
::
cڡ_
 
InArg
 = 

.
beg
();

1483 
	gcut
 !
d
) {

1484 i(*
cut
 == '[') {

1485 ++
cut
;

1486 i(*
	gcut
 == '%')

1487 
addPhInArg
(
th
, 

, 
InArg
, 
PhArgumt
::
kdIndex
);

1489 
AayIndex
 
	gdex
 = 0;

1490 ; 
	gcut
 !
d
 && *
cut
 >= '0' && *current <= '9'; ++current)

1491 
	gdex
 = 
dex
 * 10 + 
AayIndex
(*
cut
 - '0');

1492 
	ggs_
.
push_back
(
dex
);

1494 i(
	gcut
 =
d
 || *
cut
++ != ']')

1495 
vidPh
(
th
, (
cut
 -h.
c_r
()));

1496 } i(*
	gcut
 == '%') {

1497 
addPhInArg
(
th
, 

, 
InArg
, 
PhArgumt
::
kdKey
);

1498 ++
	gcut
;

1499 } i(*
	gcut
 == '.') {

1500 ++
cut
;

1502 cڡ * 
	gbegName
 = 
cut
;

1503 
	gcut
 !
d
 && !
rchr
("[.", *
cut
))

1504 ++
	gcut
;

1505 
	ggs_
.
push_back
(
JSONCPP_STRING
(
begName
, 
cut
));

1510 
	gPh
::
addPhInArg
(cڡ 
JSONCPP_STRING
& ,

1511 cڡ 
InArgs
& 

,

1512 
InArgs
::
cڡ_
& 
InArg
,

1513 
PhArgumt
::
Kd
 
kd
) {

1514 i(
InArg
 =

.
d
()) {

1516 } i((*
InArg
)->
kd_
 !
kd
) {

1519 
gs_
.
push_back
(**
InArg
);

1523 
	gPh
::
vidPh
(cڡ 
JSONCPP_STRING
& , ) {

1527 cڡ 
	gVue
& 
	gPh
::
sve
(cڡ 
Vue
& 
ro
) const {

1528 cڡ 
Vue
* 
node
 = &
ro
;

1529 
	gArgs
::
cڡ_
 

 = 
gs_
.
beg
(); 
	g
 !gs_.
d
(); ++it) {

1530 cڡ 
	gPhArgumt
& 
	gg
 = *

;

1531 i(
	gg
.
	gkd_
 =
PhArgumt
::
kdIndex
) {

1532 i(!
node
->
isAay
(|| !node->
isVidIndex
(
g
.
dex_
)) {

1535 
node
 = &((*node)[
g
.
dex_
]);

1536 } i(
	gg
.
	gkd_
 =
PhArgumt
::
kdKey
) {

1537 i(!
node
->
isObje
()) {

1540 
node
 = &((*node)[
g
.
key_
]);

1541 i(
	gnode
 =&
Vue
::
nuRef
) {

1547  *
node
;

1550 
Vue
 
	gPh
::
sve
(cڡ Vue& 
ro
, cڡ Vue& 
deuVue
) const {

1551 cڡ 
Vue
* 
	gnode
 = &
ro
;

1552 
	gArgs
::
cڡ_
 

 = 
gs_
.
beg
(); 
	g
 !gs_.
d
(); ++it) {

1553 cڡ 
	gPhArgumt
& 
	gg
 = *

;

1554 i(
	gg
.
	gkd_
 =
PhArgumt
::
kdIndex
) {

1555 i(!
node
->
isAay
(|| !node->
isVidIndex
(
g
.
dex_
))

1556  
deuVue
;

1557 
	gnode
 = &((*
node
)[
g
.
dex_
]);

1558 } i(
	gg
.
	gkd_
 =
PhArgumt
::
kdKey
) {

1559 i(!
node
->
isObje
())

1560  
deuVue
;

1561 
	gnode
 = &((*
node
)[
g
.
key_
]);

1562 i(
	gnode
 =&
Vue
::
nuRef
)

1563  
deuVue
;

1566  *
	gnode
;

1569 
	gVue
& 
	gPh
::
make
(
Vue
& 
ro
) const {

1570 
Vue
* 
node
 = &
ro
;

1571 
	gArgs
::
cڡ_
 

 = 
gs_
.
beg
(); 
	g
 !gs_.
d
(); ++it) {

1572 cڡ 
	gPhArgumt
& 
	gg
 = *

;

1573 i(
	gg
.
	gkd_
 =
PhArgumt
::
kdIndex
) {

1574 i(!
node
->
isAay
()) {

1577 
node
 = &((*node)[
g
.
dex_
]);

1578 } i(
	gg
.
	gkd_
 =
PhArgumt
::
kdKey
) {

1579 i(!
node
->
isObje
()) {

1582 
node
 = &((*node)[
g
.
key_
]);

1585  *
	gnode
;

	@open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_writer.cpp

6 #i!
defed
(
JSON_IS_AMALGAMATION
)

7 
	~<js/wr.h
>

8 
	~"js_to.h
"

10 
	~<iom
>

11 
	~<memy
>

12 
	~<sam
>

13 
	~<uty
>

14 
	~<t
>

15 
	~<s
>

16 
	~<crg
>

17 
	~<cdio
>

19 #i
defed
(
_MSC_VER
) && _MSC_VER >= 1200 && _MSC_VER < 1800

20 
	~<t.h
>

21 
	#isfe
 
_fe


	)

22 #i
defed
(
__sun
&& defed(
__SVR4
)

23 #i!
defed
(
isfe
)

24 
	~<.h
>

25 
	#isfe
 
fe


	)

27 #i
defed
(
_AIX
)

28 #i!
defed
(
isfe
)

29 
	~<mh.h
>

30 
	#isfe
 
fe


	)

32 #i
defed
(
__hpux
)

33 #i!
defed
(
isfe
)

34 #i
defed
(
__64
&& !defed(
fe
)

35 
	#isfe
(
x
) (((x) == () ? \

36 
	`_Isfef
(
x
: 
	`_IsFe
(x)))

	)

38 
	~<mh.h
>

39 
	#isfe
 
fe


	)

43 
	~<cmh
>

44 #i!(
defed
(
__QNXNTO__
))

45 
	#isfe
 
d
::
isfe


	)

49 #i
defed
(
_MSC_VER
)

50 #i!
defed
(
WINCE
&& defed(
__STDC_SECURE_LIB__
&& 
_MSC_VER
 >= 1500

51 
	#tf
 
rtf_s


	)

52 #i
_MSC_VER
 >= 1900

53 
	#tf
 
d
::
tf


	)

55 
	#tf
 
_tf


	)

57 #i
defed
(
__ANDROID__
|| defed(
__QNXNTO__
)

58 
	#tf
 
tf


	)

59 #i
__lulus
 >= 201103L

60 #i!
defed
(
__MINGW32__
&& !defed(
__CYGWIN__
)

61 
	#tf
 
d
::
tf


	)

65 #i
defed
(
__BORLANDC__
)

66 
	~<t.h
>

67 
	#isfe
 
_fe


	)

68 
	#tf
 
_tf


	)

71 #i
defed
(
_MSC_VER
) && _MSC_VER >= 1400

73 #agm
wng
(
dib
 : 4996)

76 
mea
 
	gJs
 {

78 #i
__lulus
 >201103L || (
defed
(
_CPPLIB_VER
) && _CPPLIB_VER >= 520)

79 
	gd
::
	tunique_r
<
	tSmWr
> 
	tSmWrP
;

81 
	gd
::
	tauto_r
<
	tSmWr
> 
	tSmWrP
;

84 
bo
 
cڏsCڌCha
(cڡ * 
r
) {

85 *
	gr
) {

86 i(
isCڌCha
(*(
r
++)))

87  
	gue
;

89  
	gl
;

92 
bo
 
cڏsCڌCha0
(cڡ * 
r
, 
n
) {

93 cڡ* 
	gd
 = 
r
 + 
n
;

94 
	gd
 !
r
) {

95 i(
isCڌCha
(*
r
) || 0==*str)

96  
ue
;

97 ++
	gr
;

99  
	gl
;

102 
JSONCPP_STRING
 
vueToSg
(
LgeI
 
vue
) {

103 
UIToSgBufr
 
	gbufr
;

104 * 
	gcut
 = 
bufr
 + (buffer);

105 i(
	gvue
 =
Vue
::
mLgeI
) {

106 
utToSg
(
LgeUI
(
Vue
::
maxLgeI
+ 1, 
cut
);

107 *--
	gcut
 = '-';

108 } i(
	gvue
 < 0) {

109 
utToSg
(
LgeUI
(-
vue
), 
cut
);

110 *--
	gcut
 = '-';

112 
utToSg
(
LgeUI
(
vue
), 
cut
);

114 
as
(
cut
 >
bufr
);

115  
	gcut
;

118 
JSONCPP_STRING
 
vueToSg
(
LgeUI
 
vue
) {

119 
UIToSgBufr
 
	gbufr
;

120 * 
	gcut
 = 
bufr
 + (buffer);

121 
utToSg
(
vue
, 
cut
);

122 
as
(
cut
 >
bufr
);

123  
	gcut
;

126 #i
defed
(
JSON_HAS_INT64
)

128 
JSONCPP_STRING
 
vueToSg
(
I
 
vue
) {

129  
vueToSg
(
LgeI
(
vue
));

132 
JSONCPP_STRING
 
vueToSg
(
UI
 
vue
) {

133  
vueToSg
(
LgeUI
(
vue
));

138 
JSONCPP_STRING
 
vueToSg
(
vue
, 
bo
 
uSclFlts
, 
ecisi
) {

141 
	gbufr
[32];

142 
	gn
 = -1;

144 
	gfmSg
[6];

145 
rtf
(
fmSg
, "%%.%dg", 
ecisi
);

150 i(
isfe
(
vue
)) {

151 
	gn
 = 
tf
(
bufr
, (bufr), 
fmSg
, 
vue
);

154 i(
	gvue
 !
vue
) {

155 
n
 = 
tf
(
bufr
, (bufr), 
uSclFlts
 ? "NaN" : "null");

156 } i(
	gvue
 < 0) {

157 
	gn
 = 
tf
(
bufr
, (bufr), 
uSclFlts
 ? "-Infinity" : "-1e+9999");

159 
	gn
 = 
tf
(
bufr
, (bufr), 
uSclFlts
 ? "Infinity" : "1e+9999");

163 
as
(
n
 >= 0);

164 
fixNumicLo
(
bufr
, buf+ 
n
);

165  
	gbufr
;

168 
JSONCPP_STRING
 
vueToSg
(
vue
{  vueToSg(vue, 
l
, 17); }

170 
JSONCPP_STRING
 
vueToSg
(
bo
 
vue
{  
	gvue
 ? "true" : "false"; }

172 
JSONCPP_STRING
 
vueToQuedSg
(cڡ * 
vue
) {

173 i(
	gvue
 =
NULL
)

176 i(
brk
(
vue
, "\"\\\b\f\n\r\t"=
NULL
 &&

177 !
cڏsCڌCha
(
vue
))

178  
JSONCPP_STRING
("\""+ 
vue
 + "\"";

182 
	gJSONCPP_STRING
::
size_ty
 
maxsize
 =

183 

(
vue
) * 2 + 3;

184 
JSONCPP_STRING
 
	gsu
;

185 
	gsu
.
rve
(
maxsize
);

186 
	gsu
 += "\"";

187 cڡ * 
	gc
 = 
vue
; *c != 0; ++c) {

188 *
	gc
) {

190 
su
 += "\\\"";

193 
su
 += "\\\\";

196 
su
 += "\\b";

199 
su
 += "\\f";

202 
su
 += "\\n";

205 
su
 += "\\r";

208 
su
 += "\\t";

219 i(
isCڌCha
(*
c
)) {

220 
JSONCPP_OSTRINGSTREAM
 
oss
;

221 
	goss
 << "\\u" << 
	gd
::
hex
 << 
d
::
u
 << std::
tfl
('0')

222 << 
d
::
tw
(4<< 
ic_
<>(*
c
);

223 
	gsu
 +
oss
.
r
();

225 
	gsu
 +*
c
;

230 
	gsu
 += "\"";

231  
	gsu
;

235 cڡ* 
pbrk
(cڡ* 
s
, cڡ* 
ac
, 
size_t
 
n
) {

236 
as
((
s
 || !
n
&& 
ac
);

238 cڡ* cڡ 
	gd
 = 
s
 + 
n
;

239 cڡ* 
	gcur
 = 
s
; cu< 
	gd
; ++cur) {

240 cڡ 
	gc
 = *
cur
;

241 cڡ* 
	ga
 = 
ac
; *a; ++a) {

242 i(*
	ga
 =
c
) {

243  
cur
;

247  
	gNULL
;

249 
JSONCPP_STRING
 
vueToQuedSgN
(cڡ * 
vue
, 
ngth
) {

250 i(
	gvue
 =
NULL
)

253 i(
pbrk
(
vue
, "\"\\\b\f\n\r\t", 
ngth
=
NULL
 &&

254 !
cڏsCڌCha0
(
vue
, 
ngth
))

255  
JSONCPP_STRING
("\""+ 
	gvue
 + "\"";

259 
	gJSONCPP_STRING
::
size_ty
 
maxsize
 =

260 
ngth
 * 2 + 3;

261 
JSONCPP_STRING
 
	gsu
;

262 
	gsu
.
rve
(
maxsize
);

263 
	gsu
 += "\"";

264 cڡ* 
	gd
 = 
vue
 + 
ngth
;

265 cڡ * 
	gc
 = 
vue
; c !
d
; ++c) {

266 *
	gc
) {

268 
su
 += "\\\"";

271 
su
 += "\\\\";

274 
su
 += "\\b";

277 
su
 += "\\f";

280 
su
 += "\\n";

283 
su
 += "\\r";

286 
su
 += "\\t";

297 i((
isCڌCha
(*
c
)) || (*c == 0)) {

298 
JSONCPP_OSTRINGSTREAM
 
oss
;

299 
	goss
 << "\\u" << 
	gd
::
hex
 << 
d
::
u
 << std::
tfl
('0')

300 << 
d
::
tw
(4<< 
ic_
<>(*
c
);

301 
	gsu
 +
oss
.
r
();

303 
	gsu
 +*
c
;

308 
	gsu
 += "\"";

309  
	gsu
;

314 
	gWr
::~
Wr
() {}

319 
FaWr
::FastWriter()

320 : 
yamlComtiblyEbd_
(
l
), 
drNuPhds_
(false),

321 
omEndgLeFd_
(
l
) {}

323 
	gFaWr
::
abYAMLComtiby
({ 
yamlComtiblyEbd_
 = 
ue
; }

325 
	gFaWr
::
drNuPhds
({ 
drNuPhds_
 = 
ue
; }

327 
	gFaWr
::
omEndgLeFd
({ 
omEndgLeFd_
 = 
ue
; }

329 
JSONCPP_STRING
 
	gFaWr
::
wre
(cڡ 
Vue
& 
ro
) {

330 
documt_
 = "";

331 
wreVue
(
ro
);

332 i(!
	gomEndgLeFd_
)

333 
	gdocumt_
 += "\n";

334  
	gdocumt_
;

337 
	gFaWr
::
wreVue
(cڡ 
Vue
& 
vue
) {

338 
vue
.
ty
()) {

339 
nuVue
:

340 i(!
drNuPhds_
)

341 
documt_
 += "null";

343 
	gtVue
:

344 
documt_
 +
vueToSg
(
vue
.
asLgeI
());

346 
	gutVue
:

347 
documt_
 +
vueToSg
(
vue
.
asLgeUI
());

349 
	gVue
:

350 
documt_
 +
vueToSg
(
vue
.
asDoub
());

352 
	grgVue
:

355 cڡ* 
r
;

356 cڡ* 
	gd
;

357 
bo
 
	gok
 = 
vue
.
gSg
(&
r
, &
d
);

358 i(
	gok

	gdocumt_
 +
vueToQuedSgN
(
r
, 
ic_
<>(
d
-str));

361 
	gboޗnVue
:

362 
documt_
 +
vueToSg
(
vue
.
asBo
());

364 
	gyVue
: {

365 
documt_
 += '[';

366 
AayIndex
 
	gsize
 = 
vue
.
size
();

367 
AayIndex
 
	gdex
 = 0; index < 
	gsize
; ++index) {

368 i(
	gdex
 > 0)

369 
	gdocumt_
 += ',';

370 
wreVue
(
vue
[
dex
]);

372 
	gdocumt_
 += ']';

374 
	gobjeVue
: {

375 
Vue
::
Membs
 
membs
(
vue
.
gMembNames
());

376 
	gdocumt_
 += '{';

377 
	gVue
::
Membs
::

 

 = 
membs
.
beg
(); 
	g
 !membs.
d
();

378 ++
	g
) {

379 cڡ 
	gJSONCPP_STRING
& 
	gme
 = *

;

380 i(
	g
 !
membs
.
beg
())

381 
documt_
 += ',';

382 
	gdocumt_
 +
vueToQuedSgN
(
me
.
da
(), 
ic_
<>ame.
ngth
()));

383 
	gdocumt_
 +
yamlComtiblyEbd_
 ? ": " : ":";

384 
wreVue
(
vue
[
me
]);

386 
	gdocumt_
 += '}';

394 
	gStydWr
::
StydWr
()

395 : 
rightMg_
(74), 
dtSize_
(3), 
addChdVues_
() {}

397 
JSONCPP_STRING
 
	gStydWr
::
wre
(cڡ 
Vue
& 
ro
) {

398 
documt_
 = "";

399 
	gaddChdVues_
 = 
l
;

400 
	gdtSg_
 = "";

401 
wreCommtBefeVue
(
ro
);

402 
wreVue
(
ro
);

403 
wreCommtAVueOnSameLe
(
ro
);

404 
	gdocumt_
 += "\n";

405  
	gdocumt_
;

408 
	gStydWr
::
wreVue
(cڡ 
Vue
& 
vue
) {

409 
vue
.
ty
()) {

410 
nuVue
:

411 
pushVue
("null");

413 
	gtVue
:

414 
pushVue
(
vueToSg
(
vue
.
asLgeI
()));

416 
	gutVue
:

417 
pushVue
(
vueToSg
(
vue
.
asLgeUI
()));

419 
	gVue
:

420 
pushVue
(
vueToSg
(
vue
.
asDoub
()));

422 
	grgVue
:

425 cڡ* 
r
;

426 cڡ* 
	gd
;

427 
bo
 
	gok
 = 
vue
.
gSg
(&
r
, &
d
);

428 i(
	gok

pushVue
(
vueToQuedSgN
(
r
, 
ic_
<>(
d
-str)));

429 
pushVue
("");

432 
	gboޗnVue
:

433 
pushVue
(
vueToSg
(
vue
.
asBo
()));

435 
	gyVue
:

436 
wreAayVue
(
vue
);

438 
	gobjeVue
: {

439 
Vue
::
Membs
 
membs
(
vue
.
gMembNames
());

440 i(
	gmembs
.
emy
())

441 
pushVue
("{}");

443 
wreWhIndt
("{");

444 
dt
();

445 
	gVue
::
Membs
::

 

 = 
membs
.
beg
();

447 cڡ 
	gJSONCPP_STRING
& 
	gme
 = *

;

448 cڡ 
	gVue
& 
	gchdVue
 = 
vue
[
me
];

449 
wreCommtBefeVue
(
chdVue
);

450 
wreWhIndt
(
vueToQuedSg
(
me
.
c_r
()));

451 
	gdocumt_
 += " : ";

452 
wreVue
(
chdVue
);

453 i(++
	g
 =
membs
.
d
()) {

454 
wreCommtAVueOnSameLe
(
chdVue
);

457 
	gdocumt_
 += ',';

458 
wreCommtAVueOnSameLe
(
chdVue
);

460 
undt
();

461 
wreWhIndt
("}");

467 
	gStydWr
::
wreAayVue
(cڡ 
Vue
& 
vue
) {

468 
size
 = 
vue
.size();

469 i(
	gsize
 == 0)

470 
pushVue
("[]");

472 
bo
 
	gisAayMuiLe
 = 
isMuɚeAay
(
vue
);

473 i(
	gisAayMuiLe
) {

474 
wreWhIndt
("[");

475 
dt
();

476 
bo
 
	ghasChdVue
 = !
chdVues_
.
emy
();

477 
	gdex
 = 0;

479 cڡ 
	gVue
& 
	gchdVue
 = 
vue
[
dex
];

480 
wreCommtBefeVue
(
chdVue
);

481 i(
	ghasChdVue
)

482 
wreWhIndt
(
chdVues_
[
dex
]);

484 
wreIndt
();

485 
wreVue
(
chdVue
);

487 i(++
	gdex
 =
size
) {

488 
wreCommtAVueOnSameLe
(
chdVue
);

491 
	gdocumt_
 += ',';

492 
wreCommtAVueOnSameLe
(
chdVue
);

494 
undt
();

495 
wreWhIndt
("]");

498 
as
(
chdVues_
.
size
() == size);

499 
	gdocumt_
 += "[ ";

500 
	gdex
 = 0; index < 
	gsize
; ++index) {

501 i(
	gdex
 > 0)

502 
	gdocumt_
 += ", ";

503 
	gdocumt_
 +
chdVues_
[
dex
];

505 
	gdocumt_
 += " ]";

510 
bo
 
	gStydWr
::
isMuɚeAay
(cڡ 
Vue
& 
vue
) {

511 
AayIndex
 cڡ 
size
 = 
vue
.size();

512 
bo
 
	gisMuiLe
 = 
size
 * 3 >
rightMg_
;

513 
	gchdVues_
.
r
();

514 
AayIndex
 
	gdex
 = 0; index < 
	gsize
 && !
	gisMuiLe
; ++index) {

515 cڡ 
	gVue
& 
	gchdVue
 = 
vue
[
dex
];

516 
	gisMuiLe
 = ((
chdVue
.
isAay
(|| chdVue.
isObje
()) &&

517 
chdVue
.
size
() > 0);

519 i(!
	gisMuiLe
)

521 
	gchdVues_
.
rve
(
size
);

522 
	gaddChdVues_
 = 
ue
;

523 
AayIndex
 
	gleLgth
 = 4 + (
size
 - 1) * 2;

524 
AayIndex
 
	gdex
 = 0; index < 
	gsize
; ++index) {

525 i(
hasCommtFVue
(
vue
[
dex
])) {

526 
	gisMuiLe
 = 
ue
;

528 
wreVue
(
vue
[
dex
]);

529 
	gleLgth
 +
ic_
<
AayIndex
>(
chdVues_
[
dex
].
ngth
());

531 
	gaddChdVues_
 = 
l
;

532 
	gisMuiLe
 = 
isMuiLe
 || 
leLgth
 >
rightMg_
;

534  
	gisMuiLe
;

537 
	gStydWr
::
pushVue
(cڡ 
JSONCPP_STRING
& 
vue
) {

538 i(
addChdVues_
)

539 
chdVues_
.
push_back
(
vue
);

541 
	gdocumt_
 +
vue
;

544 
	gStydWr
::
wreIndt
() {

545 i(!
documt_
.
emy
()) {

546 
ϡ
 = 
documt_
[documt_.
ngth
() - 1];

547 i(
	gϡ
 == ' ')

549 i(
	gϡ
 != '\n')

550 
documt_
 += '\n';

552 
	gdocumt_
 +
dtSg_
;

555 
	gStydWr
::
wreWhIndt
(cڡ 
JSONCPP_STRING
& 
vue
) {

556 
wreIndt
();

557 
	gdocumt_
 +
vue
;

560 
	gStydWr
::
dt
({ 
dtSg_
 +
JSONCPP_STRING
(
dtSize_
, ' '); }

562 
	gStydWr
::
undt
() {

563 
as
(
dtSg_
.
size
(>
dtSize_
);

564 
	gdtSg_
.
size
(
dtSg_
.
size
(- 
dtSize_
);

567 
	gStydWr
::
wreCommtBefeVue
(cڡ 
Vue
& 
ro
) {

568 i(!
ro
.
hasCommt
(
commtBefe
))

571 
	gdocumt_
 += "\n";

572 
wreIndt
();

573 cڡ 
	gJSONCPP_STRING
& 
	gcommt
 = 
ro
.
gCommt
(
commtBefe
);

574 
	gJSONCPP_STRING
::
cڡ_
 

 = 
commt
.
beg
();

575 
	g
 !
commt
.
d
()) {

576 
documt_
 +*

;

577 i(*
	g
 == '\n' &&

578 (

 !
commt
.
d
() && *(iter + 1) == '/'))

579 
wreIndt
();

580 ++
	g
;

584 
	gdocumt_
 += "\n";

587 
	gStydWr
::
wreCommtAVueOnSameLe
(cڡ 
Vue
& 
ro
) {

588 i(
ro
.
hasCommt
(
commtAOnSameLe
))

589 
documt_
 +" " + 
ro
.
gCommt
(
commtAOnSameLe
);

591 i(
	gro
.
hasCommt
(
commtA
)) {

592 
	gdocumt_
 += "\n";

593 
	gdocumt_
 +
ro
.
gCommt
(
commtA
);

594 
	gdocumt_
 += "\n";

598 
bo
 
	gStydWr
::
hasCommtFVue
(cڡ 
Vue
& 
vue
) {

599  
vue
.
hasCommt
(
commtBefe
) ||

600 
vue
.
hasCommt
(
commtAOnSameLe
) ||

601 
vue
.
hasCommt
(
commtA
);

607 
	gStydSmWr
::
StydSmWr
(
JSONCPP_STRING
 
dti
)

608 : 
documt_
(
NULL
), 
rightMg_
(74), 
dti_
(
dti
),

609 
addChdVues_
() {}

611 
	gStydSmWr
::
wre
(
JSONCPP_OSTREAM
& 
out
, cڡ 
Vue
& 
ro
) {

612 
	gdocumt_
 = &
out
;

613 
	gaddChdVues_
 = 
l
;

614 
	gdtSg_
 = "";

615 
	gdd_
 = 
ue
;

616 
wreCommtBefeVue
(
ro
);

617 i(!
	gdd_

wreIndt
();

618 
	gdd_
 = 
ue
;

619 
wreVue
(
ro
);

620 
wreCommtAVueOnSameLe
(
ro
);

621 *
	gdocumt_
 << "\n";

622 
	gdocumt_
 = 
NULL
;

625 
	gStydSmWr
::
wreVue
(cڡ 
Vue
& 
vue
) {

626 
vue
.
ty
()) {

627 
nuVue
:

628 
pushVue
("null");

630 
	gtVue
:

631 
pushVue
(
vueToSg
(
vue
.
asLgeI
()));

633 
	gutVue
:

634 
pushVue
(
vueToSg
(
vue
.
asLgeUI
()));

636 
	gVue
:

637 
pushVue
(
vueToSg
(
vue
.
asDoub
()));

639 
	grgVue
:

642 cڡ* 
r
;

643 cڡ* 
	gd
;

644 
bo
 
	gok
 = 
vue
.
gSg
(&
r
, &
d
);

645 i(
	gok

pushVue
(
vueToQuedSgN
(
r
, 
ic_
<>(
d
-str)));

646 
pushVue
("");

649 
	gboޗnVue
:

650 
pushVue
(
vueToSg
(
vue
.
asBo
()));

652 
	gyVue
:

653 
wreAayVue
(
vue
);

655 
	gobjeVue
: {

656 
Vue
::
Membs
 
membs
(
vue
.
gMembNames
());

657 i(
	gmembs
.
emy
())

658 
pushVue
("{}");

660 
wreWhIndt
("{");

661 
dt
();

662 
	gVue
::
Membs
::

 

 = 
membs
.
beg
();

664 cڡ 
	gJSONCPP_STRING
& 
	gme
 = *

;

665 cڡ 
	gVue
& 
	gchdVue
 = 
vue
[
me
];

666 
wreCommtBefeVue
(
chdVue
);

667 
wreWhIndt
(
vueToQuedSg
(
me
.
c_r
()));

668 *
	gdocumt_
 << " : ";

669 
wreVue
(
chdVue
);

670 i(++
	g
 =
membs
.
d
()) {

671 
wreCommtAVueOnSameLe
(
chdVue
);

674 *
	gdocumt_
 << ",";

675 
wreCommtAVueOnSameLe
(
chdVue
);

677 
undt
();

678 
wreWhIndt
("}");

684 
	gStydSmWr
::
wreAayVue
(cڡ 
Vue
& 
vue
) {

685 
size
 = 
vue
.size();

686 i(
	gsize
 == 0)

687 
pushVue
("[]");

689 
bo
 
	gisAayMuiLe
 = 
isMuɚeAay
(
vue
);

690 i(
	gisAayMuiLe
) {

691 
wreWhIndt
("[");

692 
dt
();

693 
bo
 
	ghasChdVue
 = !
chdVues_
.
emy
();

694 
	gdex
 = 0;

696 cڡ 
	gVue
& 
	gchdVue
 = 
vue
[
dex
];

697 
wreCommtBefeVue
(
chdVue
);

698 i(
	ghasChdVue
)

699 
wreWhIndt
(
chdVues_
[
dex
]);

701 i(!
	gdd_

wreIndt
();

702 
	gdd_
 = 
ue
;

703 
wreVue
(
chdVue
);

704 
	gdd_
 = 
l
;

706 i(++
	gdex
 =
size
) {

707 
wreCommtAVueOnSameLe
(
chdVue
);

710 *
	gdocumt_
 << ",";

711 
wreCommtAVueOnSameLe
(
chdVue
);

713 
undt
();

714 
wreWhIndt
("]");

717 
as
(
chdVues_
.
size
() == size);

718 *
	gdocumt_
 << "[ ";

719 
	gdex
 = 0; index < 
	gsize
; ++index) {

720 i(
	gdex
 > 0)

721 *
	gdocumt_
 << ", ";

722 *
	gdocumt_
 << 
	gchdVues_
[
dex
];

724 *
	gdocumt_
 << " ]";

729 
bo
 
	gStydSmWr
::
isMuɚeAay
(cڡ 
Vue
& 
vue
) {

730 
AayIndex
 cڡ 
size
 = 
vue
.size();

731 
bo
 
	gisMuiLe
 = 
size
 * 3 >
rightMg_
;

732 
	gchdVues_
.
r
();

733 
AayIndex
 
	gdex
 = 0; index < 
	gsize
 && !
	gisMuiLe
; ++index) {

734 cڡ 
	gVue
& 
	gchdVue
 = 
vue
[
dex
];

735 
	gisMuiLe
 = ((
chdVue
.
isAay
(|| chdVue.
isObje
()) &&

736 
chdVue
.
size
() > 0);

738 i(!
	gisMuiLe
)

740 
	gchdVues_
.
rve
(
size
);

741 
	gaddChdVues_
 = 
ue
;

742 
AayIndex
 
	gleLgth
 = 4 + (
size
 - 1) * 2;

743 
AayIndex
 
	gdex
 = 0; index < 
	gsize
; ++index) {

744 i(
hasCommtFVue
(
vue
[
dex
])) {

745 
	gisMuiLe
 = 
ue
;

747 
wreVue
(
vue
[
dex
]);

748 
	gleLgth
 +
ic_
<
AayIndex
>(
chdVues_
[
dex
].
ngth
());

750 
	gaddChdVues_
 = 
l
;

751 
	gisMuiLe
 = 
isMuiLe
 || 
leLgth
 >
rightMg_
;

753  
	gisMuiLe
;

756 
	gStydSmWr
::
pushVue
(cڡ 
JSONCPP_STRING
& 
vue
) {

757 i(
addChdVues_
)

758 
chdVues_
.
push_back
(
vue
);

760 *
	gdocumt_
 << 
	gvue
;

763 
	gStydSmWr
::
wreIndt
() {

768 *
documt_
 << '\n' << 
dtSg_
;

771 
	gStydSmWr
::
wreWhIndt
(cڡ 
JSONCPP_STRING
& 
vue
) {

772 i(!
dd_

wreIndt
();

773 *
	gdocumt_
 << 
	gvue
;

774 
	gdd_
 = 
l
;

777 
	gStydSmWr
::
dt
({ 
dtSg_
 +
dti_
; }

779 
	gStydSmWr
::
undt
() {

780 
as
(
dtSg_
.
size
(>
dti_
.size());

781 
	gdtSg_
.
size
(
dtSg_
.
size
(- 
dti_
.size());

784 
	gStydSmWr
::
wreCommtBefeVue
(cڡ 
Vue
& 
ro
) {

785 i(!
ro
.
hasCommt
(
commtBefe
))

788 i(!
	gdd_

wreIndt
();

789 cڡ 
	gJSONCPP_STRING
& 
	gcommt
 = 
ro
.
gCommt
(
commtBefe
);

790 
	gJSONCPP_STRING
::
cڡ_
 

 = 
commt
.
beg
();

791 
	g
 !
commt
.
d
()) {

792 *
documt_
 << *

;

793 i(*
	g
 == '\n' &&

794 (

 !
commt
.
d
() && *(iter + 1) == '/'))

796 *
documt_
 << 
dtSg_
;

797 ++
	g
;

799 
	gdd_
 = 
l
;

802 
	gStydSmWr
::
wreCommtAVueOnSameLe
(cڡ 
Vue
& 
ro
) {

803 i(
ro
.
hasCommt
(
commtAOnSameLe
))

804 *
documt_
 << ' ' << 
ro
.
gCommt
(
commtAOnSameLe
);

806 i(
	gro
.
hasCommt
(
commtA
)) {

807 
wreIndt
();

808 *
	gdocumt_
 << 
	gro
.
gCommt
(
commtA
);

810 
	gdd_
 = 
l
;

813 
bo
 
	gStydSmWr
::
hasCommtFVue
(cڡ 
Vue
& 
vue
) {

814  
vue
.
hasCommt
(
commtBefe
) ||

815 
vue
.
hasCommt
(
commtAOnSameLe
) ||

816 
vue
.
hasCommt
(
commtA
);

823 
	sCommtSty
 {

825 
	eEnum
 {

826 
	gNe
,

827 
	gMo
,

828 
	gA


832 
	gButStydSmWr
 : 
public
 
SmWr


834 
ButStydSmWr
(

835 
JSONCPP_STRING
 cڡ& 
dti
,

836 
CommtSty
::
Enum
 
cs
,

837 
JSONCPP_STRING
 cڡ& 
cSymb
,

838 
JSONCPP_STRING
 cڡ& 
nuSymb
,

839 
JSONCPP_STRING
 cڡ& 
dgLeFdSymb
,

840 
bo
 
uSclFlts
,

841 
ecisi
);

842 
wre
(
Vue
 cڡ& 
ro
, 
JSONCPP_OSTREAM
* 
sout

	gJSONCPP_OVERRIDE
;

843 
	give
:

844 
wreVue
(
Vue
 cڡ& 
vue
);

845 
wreAayVue
(
Vue
 cڡ& 
vue
);

846 
bo
 
isMuɚeAay
(
Vue
 cڡ& 
vue
);

847 
pushVue
(
JSONCPP_STRING
 cڡ& 
vue
);

848 
wreIndt
();

849 
wreWhIndt
(
JSONCPP_STRING
 cڡ& 
vue
);

850 
dt
();

851 
undt
();

852 
wreCommtBefeVue
(
Vue
 cڡ& 
ro
);

853 
wreCommtAVueOnSameLe
(
Vue
 cڡ& 
ro
);

854 
bo
 
hasCommtFVue
(cڡ 
Vue
& 
vue
);

856 
	gd
::
	tve
<
	tJSONCPP_STRING
> 
	tChdVues
;

858 
ChdVues
 
	gchdVues_
;

859 
JSONCPP_STRING
 
	gdtSg_
;

860 
	grightMg_
;

861 
JSONCPP_STRING
 
	gdti_
;

862 
	gCommtSty
::
Enum
 
cs_
;

863 
JSONCPP_STRING
 
	gcSymb_
;

864 
JSONCPP_STRING
 
	gnuSymb_
;

865 
JSONCPP_STRING
 
	gdgLeFdSymb_
;

866 
bo
 
	gaddChdVues_
 : 1;

867 
bo
 
	gdd_
 : 1;

868 
bo
 
	guSclFlts_
 : 1;

869 
	gecisi_
;

871 
	gButStydSmWr
::
ButStydSmWr
(

872 
JSONCPP_STRING
 cڡ& 
dti
,

873 
CommtSty
::
Enum
 
cs
,

874 
JSONCPP_STRING
 cڡ& 
cSymb
,

875 
JSONCPP_STRING
 cڡ& 
nuSymb
,

876 
JSONCPP_STRING
 cڡ& 
dgLeFdSymb
,

877 
bo
 
uSclFlts
,

878 
ecisi
)

879 : 
rightMg_
(74)

880 , 
dti_
(
dti
)

881 , 
cs_
(
cs
)

882 , 
cSymb_
(
cSymb
)

883 , 
nuSymb_
(
nuSymb
)

884 , 
dgLeFdSymb_
(
dgLeFdSymb
)

885 , 
addChdVues_
(
l
)

886 , 
dd_
(
l
)

887 , 
uSclFlts_
(
uSclFlts
)

888 , 
ecisi_
(
ecisi
)

891 
	gButStydSmWr
::
wre
(
Vue
 cڡ& 
ro
, 
JSONCPP_OSTREAM
* 
sout
)

893 
	gsout_
 = 
sout
;

894 
	gaddChdVues_
 = 
l
;

895 
	gdd_
 = 
ue
;

896 
	gdtSg_
 = "";

897 
wreCommtBefeVue
(
ro
);

898 i(!
	gdd_

wreIndt
();

899 
	gdd_
 = 
ue
;

900 
wreVue
(
ro
);

901 
wreCommtAVueOnSameLe
(
ro
);

902 *
	gsout_
 << 
	gdgLeFdSymb_
;

903 
	gsout_
 = 
NULL
;

906 
	gButStydSmWr
::
wreVue
(
Vue
 cڡ& 
vue
) {

907 
vue
.
ty
()) {

908 
nuVue
:

909 
pushVue
(
nuSymb_
);

911 
	gtVue
:

912 
pushVue
(
vueToSg
(
vue
.
asLgeI
()));

914 
	gutVue
:

915 
pushVue
(
vueToSg
(
vue
.
asLgeUI
()));

917 
	gVue
:

918 
pushVue
(
vueToSg
(
vue
.
asDoub
(), 
uSclFlts_
, 
ecisi_
));

920 
	grgVue
:

923 cڡ* 
r
;

924 cڡ* 
	gd
;

925 
bo
 
	gok
 = 
vue
.
gSg
(&
r
, &
d
);

926 i(
	gok

pushVue
(
vueToQuedSgN
(
r
, 
ic_
<>(
d
-str)));

927 
pushVue
("");

930 
	gboޗnVue
:

931 
pushVue
(
vueToSg
(
vue
.
asBo
()));

933 
	gyVue
:

934 
wreAayVue
(
vue
);

936 
	gobjeVue
: {

937 
Vue
::
Membs
 
membs
(
vue
.
gMembNames
());

938 i(
	gmembs
.
emy
())

939 
pushVue
("{}");

941 
wreWhIndt
("{");

942 
dt
();

943 
	gVue
::
Membs
::

 

 = 
membs
.
beg
();

945 
JSONCPP_STRING
 cڡ& 
	gme
 = *

;

946 
Vue
 cڡ& 
	gchdVue
 = 
vue
[
me
];

947 
wreCommtBefeVue
(
chdVue
);

948 
wreWhIndt
(
vueToQuedSgN
(
me
.
da
(), 
ic_
<>ame.
ngth
())));

949 *
	gsout_
 << 
	gcSymb_
;

950 
wreVue
(
chdVue
);

951 i(++
	g
 =
membs
.
d
()) {

952 
wreCommtAVueOnSameLe
(
chdVue
);

955 *
	gsout_
 << ",";

956 
wreCommtAVueOnSameLe
(
chdVue
);

958 
undt
();

959 
wreWhIndt
("}");

965 
	gButStydSmWr
::
wreAayVue
(
Vue
 cڡ& 
vue
) {

966 
size
 = 
vue
.size();

967 i(
	gsize
 == 0)

968 
pushVue
("[]");

970 
bo
 
	gisMuiLe
 = (
cs_
 =
CommtSty
::
A
|| 
isMuɚeAay
(
vue
);

971 i(
	gisMuiLe
) {

972 
wreWhIndt
("[");

973 
dt
();

974 
bo
 
	ghasChdVue
 = !
chdVues_
.
emy
();

975 
	gdex
 = 0;

977 
Vue
 cڡ& 
	gchdVue
 = 
vue
[
dex
];

978 
wreCommtBefeVue
(
chdVue
);

979 i(
	ghasChdVue
)

980 
wreWhIndt
(
chdVues_
[
dex
]);

982 i(!
	gdd_

wreIndt
();

983 
	gdd_
 = 
ue
;

984 
wreVue
(
chdVue
);

985 
	gdd_
 = 
l
;

987 i(++
	gdex
 =
size
) {

988 
wreCommtAVueOnSameLe
(
chdVue
);

991 *
	gsout_
 << ",";

992 
wreCommtAVueOnSameLe
(
chdVue
);

994 
undt
();

995 
wreWhIndt
("]");

998 
as
(
chdVues_
.
size
() == size);

999 *
	gsout_
 << "[";

1000 i(!
	gdti_
.
emy
()*
	gsout_
 << " ";

1001 
	gdex
 = 0; index < 
	gsize
; ++index) {

1002 i(
	gdex
 > 0)

1003 *
	gsout_
 << ", ";

1004 *
	gsout_
 << 
	gchdVues_
[
dex
];

1006 i(!
	gdti_
.
emy
()*
	gsout_
 << " ";

1007 *
	gsout_
 << "]";

1012 
bo
 
	gButStydSmWr
::
isMuɚeAay
(
Vue
 cڡ& 
vue
) {

1013 
AayIndex
 cڡ 
size
 = 
vue
.size();

1014 
bo
 
	gisMuiLe
 = 
size
 * 3 >
rightMg_
;

1015 
	gchdVues_
.
r
();

1016 
AayIndex
 
	gdex
 = 0; index < 
	gsize
 && !
	gisMuiLe
; ++index) {

1017 
Vue
 cڡ& 
	gchdVue
 = 
vue
[
dex
];

1018 
	gisMuiLe
 = ((
chdVue
.
isAay
(|| chdVue.
isObje
()) &&

1019 
chdVue
.
size
() > 0);

1021 i(!
	gisMuiLe
)

1023 
	gchdVues_
.
rve
(
size
);

1024 
	gaddChdVues_
 = 
ue
;

1025 
AayIndex
 
	gleLgth
 = 4 + (
size
 - 1) * 2;

1026 
AayIndex
 
	gdex
 = 0; index < 
	gsize
; ++index) {

1027 i(
hasCommtFVue
(
vue
[
dex
])) {

1028 
	gisMuiLe
 = 
ue
;

1030 
wreVue
(
vue
[
dex
]);

1031 
	gleLgth
 +
ic_
<
AayIndex
>(
chdVues_
[
dex
].
ngth
());

1033 
	gaddChdVues_
 = 
l
;

1034 
	gisMuiLe
 = 
isMuiLe
 || 
leLgth
 >
rightMg_
;

1036  
	gisMuiLe
;

1039 
	gButStydSmWr
::
pushVue
(
JSONCPP_STRING
 cڡ& 
vue
) {

1040 i(
addChdVues_
)

1041 
chdVues_
.
push_back
(
vue
);

1043 *
	gsout_
 << 
	gvue
;

1046 
	gButStydSmWr
::
wreIndt
() {

1052 i(!
dti_
.
emy
()) {

1054 *
sout_
 << '\n' << 
dtSg_
;

1058 
	gButStydSmWr
::
wreWhIndt
(
JSONCPP_STRING
 cڡ& 
vue
) {

1059 i(!
dd_

wreIndt
();

1060 *
	gsout_
 << 
	gvue
;

1061 
	gdd_
 = 
l
;

1064 
	gButStydSmWr
::
dt
({ 
dtSg_
 +
dti_
; }

1066 
	gButStydSmWr
::
undt
() {

1067 
as
(
dtSg_
.
size
(>
dti_
.size());

1068 
	gdtSg_
.
size
(
dtSg_
.
size
(- 
dti_
.size());

1071 
	gButStydSmWr
::
wreCommtBefeVue
(
Vue
 cڡ& 
ro
) {

1072 i(
cs_
 =
CommtSty
::
Ne
) ;

1073 i(!
	gro
.
hasCommt
(
commtBefe
))

1076 i(!
	gdd_

wreIndt
();

1077 cڡ 
	gJSONCPP_STRING
& 
	gcommt
 = 
ro
.
gCommt
(
commtBefe
);

1078 
	gJSONCPP_STRING
::
cڡ_
 

 = 
commt
.
beg
();

1079 
	g
 !
commt
.
d
()) {

1080 *
sout_
 << *

;

1081 i(*
	g
 == '\n' &&

1082 (

 !
commt
.
d
() && *(iter + 1) == '/'))

1084 *
sout_
 << 
dtSg_
;

1085 ++
	g
;

1087 
	gdd_
 = 
l
;

1090 
	gButStydSmWr
::
wreCommtAVueOnSameLe
(
Vue
 cڡ& 
ro
) {

1091 i(
cs_
 =
CommtSty
::
Ne
) ;

1092 i(
	gro
.
hasCommt
(
commtAOnSameLe
))

1093 *
	gsout_
 << " " + 
	gro
.
gCommt
(
commtAOnSameLe
);

1095 i(
	gro
.
hasCommt
(
commtA
)) {

1096 
wreIndt
();

1097 *
	gsout_
 << 
	gro
.
gCommt
(
commtA
);

1102 
bo
 
	gButStydSmWr
::
hasCommtFVue
(cڡ 
Vue
& 
vue
) {

1103  
vue
.
hasCommt
(
commtBefe
) ||

1104 
vue
.
hasCommt
(
commtAOnSameLe
) ||

1105 
vue
.
hasCommt
(
commtA
);

1111 
	gSmWr
::
SmWr
()

1112 : 
sout_
(
NULL
)

1115 
SmWr
::~StreamWriter()

1118 
SmWr
::
Fay
::~Factory()

1120 
SmWrBud
::StreamWriterBuilder()

1122 
tDeus
(&
gs_
);

1124 
	gSmWrBud
::~
SmWrBud
()

1126 
SmWr
* 
SmWrBud
::
wSmWr
() const

1128 
JSONCPP_STRING
 
dti
 = 
gs_
["dti"].
asSg
();

1129 
JSONCPP_STRING
 
	gcs_r
 = 
gs_
["commtSty"].
asSg
();

1130 
bo
 
	geyc
 = 
gs_
["abYAMLComtiby"].
asBo
();

1131 
bo
 
	gd
 = 
gs_
["drNuPhds"].
asBo
();

1132 
bo
 
	gusf
 = 
gs_
["uSclFlts"].
asBo
();

1133 
	ge
 = 
gs_
["ecisi"].
asUI
();

1134 
	gCommtSty
::
Enum
 
cs
 = 
CommtSty
::
A
;

1135 i(
	gcs_r
 == "All") {

1136 
cs
 = 
CommtSty
::
A
;

1137 } i(
	gcs_r
 == "None") {

1138 
cs
 = 
CommtSty
::
Ne
;

1140 
throwRuimeE
("commentStyle must be 'All' or 'None'");

1142 
JSONCPP_STRING
 
	gcSymb
 = " : ";

1143 i(
	geyc
) {

1144 
	gcSymb
 = ": ";

1145 } i(
	gdti
.
emy
()) {

1146 
	gcSymb
 = ":";

1148 
JSONCPP_STRING
 
	gnuSymb
 = "null";

1149 i(
	gd
) {

1150 
	gnuSymb
 = "";

1152 i(
	ge
 > 17)re = 17;

1153 
JSONCPP_STRING
 
	gdgLeFdSymb
 = "";

1154  
w
 
ButStydSmWr
(

1155 
dti
, 
cs
,

1156 
cSymb
, 
nuSymb
, 
dgLeFdSymb
, 
usf
, 
e
);

1158 
gVidWrKeys
(
d
::
t
<
JSONCPP_STRING
>* 
vid_keys
)

1160 
vid_keys
->
r
();

1161 
	gvid_keys
->

("indentation");

1162 
	gvid_keys
->

("commentStyle");

1163 
	gvid_keys
->

("enableYAMLCompatibility");

1164 
	gvid_keys
->

("dropNullPlaceholders");

1165 
	gvid_keys
->

("useSpecialFloats");

1166 
	gvid_keys
->

("precision");

1168 
bo
 
	gSmWrBud
::
vide
(
Js
::
Vue
* 
vid
) const

1170 
Js
::
Vue
 
my_vid
;

1171 i(!
	gvid
vid = &
my_vid
;

1172 
	gJs
::
Vue
& 
v
 = *
vid
;

1173 
	gd
::
t
<
JSONCPP_STRING
> 
vid_keys
;

1174 
gVidWrKeys
(&
vid_keys
);

1175 
	gVue
::
Membs
 
keys
 = 
gs_
.
gMembNames
();

1176 
size_t
 
	gn
 = 
keys
.
size
();

1177 
size_t
 
	gi
 = 0; i < 
	gn
; ++i) {

1178 
JSONCPP_STRING
 cڡ& 
	gkey
 = 
keys
[
i
];

1179 i(
	gvid_keys
.
fd
(
key
=
vid_keys
.
d
()) {

1180 
v
[
key
] = 
gs_
[key];

1183  0u =
v
.
size
();

1185 
	gVue
& 
	gSmWrBud
::
ݔ
[](
JSONCPP_STRING
 
key
)

1187  
gs_
[
key
];

1190 
	gSmWrBud
::
tDeus
(
Js
::
Vue
* 
gs
)

1193 (*
gs
)["commentStyle"] = "All";

1194 (*
	ggs
)["indentation"] = "\t";

1195 (*
	ggs
)["abYAMLComtiby"] = 
l
;

1196 (*
	ggs
)["drNuPhds"] = 
l
;

1197 (*
	ggs
)["uSclFlts"] = 
l
;

1198 (*
	ggs
)["precision"] = 17;

1202 
JSONCPP_STRING
 
wreSg
(
SmWr
::
Fay
 cڡ& 
bud
, 
Vue
 cڡ& 
ro
) {

1203 
JSONCPP_OSTRINGSTREAM
 
	gsout
;

1204 
SmWrP
 cڡ 
wr
(
bud
.
wSmWr
());

1205 
	gwr
->
wre
(
ro
, &
sout
);

1206  
	gsout
.
r
();

1209 
	gJSONCPP_OSTREAM
& 
	gݔ
<<(JSONCPP_OSTREAM& 
	gsout
, 
Vue
 cڡ& 
	gro
) {

1210 
SmWrBud
 
	gbud
;

1211 
SmWrP
 cڡ 
wr
(
bud
.
wSmWr
());

1212 
	gwr
->
wre
(
ro
, &
sout
);

1213  
	gsout
;

	@open_source/jsoncpp-1.7.2.no-abi/src/test_lib_json/jsontest.cpp

6 
	#_CRT_SECURE_NO_WARNINGS
 1

7 
	~"jsڋ.h
"

	)

8 
	~<dio.h
>

9 
	~<rg
>

11 #i
defed
(
_MSC_VER
)

13 
	~<tdbg.h
>

16 #i
defed
(
_WIN32
)

19 
	#WIN32_LEAN_AND_MEAN


	)

20 
	#NOSERVICE


	)

21 
	#NOMCX


	)

22 
	#NOIME


	)

23 
	#NOSOUND


	)

24 
	#NOCOMM


	)

25 
	#NORPC


	)

26 
	#NOGDI


	)

27 
	#NOUSER


	)

28 
	#NODRIVERS


	)

29 
	#NOLOGERROR


	)

30 
	#NOPROFILER


	)

31 
	#NOMEMMGR


	)

32 
	#NOLFILEIO


	)

33 
	#NOOPENFILE


	)

34 
	#NORESOURCE


	)

35 
	#NOATOM


	)

36 
	#NOLANGUAGE


	)

37 
	#NOLSTRING


	)

38 
	#NODBCS


	)

39 
	#NOKEYBOARDINFO


	)

40 
	#NOGDICAPMASKS


	)

41 
	#NOCOLOR


	)

42 
	#NOGDIOBJ


	)

43 
	#NODRAWTEXT


	)

44 
	#NOTEXTMETRIC


	)

45 
	#NOSCALABLEFONT


	)

46 
	#NOBITMAP


	)

47 
	#NORASTEROPS


	)

48 
	#NOMETAFILE


	)

49 
	#NOSYSMETRICS


	)

50 
	#NOSYSTEMPARAMSINFO


	)

51 
	#NOMSG


	)

52 
	#NOWINSTYLES


	)

53 
	#NOWINOFFSETS


	)

54 
	#NOSHOWWINDOW


	)

55 
	#NODEFERWINDOWPOS


	)

56 
	#NOVIRTUALKEYCODES


	)

57 
	#NOKEYSTATES


	)

58 
	#NOWH


	)

59 
	#NOMENUS


	)

60 
	#NOSCROLL


	)

61 
	#NOCLIPBOARD


	)

62 
	#NOICONS


	)

63 
	#NOMB


	)

64 
	#NOSYSCOMMANDS


	)

65 
	#NOMDI


	)

66 
	#NOCTLMGR


	)

67 
	#NOWINMESSAGES


	)

68 
	~<wdows.h
>

71 
mea
 
	gJsTe
 {

76 
	gTeResu
::
TeResu
()

77 : 
ediId_
(1), 
ϡUdPdiId_
(0), 
mesgeTg_
(0) {

79 
	groPdiNode_
.
	gid_
 = 0;

80 
	groPdiNode_
.
	gxt_
 = 0;

81 
	gediSckTa_
 = &
roPdiNode_
;

84 
	gTeResu
::
tTeName
(cڡ 
JSONCPP_STRING
& 
me
{ 
me_
 =ame; }

86 
	gTeResu
&

87 
	gTeResu
::
addFau
(cڡ * 
fe
, 
le
, cڡ * 
ex
) {

90 
	gágLev
 = 0;

91 
PdiCڋxt
* 
	gϡNode
 = 
roPdiNode_
.
xt_
;

92 ; 
	gϡNode
 !0;aNod
ϡNode
->
xt_
) {

93 i(
ϡNode
->
id_
 > 
ϡUdPdiId_
)

95 
ϡUdPdiId_
 = 
ϡNode
->
id_
;

96 
addFauInfo
(

97 
ϡNode
->
fe_
,aNode->
le_
,aNode->
ex_
, 
ágLev
);

100 
	gϡNode
->
	gu_
 = &(
us_
.
back
());

102 ++
	gágLev
;

106 
addFauInfo
(
fe
, 
le
, 
ex
, 
ágLev
);

107 
	gmesgeTg_
 = &(
us_
.
back
());

108  *
	gthis
;

111 
	gTeResu
::
addFauInfo
(cڡ * 
fe
,

112 
le
,

113 cڡ * 
ex
,

114 
ágLev
) {

115 
Fau
 
	gu
;

116 
	gu
.
	gfe_
 = 
fe
;

117 
	gu
.
	gle_
 = 
le
;

118 i(
	gex
) {

119 
	gu
.
	gex_
 = 
ex
;

121 
	gu
.
	gágLev_
 = 
ágLev
;

122 
	gus_
.
push_back
(
u
);

125 
	gTeResu
& TeResu::
pPdiCڋxt
() {

126 
PdiCڋxt
* 
ϡNode
 = &
roPdiNode_
;

127 
	gϡNode
->
	gxt_
 !0 && 
ϡNode
->
xt_
->next_ != 0) {

128 
ϡNode
 =aNode->
xt_
;

131 
PdiCڋxt
* 
	g
 = 
ϡNode
->
xt_
;

132 i(
	g
 !0 && 

->
u_
 != 0) {

133 
mesgeTg_
 = 

->
u_
;

136 
	gediSckTa_
 = 
ϡNode
;

137 
	gϡNode
->
	gxt_
 = 0;

138  *
	gthis
;

141 
bo
 
	gTeResu
::
ed
(cڡ {  !
us_
.
emy
(); }

143 
	gTeResu
::
gAsiNegLev
() const {

144 
v
 = 0;

145 cڡ 
PdiCڋxt
* 
	gϡNode
 = &
roPdiNode_
;

146 
	gϡNode
->
	gxt_
 != 0) {

147 
ϡNode
 =aNode->
xt_
;

148 ++
	gv
;

150  
	gv
;

153 
	gTeResu
::
tFau
(
bo
 
tTeName
) const {

154 i(
us_
.
emy
()) {

158 i(
	gtTeName
) {

159 
tf
("* Da o% fau:\n", 
me_
.
c_r
());

163 
	gFaus
::
cڡ_
 
End
 = 
us_
.
d
();

164 
	gFaus
::
cڡ_
 

 = 
us_
.
beg
(); 
	g
 !
End
; ++it) {

165 cڡ 
	gFau
& 
	gu
 = *

;

166 
JSONCPP_STRING
 
dt
(
u
.
ágLev_
 * 2, ' ');

167 i(
	gu
.
	gfe_
) {

168 
tf
("%s%s(%d): ", 
dt
.
c_r
(), 
u
.
fe_
, fau.
le_
);

170 i(!
	gu
.
	gex_
.
emy
()) {

171 
tf
("%s\n", 
u
.
ex_
.
c_r
());

172 } i(
	gu
.
	gfe_
) {

173 
tf
("\n");

175 i(!
	gu
.
	gmesge_
.
emy
()) {

176 
JSONCPP_STRING
 
	gdd
 = 
dtText
(
u
.
mesge_
, 
dt
 + " ");

177 
tf
("%s\n", 
dd
.
c_r
());

182 
JSONCPP_STRING
 
	gTeResu
::
dtText
(cڡ JSONCPP_STRING& 
xt
,

183 cڡ 
JSONCPP_STRING
& 
dt
) {

184 
JSONCPP_STRING
 
	gdd
;

185 
	gJSONCPP_STRING
::
size_ty
 
ϡIndex
 = 0;

186 
	gϡIndex
 < 
	gxt
.
size
()) {

187 
	gJSONCPP_STRING
::
size_ty
 
xtIndex
 = 
xt
.
fd
('\n', 
ϡIndex
);

188 i(
	gxtIndex
 =
JSONCPP_STRING
::
os
) {

189 
xtIndex
 = 
xt
.
size
() - 1;

191 
	gdd
 +
dt
;

192 
	gdd
 +
xt
.
subr
(
ϡIndex
, 
xtIndex
 -astIndex + 1);

193 
	gϡIndex
 = 
xtIndex
 + 1;

195  
	gdd
;

198 
	gTeResu
& TeResu::
addToLaFau
(cڡ 
JSONCPP_STRING
& 
mesge
) {

199 i(
mesgeTg_
 != 0) {

200 
mesgeTg_
->
mesge_
 +
mesge
;

202  *
	gthis
;

205 
	gTeResu
& TeResu::
ݔ
<<(
Js
::
I64
 
vue
) {

206  
addToLaFau
(
Js
::
vueToSg
(
vue
));

209 
	gTeResu
& TeResu::
ݔ
<<(
Js
::
UI64
 
vue
) {

210  
addToLaFau
(
Js
::
vueToSg
(
vue
));

213 
	gTeResu
& TeResu::
ݔ
<<(
bo
 
vue
) {

214  
addToLaFau
(
vue
 ? "true" : "false");

220 
	gTeCa
::
TeCa
(: 
su_
(0) {}

222 
TeCa
::~TestCase() {}

224 
TeCa
::
run
(
TeResu
& 
su
) {

225 
su_
 = &
su
;

226 
runTeCa
();

232 
	gRu
::
Ru
() {}

234 
Ru
& Ru::
add
(
TeCaFay
 
y
) {

235 
s_
.
push_back
(
y
);

236  *
	gthis
;

239 
	gRu
::
Cou
() const {

240  
ic_
<>(
s_
.
size
());

243 
JSONCPP_STRING
 
	gRu
::
NameAt
(
dex
) const {

244 
TeCa
* 

 = 
s_
[
dex
]();

245 
JSONCPP_STRING
 
	gme
 = 

->
Name
();

246 
de
 
	g
;

247  
	gme
;

250 
	gRu
::
runTeAt
(
dex
, 
TeResu
& 
su
) const {

251 
TeCa
* 
	g
 = 
s_
[
dex
]();

252 
	gsu
.
tTeName
(

->
Name
());

253 
tf
("Teg %s: ", 

->
Name
());

254 
fush
(
dout
);

255 #i
JSON_USE_EXCEPTION


256 
	gy
 {

258 
	g
->
run
(
su
);

259 #i
JSON_USE_EXCEPTION


261 
tch
 (cڡ 
d
::
exi
& 
e
) {

262 
su
.
addFau
(
__FILE__
, 
__LINE__
, "Unexpectedxception caught:")

263 << 
	ge
.
wh
();

266 
de
 
	g
;

267 cڡ * 
	gus
 = 
su
.
ed
() ? "FAILED" : "OK";

268 
tf
("%s\n", 
us
);

269 
fush
(
dout
);

272 
bo
 
	gRu
::
runATe
(bo 
tSummy
) const {

273 
cou
 = 
Cou
();

274 
	gd
::
deque
<
TeResu
> 
us
;

275 
	gdex
 = 0; index < 
	gcou
; ++index) {

276 
TeResu
 
	gsu
;

277 
runTeAt
(
dex
, 
su
);

278 i(
	gsu
.
ed
()) {

279 
	gus
.
push_back
(
su
);

283 i(
	gus
.
emy
()) {

284 i(
	gtSummy
) {

285 
tf
("A %desd\n", 
cou
);

287  
	gue
;

289 
	gdex
 = 0; index < 
	gus
.
size
(); ++index) {

290 
	gTeResu
& 
	gsu
 = 
us
[
dex
];

291 
	gsu
.
tFau
(
cou
 > 1);

294 i(
	gtSummy
) {

295 
	gedCou
 = 
ic_
<>(
us
.
size
());

296 
	gsdCou
 = 
cou
 - 
edCou
;

297 
tf
("%d/%destsassed (%d failure(s))\n",

298 
sdCou
,

299 
cou
,

300 
edCou
);

302  
	gl
;

306 
bo
 
	gRu
::
Index
(cڡ 
JSONCPP_STRING
& 
Name
,

307 & 
dexOut
) const {

308 
	gcou
 = 
Cou
();

309 
	gdex
 = 0; index < 
	gcou
; ++index) {

310 i(
NameAt
(
dex
=
Name
) {

311 
dexOut
 = 
dex
;

312  
	gue
;

315  
	gl
;

318 
	gRu
::
liTes
() const {

319 
cou
 = 
Cou
();

320 
	gdex
 = 0; index < 
	gcou
; ++index) {

321 
tf
("%s\n", 
NameAt
(
dex
).
c_r
());

325 
	gRu
::
runCommdLe
(
gc
, cڡ * 
gv
[]) const {

327 
Ru
 
	gsubru
;

328 
	gdex
 = 1; index < 
	ggc
; ++index) {

329 
JSONCPP_STRING
 
	gt
 = 
gv
[
dex
];

330 i(
	gt
 == "--list-tests") {

331 
liTes
();

333 } i(
	gt
 == "--test-auto") {

334 
evtDlogOnCsh
();

335 } i(
	gt
 == "--test") {

336 ++
dex
;

337 i(
	gdex
 < 
	ggc
) {

338 
	gNameIndex
;

339 i(
Index
(
gv
[
dex
], 
NameIndex
)) {

340 
	gsubru
.
add
(
s_
[
NameIndex
]);

342 
rtf
(
dr
, "Te '%s' d۠nكxi!\n", 
gv
[
dex
]);

346 
tUge
(
gv
[0]);

350 
tUge
(
gv
[0]);

354 
bo
 
	gsuceded
;

355 i(
	gsubru
.
Cou
() > 0) {

356 
	gsuceded
 = 
subru
.
runATe
(subru.
Cou
() > 1);

358 
	gsuceded
 = 
runATe
(
ue
);

360  
	gsuceded
 ? 0 : 1;

363 #i
defed
(
_MSC_VER
&& defed(
_DEBUG
)

366 
msvtStRtHook
(
ptTy
, * 
mesge
, * ) {

372 i(
	gptTy
 =
_CRT_ERROR
 || 
ptTy
 =
_CRT_ASSERT
) {

377 vީ
bo
 
isAbtg
 = 
l
;

378 i(
	gisAbtg
) {

379  
	gTRUE
;

381 
	gisAbtg
 = 
ue
;

383 
rtf
(
dr
, "CRT E/As:\n%s\n", 
mesge
);

384 
fush
(
dr
);

385 
abt
();

388  
	gFALSE
;

392 
	gRu
::
evtDlogOnCsh
() {

393 #i
defed
(
_MSC_VER
&& defed(
_DEBUG
)

398 
_CSRtHook
(&
msvtStRtHook
);

404 #i
defed
(
_WIN32
)

407 
SEMode
(
SEM_FAILCRITICALERRORS
 | 
SEM_NOGPFAULTERRORBOX
 |

408 
SEM_NOOPENFILEERRORBOX
);

412 
	gRu
::
tUge
(cڡ * 
pName
) {

413 
tf
("Usage: %s [options]\n"

423 
pName
);

429 
JSONCPP_STRING
 
ToJsSg
(cڡ * 
toCvt
) {

430  
JSONCPP_STRING
(
toCvt
);

433 
JSONCPP_STRING
 
ToJsSg
(JSONCPP_STRING 

) {

434  
	g
;

437 #i
JSONCPP_USING_SECURE_MEMORY


438 
JSONCPP_STRING
 
ToJsSg
(
d
::
rg
 

) {

439  
JSONCPP_STRING
(

.
da
(), in.da(+ in.
ngth
());

443 
	gTeResu
& 
checkSgEqu
(
TeResu
& 
su
,

444 cڡ 
JSONCPP_STRING
& 
exed
,

445 cڡ 
JSONCPP_STRING
& 
au
,

446 cڡ * 
fe
,

447 
le
,

448 cڡ * 
ex
) {

449 i(
	gexed
 !
au
) {

450 
su
.
addFau
(
fe
, 
le
, 
ex
);

451 
	gsu
 << "Exed: '" << 
	gexed
 << "'\n";

452 
	gsu
 << "Au : '" << 
	gau
 << "'";

454  
	gsu
;

	@open_source/jsoncpp-1.7.2.no-abi/src/test_lib_json/jsontest.h

6 #ide
JSONTEST_H_INCLUDED


7 
	#JSONTEST_H_INCLUDED


	)

9 
	~<js/cfig.h
>

10 
	~<js/vue.h
>

11 
	~<js/wr.h
>

12 
	~<dio.h
>

13 
	~<deque
>

14 
	~<sam
>

15 
	~<rg
>

29 
mea
 
	gJsTe
 {

31 as
	cFau
 {

32 
	gpublic
:

33 cڡ * 
fe_
;

34 
	gle_
;

35 
JSONCPP_STRING
 
	gex_
;

36 
JSONCPP_STRING
 
	gmesge_
;

37 
	gágLev_
;

43 
	sPdiCڋxt
 {

44 
	tId
;

45 
Id
 
	gid_
;

46 cڡ * 
	gfe_
;

47 
	gle_
;

48 cڡ * 
	gex_
;

49 
PdiCڋxt
* 
	gxt_
;

52 
Fau
* 
	gu_
;

55 as
	cTeResu
 {

56 
	gpublic
:

57 
TeResu
();

63 
	gPdiCڋxt
::
Id
 
ediId_
;

66 
PdiCڋxt
* 
	gediSckTa_
;

68 
tTeName
(cڡ 
JSONCPP_STRING
& 
me
);

71 
	gTeResu
&

72 
addFau
(cڡ * 
fe
, 
le
, cڡ * 
ex
 = 0);

77 
	gTeResu
& 
pPdiCڋxt
();

79 
bo
 
ed
() const;

81 
tFau
(
bo
 
tTeName
) const;

84 
	gme
 <
tyme
 
	gT
> 
	gTeResu
& 
	gݔ
<<(cڡ T& 
	gvue
) {

85 
JSONCPP_OSTRINGSTREAM
 
	goss
;

86 
	goss
.
ecisi
(16);

87 
	goss
.
tf
(
d
::
ios_ba
::
tfld
);

88 
	goss
 << 
	gvue
;

89  
addToLaFau
(
oss
.
r
());

93 
	gTeResu
& 
	gݔ
<<(
bo
 
	gvue
);

95 
	gTeResu
& 
	gݔ
<<(
	gJs
::
I64
 
vue
);

96 
	gTeResu
& 
	gݔ
<<(
	gJs
::
UI64
 
vue
);

98 
	give
:

99 
TeResu
& 
addToLaFau
(cڡ 
JSONCPP_STRING
& 
mesge
);

100 
gAsiNegLev
() const;

102 
addFauInfo
(cڡ * 
fe
,

103 
le
,

104 cڡ * 
ex
,

105 
ágLev
);

106 
JSONCPP_STRING
 
dtText
(cڡ JSONCPP_STRING& 
xt
,

107 cڡ 
JSONCPP_STRING
& 
dt
);

109 
	gd
::
	tdeque
<
	tFau
> 
	tFaus
;

110 
Faus
 
	gus_
;

111 
JSONCPP_STRING
 
	gme_
;

112 
PdiCڋxt
 
	groPdiNode_
;

113 
	gPdiCڋxt
::
Id
 
ϡUdPdiId_
;

115 
Fau
* 
	gmesgeTg_
;

118 as
	cTeCa
 {

119 
	gpublic
:

120 
TeCa
();

122 
	gvtu
 ~
TeCa
();

124 
run
(
TeResu
& 
su
);

126 
vtu
 cڡ * 
Name
() const = 0;

128 
	geed
:

129 
TeResu
* 
su_
;

131 
	give
:

132 
vtu
 
runTeCa
() = 0;

136 
	gTeCa
* (*
	tTeCaFay
)();

138 as
	cRu
 {

139 
	gpublic
:

140 
Ru
();

143 
	gRu
& 
add
(
TeCaFay
 
y
);

149 
runCommdLe
(
gc
, cڡ * 
gv
[]) const;

152 
bo
 
runATe
(bo 
tSummy
) const;

155 
Cou
() const;

158 
JSONCPP_STRING
 
NameAt
(
dex
) const;

161 
runTeAt
(
dex
, 
TeResu
& 
su
) const;

163 
tUge
(cڡ * 
pName
);

165 
	give
:

166 
Ru
(cڡ Ru& 
h
);

167 
	gRu
& 
	gݔ
=(cڡ 
Ru
& 
h
);

169 
	give
:

170 
liTes
() const;

171 
bo
 
Index
(cڡ 
JSONCPP_STRING
& 
Name
, & 
dex
) const;

172 
evtDlogOnCsh
();

174 
	give
:

175 
d
::
	tdeque
<
	tTeCaFay
> 
	tFaܛs
;

176 
Faܛs
 
	gs_
;

179 
	gme
 <
tyme
 
	gT
,ym
	gU
>

180 
	gTeResu
& 
	$checkEqu
(
TeResu
& 
su
,

181 
T
 
exed
,

182 
U
 
au
,

183 cڡ * 
fe
,

184 
le
,

185 cڡ * 
ex
) {

186 i(
ic_
<
U
>(
exed
!
au
) {

187 
su
.
	`addFau
(
fe
, 
le
, 
ex
);

188 
su
 << "Exed: " << 
ic_
<
U
>(
exed
) << "\n";

189 
su
 << "Au : " << 
au
;

191  
su
;

192 
	}
}

194 
JSONCPP_STRING
 
ToJsSg
(cڡ * 
toCvt
);

195 
JSONCPP_STRING
 
ToJsSg
(JSONCPP_STRING 

);

196 #i
JSONCPP_USING_SECURE_MEMORY


197 
JSONCPP_STRING
 
ToJsSg
(
d
::
rg
 

);

200 
	gTeResu
& 
checkSgEqu
(
TeResu
& 
su
,

201 cڡ 
JSONCPP_STRING
& 
exed
,

202 cڡ 
JSONCPP_STRING
& 
au
,

203 cڡ * 
fe
,

204 
le
,

205 cڡ * 
ex
);

212 
	#JSONTEST_ASSERT
(
ex
) \

213 i(
ex
) { \

215 
su_
->
	`addFau
(
__FILE__
, 
__LINE__
, #ex)

	)

220 
	#JSONTEST_ASSERT_PRED
(
ex
) \

222 
JsTe
::
PdiCڋxt
 
_me_Cڋxt
 = { \

223 
su_
->
ediId_
, 
__FILE__
, 
__LINE__
, #ex, 
NULL
, NULL \

225 
su_
->
ediSckTa_
->
xt_
 = &
_me_Cڋxt
; \

226 
su_
->
ediId_
 += 1; \

227 
su_
->
ediSckTa_
 = &
_me_Cڋxt
; \

228 (
ex
); \

229 
su_
->
	`pPdiCڋxt
(); \

230 }

	)

233 
	#JSONTEST_ASSERT_EQUAL
(
exed
, 
au
) \

234 
JsTe
::
	`checkEqu
(*
su_
, \

235 
exed
, \

236 
au
, \

237 
__FILE__
, \

238 
__LINE__
, \

239 #exed " =" #au)

	)

242 
	#JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
au
) \

243 
JsTe
::
	`checkSgEqu
(*
su_
, \

244 
JsTe
::
	`ToJsSg
(
exed
), \

245 
JsTe
::
	`ToJsSg
(
au
), \

246 
__FILE__
, \

247 
__LINE__
, \

248 #exed " =" #au)

	)

251 
	#JSONTEST_ASSERT_THROWS
(
ex
) \

253 
bo
 
_thw
 = 
l
; \

254 
y
 { \

255 
ex
; \

257 
	`tch
 (...) { \

258 
_thw
 = 
ue
; \

260 i(!
_thw
) \

261 
su_
->
	`addFau
( \

262 
__FILE__
, 
__LINE__
, "expectedxceptionhrown: " #expr); \

263 }

	)

266 
	#JSONTEST_FIXTURE
(
FixtuTy
, 
me
) \

267 
ass
 
Te
##
FixtuTy
##
me
 : 
public
 FixtureType { \

268 
public
: \

269 
JsTe
::
TeCa
* 
	`y
() { \

270  
w
 
Te
##
FixtuTy
##
	`me
(); \

273 
public
: \

274 cڡ * 
	`Name
(cڡ 
JSONCPP_OVERRIDE
 {  #FixtureType "/" #name; } \

275 
	`runTeCa
(
JSONCPP_OVERRIDE
; \

278 
Te
##
FixtuTy
##
me
::
	`runTeCa
()

	)

280 
	#JSONTEST_FIXTURE_FACTORY
(
FixtuTy
, 
me
) \

281 &
Te
##
FixtuTy
##
me
::
y


	)

283 
	#JSONTEST_REGISTER_FIXTURE
(
ru
, 
FixtuTy
, 
me
) \

284 (
ru
).
	`add
(
	`JSONTEST_FIXTURE_FACTORY
(
FixtuTy
, 
me
))

	)

	@open_source/jsoncpp-1.7.2.no-abi/src/test_lib_json/main.cpp

6 
	~"jsڋ.h
"

7 
	~<js/cfig.h
>

8 
	~<js/js.h
>

9 
	~<crg
>

10 
	~<lims
>

11 
	~<sam
>

12 
	~<rg
>

13 
	~<iom
>

17 
	#kt32max
 
Js
::
Vue
::
maxI


	)

18 
	#kt32m
 
Js
::
Vue
::
mI


	)

19 
	#kut32max
 
Js
::
Vue
::
maxUI


	)

20 
	#kt64max
 
Js
::
Vue
::
maxI64


	)

21 
	#kt64m
 
Js
::
Vue
::
mI64


	)

22 
	#kut64max
 
Js
::
Vue
::
maxUI64


	)

26 cڡ 
	gkft32max
 = (
kt32max
);

27 cڡ 
	gkfut32max
 = (
kut32max
);

35 #i!
defed
(
JSON_USE_INT64_DOUBLE_CONVERSION
)

36 
le
 
	$ut64ToDoub
(
Js
::
UI64
 
vue
) {

37  
ic_
<>(
vue
);

38 
	}
}

40 
le
 
	$ut64ToDoub
(
Js
::
UI64
 
vue
) {

41  
ic_
<>(
Js
::
	`I64
(
vue
 / 2)) * 2.0 +

42 
ic_
<>(
Js
::
	`I64
(
vue
 & 1));

43 
	}
}

46 
	gVueTe
 : 
JsTe
::
TeCa
 {

47 
Js
::
Vue
 
nu_
;

48 
	gJs
::
Vue
 
emyAay_
;

49 
	gJs
::
Vue
 
emyObje_
;

50 
	gJs
::
Vue
 
g_
;

51 
	gJs
::
Vue
 
unsigdIeg_
;

52 
	gJs
::
Vue
 
smlUnsigdIeg_
;

53 
	gJs
::
Vue
 
_
;

54 
	gJs
::
Vue
 
t_
;

55 
	gJs
::
Vue
 
y1_
;

56 
	gJs
::
Vue
 
obje1_
;

57 
	gJs
::
Vue
 
emySg_
;

58 
	gJs
::
Vue
 
rg1_
;

59 
	gJs
::
Vue
 
rg_
;

60 
	gJs
::
Vue
 
ue_
;

61 
	gJs
::
Vue
 
l_
;

63 
VueTe
()

64 : 
emyAay_
(
Js
::
yVue
), 
emyObje_
(Js::
objeVue
),

65 
g_
(123456789), 
unsigdIeg_
(34567890u),

66 
smlUnsigdIeg_
(
Js
::
Vue
::
UI
(Js::Vue::
maxI
)),

67 
_
(1234.56789), 
t_
(0.00390625f), 
emySg_
(""), 
rg1_
("a"),

68 
rg_
("somexwh s"), 
ue_
(
ue
), 
l_
(
l
) {

69 
	gy1_
.
nd
(1234);

70 
	gobje1_
["id"] = 1234;

73 
	sIsCheck
 {

75 
IsCheck
();

77 
bo
 
	gisObje_
;

78 
bo
 
	gisAay_
;

79 
bo
 
	gisBo_
;

80 
bo
 
	gisSg_
;

81 
bo
 
	gisNu_
;

83 
bo
 
	gisI_
;

84 
bo
 
	gisI64_
;

85 
bo
 
	gisUI_
;

86 
bo
 
	gisUI64_
;

87 
bo
 
	gisIegl_
;

88 
bo
 
	gisDoub_
;

89 
bo
 
	gisNumic_
;

92 
checkCڡMembCou
(cڡ 
Js
::
Vue
& 
vue
,

93 
exedCou
);

95 
checkMembCou
(
Js
::
Vue
& 
vue
, 
exedCou
);

97 
checkIs
(cڡ 
Js
::
Vue
& 
vue
, cڡ 
IsCheck
& 
check
);

99 
checkIsLess
(cڡ 
Js
::
Vue
& 
x
, cڡ Js::Vue& 
y
);

101 
checkIsEqu
(cڡ 
Js
::
Vue
& 
x
, cڡ Js::Vue& 
y
);

105 
JSONCPP_STRING
 
nmizeFltgPotS
(cڡ JSONCPP_STRING& 
s
);

108 
JSONCPP_STRING
 
	gVueTe
::
	$nmizeFltgPotS
(cڡ 
JSONCPP_STRING
& 
s
) {

109 
JSONCPP_STRING
::
size_ty
 
dex
 = 
s
.
	`fd_ϡ_of
("eE");

110 i(
dex
 !
JSONCPP_STRING
::
os
) {

111 
JSONCPP_STRING
::
size_ty
 
hasSign
 =

112 (
s
[
dex
 + 1] == '+' || s[index + 1] == '-') ? 1 : 0;

113 
JSONCPP_STRING
::
size_ty
 
expڒtSIndex
 = 
dex
 + 1 + 
hasSign
;

114 
JSONCPP_STRING
 
nmized
 = 
s
.
	`subr
(0, 
expڒtSIndex
);

115 
JSONCPP_STRING
::
size_ty
 
dexDig
 =

116 
s
.
	`fd_f_n_of
('0', 
expڒtSIndex
);

117 
JSONCPP_STRING
 
expڒt
 = "0";

118 i(
dexDig
 !=

119 
JSONCPP_STRING
::
os
)

121 
expڒt
 = 
s
.
	`subr
(
dexDig
);

123  
nmized
 + 
expڒt
;

125  
s
;

126 
	}
}

128 
	$JSONTEST_FIXTURE
(
VueTe
, 
checkNmizeFltgPotS
) {

129 
	`JSONTEST_ASSERT_STRING_EQUAL
("0.0", 
	`nmizeFltgPotS
("0.0"));

130 
	`JSONTEST_ASSERT_STRING_EQUAL
("0e0", 
	`nmizeFltgPotS
("0e0"));

131 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234.0", 
	`nmizeFltgPotS
("1234.0"));

132 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234.0e0",

133 
	`nmizeFltgPotS
("1234.0e0"));

134 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234.0e+0",

135 
	`nmizeFltgPotS
("1234.0e+0"));

136 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e-1", 
	`nmizeFltgPotS
("1234e-1"));

137 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e10", 
	`nmizeFltgPotS
("1234e10"));

138 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e10",

139 
	`nmizeFltgPotS
("1234e010"));

140 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e+10",

141 
	`nmizeFltgPotS
("1234e+010"));

142 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e-10",

143 
	`nmizeFltgPotS
("1234e-010"));

144 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e+100",

145 
	`nmizeFltgPotS
("1234e+100"));

146 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e-100",

147 
	`nmizeFltgPotS
("1234e-100"));

148 
	`JSONTEST_ASSERT_STRING_EQUAL
("1234e+1",

149 
	`nmizeFltgPotS
("1234e+001"));

150 
	}
}

152 
	$JSONTEST_FIXTURE
(
VueTe
, 
membCou
) {

153 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
emyAay_
, 0));

154 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
emyObje_
, 0));

155 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
y1_
, 1));

156 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
obje1_
, 1));

157 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
nu_
, 0));

158 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
g_
, 0));

159 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
unsigdIeg_
, 0));

160 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
smlUnsigdIeg_
, 0));

161 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
_
, 0));

162 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
emySg_
, 0));

163 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
rg_
, 0));

164 
	`JSONTEST_ASSERT_PRED
(
	`checkMembCou
(
ue_
, 0));

165 
	}
}

167 
	$JSONTEST_FIXTURE
(
VueTe
, 
objes
) {

169 
IsCheck
 
checks
;

170 
checks
.
isObje_
 = 
ue
;

171 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
emyObje_
, 
checks
));

172 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
obje1_
, 
checks
));

174 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
objeVue
, 
emyObje_
.
	`ty
());

177 
	`JSONTEST_ASSERT
(
emyObje_
.
	`isCvtibTo
(
Js
::
nuVue
));

180 
	`JSONTEST_ASSERT
(!
obje1_
.
	`isCvtibTo
(
Js
::
nuVue
));

183 
	`JSONTEST_ASSERT
(
emyObje_
.
	`isCvtibTo
(
Js
::
objeVue
));

186 
	`JSONTEST_ASSERT
(!
emyObje_
.
	`isCvtibTo
(
Js
::
yVue
));

187 
	`JSONTEST_ASSERT
(!
emyObje_
.
	`isCvtibTo
(
Js
::
tVue
));

188 
	`JSONTEST_ASSERT
(!
emyObje_
.
	`isCvtibTo
(
Js
::
utVue
));

189 
	`JSONTEST_ASSERT
(!
emyObje_
.
	`isCvtibTo
(
Js
::
Vue
));

190 
	`JSONTEST_ASSERT
(!
emyObje_
.
	`isCvtibTo
(
Js
::
boޗnVue
));

191 
	`JSONTEST_ASSERT
(!
emyObje_
.
	`isCvtibTo
(
Js
::
rgVue
));

194 cڡ 
Js
::
Vue
& 
cڡObje
 = 
obje1_
;

196 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(1234), 
cڡObje
["id"]);

197 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(), 
cڡObje
["unknown id"]);

200 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(1234), 
obje1_
["id"]);

201 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(), 
obje1_
["unknown id"]);

203 
obje1_
["some other id"] = "foo";

204 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
("foo"), 
obje1_
["some other id"]);

205 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
("foo"), 
obje1_
["some other id"]);

208 
Js
::
Vue
 
g
;

209 
bo
 
did
;

210 
did
 = 
obje1_
.
	`moveMemb
("somh id", &
g
);

211 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
("foo"), 
g
);

212 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
did
);

213 
g
 = 
Js
::
	`Vue
("bar");

214 
did
 = 
obje1_
.
	`moveMemb
("somh id", &
g
);

215 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
("b"), 
g
);

216 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
did
);

217 
	}
}

219 
	$JSONTEST_FIXTURE
(
VueTe
, 
ys
) {

220 cڡ 
dex0
 = 0;

223 
IsCheck
 
checks
;

224 
checks
.
isAay_
 = 
ue
;

225 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
emyAay_
, 
checks
));

226 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
y1_
, 
checks
));

228 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
yVue
, 
y1_
.
	`ty
());

231 
	`JSONTEST_ASSERT
(
emyAay_
.
	`isCvtibTo
(
Js
::
nuVue
));

234 
	`JSONTEST_ASSERT
(!
y1_
.
	`isCvtibTo
(
Js
::
nuVue
));

237 
	`JSONTEST_ASSERT
(
emyAay_
.
	`isCvtibTo
(
Js
::
yVue
));

240 
	`JSONTEST_ASSERT
(!
emyAay_
.
	`isCvtibTo
(
Js
::
objeVue
));

241 
	`JSONTEST_ASSERT
(!
emyAay_
.
	`isCvtibTo
(
Js
::
tVue
));

242 
	`JSONTEST_ASSERT
(!
emyAay_
.
	`isCvtibTo
(
Js
::
utVue
));

243 
	`JSONTEST_ASSERT
(!
emyAay_
.
	`isCvtibTo
(
Js
::
Vue
));

244 
	`JSONTEST_ASSERT
(!
emyAay_
.
	`isCvtibTo
(
Js
::
boޗnVue
));

245 
	`JSONTEST_ASSERT
(!
emyAay_
.
	`isCvtibTo
(
Js
::
rgVue
));

248 cڡ 
Js
::
Vue
& 
cڡAay
 = 
y1_
;

249 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(1234), 
cڡAay
[
dex0
]);

250 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(1234), 
cڡAay
[0]);

253 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(1234), 
y1_
[
dex0
]);

254 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(1234), 
y1_
[0]);

256 
y1_
[2] = 
Js
::
	`Vue
(17);

257 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(), 
y1_
[1]);

258 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(17), 
y1_
[2]);

259 
Js
::
Vue
 
g
;

260 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
y1_
.
	`moveIndex
(2, &
g
));

261 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(17), 
g
);

262 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
y1_
.
	`moveIndex
(2, &
g
));

263 
	}
}

264 
	$JSONTEST_FIXTURE
(
VueTe
, 
yIssue252
)

266 
cou
 = 5;

267 
Js
::
Vue
 
ro
;

268 
Js
::
Vue
 
em
;

269 
ro
["y"] = 
Js
::
Vue
::
nuRef
;

270 
i
 = 0; i < 
cou
; i++)

272 
em
["a"] = 
i
;

273 
em
["b"] = 
i
;

274 
ro
["y"][
i
] = 
em
;

277 
	}
}

279 
	$JSONTEST_FIXTURE
(
VueTe
, 
nu
) {

280 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
nuVue
, 
nu_
.
	`ty
());

282 
IsCheck
 
checks
;

283 
checks
.
isNu_
 = 
ue
;

284 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
nu_
, 
checks
));

286 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
nuVue
));

287 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
tVue
));

288 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
utVue
));

289 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
Vue
));

290 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
boޗnVue
));

291 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
rgVue
));

292 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
yVue
));

293 
	`JSONTEST_ASSERT
(
nu_
.
	`isCvtibTo
(
Js
::
objeVue
));

295 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`I
(0), 
nu_
.
	`asI
());

296 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`LgeI
(0), 
nu_
.
	`asLgeI
());

297 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`UI
(0), 
nu_
.
	`asUI
());

298 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`LgeUI
(0), 
nu_
.
	`asLgeUI
());

299 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
nu_
.
	`asDoub
());

300 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
nu_
.
	`asFlt
());

301 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
nu_
.
	`asSg
());

303 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
::
nu
, 
nu_
);

304 
	}
}

306 
	$JSONTEST_FIXTURE
(
VueTe
, 
rgs
) {

307 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
rgVue
, 
rg1_
.
	`ty
());

309 
IsCheck
 
checks
;

310 
checks
.
isSg_
 = 
ue
;

311 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
emySg_
, 
checks
));

312 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
rg_
, 
checks
));

313 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
rg1_
, 
checks
));

316 
	`JSONTEST_ASSERT
(
emySg_
.
	`isCvtibTo
(
Js
::
nuVue
));

319 
	`JSONTEST_ASSERT
(!
rg1_
.
	`isCvtibTo
(
Js
::
nuVue
));

322 
	`JSONTEST_ASSERT
(
rg1_
.
	`isCvtibTo
(
Js
::
rgVue
));

325 
	`JSONTEST_ASSERT
(!
rg1_
.
	`isCvtibTo
(
Js
::
objeVue
));

326 
	`JSONTEST_ASSERT
(!
rg1_
.
	`isCvtibTo
(
Js
::
yVue
));

327 
	`JSONTEST_ASSERT
(!
rg1_
.
	`isCvtibTo
(
Js
::
tVue
));

328 
	`JSONTEST_ASSERT
(!
rg1_
.
	`isCvtibTo
(
Js
::
utVue
));

329 
	`JSONTEST_ASSERT
(!
rg1_
.
	`isCvtibTo
(
Js
::
Vue
));

331 
	`JSONTEST_ASSERT_STRING_EQUAL
("a", 
rg1_
.
	`asSg
());

332 
	`JSONTEST_ASSERT_STRING_EQUAL
("a", 
rg1_
.
	`asCSg
());

333 
	}
}

335 
	$JSONTEST_FIXTURE
(
VueTe
, 
bos
) {

336 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
boޗnVue
, 
l_
.
	`ty
());

338 
IsCheck
 
checks
;

339 
checks
.
isBo_
 = 
ue
;

340 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
l_
, 
checks
));

341 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
ue_
, 
checks
));

344 
	`JSONTEST_ASSERT
(
l_
.
	`isCvtibTo
(
Js
::
nuVue
));

347 
	`JSONTEST_ASSERT
(!
ue_
.
	`isCvtibTo
(
Js
::
nuVue
));

350 
	`JSONTEST_ASSERT
(
ue_
.
	`isCvtibTo
(
Js
::
tVue
));

351 
	`JSONTEST_ASSERT
(
ue_
.
	`isCvtibTo
(
Js
::
utVue
));

352 
	`JSONTEST_ASSERT
(
ue_
.
	`isCvtibTo
(
Js
::
Vue
));

353 
	`JSONTEST_ASSERT
(
ue_
.
	`isCvtibTo
(
Js
::
boޗnVue
));

354 
	`JSONTEST_ASSERT
(
ue_
.
	`isCvtibTo
(
Js
::
rgVue
));

357 
	`JSONTEST_ASSERT
(!
ue_
.
	`isCvtibTo
(
Js
::
yVue
));

358 
	`JSONTEST_ASSERT
(!
ue_
.
	`isCvtibTo
(
Js
::
objeVue
));

360 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
ue_
.
	`asBo
());

361 
	`JSONTEST_ASSERT_EQUAL
(1, 
ue_
.
	`asI
());

362 
	`JSONTEST_ASSERT_EQUAL
(1, 
ue_
.
	`asLgeI
());

363 
	`JSONTEST_ASSERT_EQUAL
(1, 
ue_
.
	`asUI
());

364 
	`JSONTEST_ASSERT_EQUAL
(1, 
ue_
.
	`asLgeUI
());

365 
	`JSONTEST_ASSERT_EQUAL
(1.0, 
ue_
.
	`asDoub
());

366 
	`JSONTEST_ASSERT_EQUAL
(1.0, 
ue_
.
	`asFlt
());

368 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
l_
.
	`asBo
());

369 
	`JSONTEST_ASSERT_EQUAL
(0, 
l_
.
	`asI
());

370 
	`JSONTEST_ASSERT_EQUAL
(0, 
l_
.
	`asLgeI
());

371 
	`JSONTEST_ASSERT_EQUAL
(0, 
l_
.
	`asUI
());

372 
	`JSONTEST_ASSERT_EQUAL
(0, 
l_
.
	`asLgeUI
());

373 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
l_
.
	`asDoub
());

374 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
l_
.
	`asFlt
());

375 
	}
}

377 
	$JSONTEST_FIXTURE
(
VueTe
, 
gs
) {

378 
IsCheck
 
checks
;

379 
Js
::
Vue
 
v
;

382 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17).
	`isCvtibTo
(Js::
Vue
));

383 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17).
	`isCvtibTo
(Js::
rgVue
));

384 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17).
	`isCvtibTo
(Js::
boޗnVue
));

385 
	`JSONTEST_ASSERT
(!
Js
::
	`Vue
(17).
	`isCvtibTo
(Js::
yVue
));

386 
	`JSONTEST_ASSERT
(!
Js
::
	`Vue
(17).
	`isCvtibTo
(Js::
objeVue
));

388 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17U).
	`isCvtibTo
(Js::
Vue
));

389 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17U).
	`isCvtibTo
(Js::
rgVue
));

390 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17U).
	`isCvtibTo
(Js::
boޗnVue
));

391 
	`JSONTEST_ASSERT
(!
Js
::
	`Vue
(17U).
	`isCvtibTo
(Js::
yVue
));

392 
	`JSONTEST_ASSERT
(!
Js
::
	`Vue
(17U).
	`isCvtibTo
(Js::
objeVue
));

394 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17.0).
	`isCvtibTo
(Js::
Vue
));

395 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17.0).
	`isCvtibTo
(Js::
rgVue
));

396 
	`JSONTEST_ASSERT
(
Js
::
	`Vue
(17.0).
	`isCvtibTo
(Js::
boޗnVue
));

397 
	`JSONTEST_ASSERT
(!
Js
::
	`Vue
(17.0).
	`isCvtibTo
(Js::
yVue
));

398 
	`JSONTEST_ASSERT
(!
Js
::
	`Vue
(17.0).
	`isCvtibTo
(Js::
objeVue
));

401 
v
 = 
Js
::
	`Vue
(Js::
tVue
);

403 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

405 
checks
 = 
	`IsCheck
();

406 
checks
.
isI_
 = 
ue
;

407 
checks
.
isI64_
 = 
ue
;

408 
checks
.
isUI_
 = 
ue
;

409 
checks
.
isUI64_
 = 
ue
;

410 
checks
.
isIegl_
 = 
ue
;

411 
checks
.
isDoub_
 = 
ue
;

412 
checks
.
isNumic_
 = 
ue
;

413 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

415 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
nuVue
));

416 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

417 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

419 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asI
());

420 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeI
());

421 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asUI
());

422 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeUI
());

423 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asDoub
());

424 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asFlt
());

425 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
v
.
	`asBo
());

426 
	`JSONTEST_ASSERT_STRING_EQUAL
("0", 
v
.
	`asSg
());

429 
v
 = 
Js
::
	`Vue
(Js::
utVue
);

431 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
utVue
, 
v
.
	`ty
());

433 
checks
 = 
	`IsCheck
();

434 
checks
.
isI_
 = 
ue
;

435 
checks
.
isI64_
 = 
ue
;

436 
checks
.
isUI_
 = 
ue
;

437 
checks
.
isUI64_
 = 
ue
;

438 
checks
.
isIegl_
 = 
ue
;

439 
checks
.
isDoub_
 = 
ue
;

440 
checks
.
isNumic_
 = 
ue
;

441 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

443 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
nuVue
));

444 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

445 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

447 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asI
());

448 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeI
());

449 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asUI
());

450 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeUI
());

451 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asDoub
());

452 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asFlt
());

453 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
v
.
	`asBo
());

454 
	`JSONTEST_ASSERT_STRING_EQUAL
("0", 
v
.
	`asSg
());

457 
v
 = 
Js
::
	`Vue
(Js::
Vue
);

459 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

461 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
nuVue
));

462 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

463 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

465 
checks
 = 
	`IsCheck
();

466 
checks
.
isI_
 = 
ue
;

467 
checks
.
isI64_
 = 
ue
;

468 
checks
.
isUI_
 = 
ue
;

469 
checks
.
isUI64_
 = 
ue
;

470 
checks
.
isIegl_
 = 
ue
;

471 
checks
.
isDoub_
 = 
ue
;

472 
checks
.
isNumic_
 = 
ue
;

473 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

475 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asI
());

476 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeI
());

477 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asUI
());

478 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeUI
());

479 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asDoub
());

480 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asFlt
());

481 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
v
.
	`asBo
());

482 
	`JSONTEST_ASSERT_STRING_EQUAL
("0", 
v
.
	`asSg
());

485 
v
 = 
Js
::
	`Vue
(0);

487 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

489 
checks
 = 
	`IsCheck
();

490 
checks
.
isI_
 = 
ue
;

491 
checks
.
isI64_
 = 
ue
;

492 
checks
.
isUI_
 = 
ue
;

493 
checks
.
isUI64_
 = 
ue
;

494 
checks
.
isIegl_
 = 
ue
;

495 
checks
.
isDoub_
 = 
ue
;

496 
checks
.
isNumic_
 = 
ue
;

497 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

499 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
nuVue
));

500 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

501 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

503 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asI
());

504 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeI
());

505 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asUI
());

506 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeUI
());

507 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asDoub
());

508 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asFlt
());

509 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
v
.
	`asBo
());

510 
	`JSONTEST_ASSERT_STRING_EQUAL
("0", 
v
.
	`asSg
());

513 
v
 = 
Js
::
	`Vue
(0u);

515 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
utVue
, 
v
.
	`ty
());

517 
checks
 = 
	`IsCheck
();

518 
checks
.
isI_
 = 
ue
;

519 
checks
.
isI64_
 = 
ue
;

520 
checks
.
isUI_
 = 
ue
;

521 
checks
.
isUI64_
 = 
ue
;

522 
checks
.
isIegl_
 = 
ue
;

523 
checks
.
isDoub_
 = 
ue
;

524 
checks
.
isNumic_
 = 
ue
;

525 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

527 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
nuVue
));

528 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

529 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

531 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asI
());

532 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeI
());

533 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asUI
());

534 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeUI
());

535 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asDoub
());

536 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asFlt
());

537 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
v
.
	`asBo
());

538 
	`JSONTEST_ASSERT_STRING_EQUAL
("0", 
v
.
	`asSg
());

541 
v
 = 
Js
::
	`Vue
(0.0);

543 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

545 
checks
 = 
	`IsCheck
();

546 
checks
.
isI_
 = 
ue
;

547 
checks
.
isI64_
 = 
ue
;

548 
checks
.
isUI_
 = 
ue
;

549 
checks
.
isUI64_
 = 
ue
;

550 
checks
.
isIegl_
 = 
ue
;

551 
checks
.
isDoub_
 = 
ue
;

552 
checks
.
isNumic_
 = 
ue
;

553 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

555 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
nuVue
));

556 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

557 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

559 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asI
());

560 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeI
());

561 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asUI
());

562 
	`JSONTEST_ASSERT_EQUAL
(0, 
v
.
	`asLgeUI
());

563 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asDoub
());

564 
	`JSONTEST_ASSERT_EQUAL
(0.0, 
v
.
	`asFlt
());

565 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
v
.
	`asBo
());

566 
	`JSONTEST_ASSERT_STRING_EQUAL
("0", 
v
.
	`asSg
());

569 
v
 = 
Js
::
	`Vue
(1 << 20);

571 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

572 
checks
 = 
	`IsCheck
();

573 
checks
.
isI_
 = 
ue
;

574 
checks
.
isI64_
 = 
ue
;

575 
checks
.
isUI_
 = 
ue
;

576 
checks
.
isUI64_
 = 
ue
;

577 
checks
.
isIegl_
 = 
ue
;

578 
checks
.
isDoub_
 = 
ue
;

579 
checks
.
isNumic_
 = 
ue
;

580 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

582 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

583 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

584 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

586 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asI
());

587 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asLgeI
());

588 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asUI
());

589 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asLgeUI
());

590 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asDoub
());

591 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asFlt
());

592 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

593 
	`JSONTEST_ASSERT_STRING_EQUAL
("1048576", 
v
.
	`asSg
());

596 
v
 = 
Js
::
	`Vue
(Js::
	`UI
(1 << 20));

598 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
utVue
, 
v
.
	`ty
());

600 
checks
 = 
	`IsCheck
();

601 
checks
.
isI_
 = 
ue
;

602 
checks
.
isI64_
 = 
ue
;

603 
checks
.
isUI_
 = 
ue
;

604 
checks
.
isUI64_
 = 
ue
;

605 
checks
.
isIegl_
 = 
ue
;

606 
checks
.
isDoub_
 = 
ue
;

607 
checks
.
isNumic_
 = 
ue
;

608 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

610 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

611 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

612 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

614 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asI
());

615 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asLgeI
());

616 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asUI
());

617 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asLgeUI
());

618 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asDoub
());

619 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asFlt
());

620 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

621 
	`JSONTEST_ASSERT_STRING_EQUAL
("1048576", 
v
.
	`asSg
());

624 
v
 = 
Js
::
	`Vue
((1 << 20) / 1.0);

626 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

628 
checks
 = 
	`IsCheck
();

629 
checks
.
isI_
 = 
ue
;

630 
checks
.
isI64_
 = 
ue
;

631 
checks
.
isUI_
 = 
ue
;

632 
checks
.
isUI64_
 = 
ue
;

633 
checks
.
isIegl_
 = 
ue
;

634 
checks
.
isDoub_
 = 
ue
;

635 
checks
.
isNumic_
 = 
ue
;

636 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

638 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

639 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

640 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

642 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asI
());

643 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asLgeI
());

644 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asUI
());

645 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asLgeUI
());

646 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asDoub
());

647 
	`JSONTEST_ASSERT_EQUAL
((1 << 20), 
v
.
	`asFlt
());

648 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

649 
	`JSONTEST_ASSERT_STRING_EQUAL
("1048576",

650 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

653 
v
 = 
Js
::
	`Vue
(-(1 << 20));

655 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

657 
checks
 = 
	`IsCheck
();

658 
checks
.
isI_
 = 
ue
;

659 
checks
.
isI64_
 = 
ue
;

660 
checks
.
isIegl_
 = 
ue
;

661 
checks
.
isDoub_
 = 
ue
;

662 
checks
.
isNumic_
 = 
ue
;

663 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

665 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

666 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

667 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

669 
	`JSONTEST_ASSERT_EQUAL
(-(1 << 20), 
v
.
	`asI
());

670 
	`JSONTEST_ASSERT_EQUAL
(-(1 << 20), 
v
.
	`asLgeI
());

671 
	`JSONTEST_ASSERT_EQUAL
(-(1 << 20), 
v
.
	`asDoub
());

672 
	`JSONTEST_ASSERT_EQUAL
(-(1 << 20), 
v
.
	`asFlt
());

673 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

674 
	`JSONTEST_ASSERT_STRING_EQUAL
("-1048576", 
v
.
	`asSg
());

677 
v
 = 
Js
::
	`Vue
(
kt32max
);

679 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

681 
checks
 = 
	`IsCheck
();

682 
checks
.
isI_
 = 
ue
;

683 
checks
.
isI64_
 = 
ue
;

684 
checks
.
isUI_
 = 
ue
;

685 
checks
.
isUI64_
 = 
ue
;

686 
checks
.
isIegl_
 = 
ue
;

687 
checks
.
isDoub_
 = 
ue
;

688 
checks
.
isNumic_
 = 
ue
;

689 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

691 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

692 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

693 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

695 
	`JSONTEST_ASSERT_EQUAL
(
kt32max
, 
v
.
	`asI
());

696 
	`JSONTEST_ASSERT_EQUAL
(
kt32max
, 
v
.
	`asLgeI
());

697 
	`JSONTEST_ASSERT_EQUAL
(
kt32max
, 
v
.
	`asUI
());

698 
	`JSONTEST_ASSERT_EQUAL
(
kt32max
, 
v
.
	`asLgeUI
());

699 
	`JSONTEST_ASSERT_EQUAL
(
kt32max
, 
v
.
	`asDoub
());

700 
	`JSONTEST_ASSERT_EQUAL
(
kft32max
, 
v
.
	`asFlt
());

701 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

702 
	`JSONTEST_ASSERT_STRING_EQUAL
("2147483647", 
v
.
	`asSg
());

705 
v
 = 
Js
::
	`Vue
(
kt32m
);

707 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

709 
checks
 = 
	`IsCheck
();

710 
checks
.
isI_
 = 
ue
;

711 
checks
.
isI64_
 = 
ue
;

712 
checks
.
isIegl_
 = 
ue
;

713 
checks
.
isDoub_
 = 
ue
;

714 
checks
.
isNumic_
 = 
ue
;

715 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

717 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

718 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

719 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

721 
	`JSONTEST_ASSERT_EQUAL
(
kt32m
, 
v
.
	`asI
());

722 
	`JSONTEST_ASSERT_EQUAL
(
kt32m
, 
v
.
	`asLgeI
());

723 
	`JSONTEST_ASSERT_EQUAL
(
kt32m
, 
v
.
	`asDoub
());

724 
	`JSONTEST_ASSERT_EQUAL
(
kt32m
, 
v
.
	`asFlt
());

725 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

726 
	`JSONTEST_ASSERT_STRING_EQUAL
("-2147483648", 
v
.
	`asSg
());

729 
v
 = 
Js
::
	`Vue
(
kut32max
);

731 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
utVue
, 
v
.
	`ty
());

733 
checks
 = 
	`IsCheck
();

734 
checks
.
isI64_
 = 
ue
;

735 
checks
.
isUI_
 = 
ue
;

736 
checks
.
isUI64_
 = 
ue
;

737 
checks
.
isIegl_
 = 
ue
;

738 
checks
.
isDoub_
 = 
ue
;

739 
checks
.
isNumic_
 = 
ue
;

740 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

742 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

743 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

744 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

746 #ide
JSON_NO_INT64


747 
	`JSONTEST_ASSERT_EQUAL
(
kut32max
, 
v
.
	`asLgeI
());

749 
	`JSONTEST_ASSERT_EQUAL
(
kut32max
, 
v
.
	`asUI
());

750 
	`JSONTEST_ASSERT_EQUAL
(
kut32max
, 
v
.
	`asLgeUI
());

751 
	`JSONTEST_ASSERT_EQUAL
(
kut32max
, 
v
.
	`asDoub
());

752 
	`JSONTEST_ASSERT_EQUAL
(
kfut32max
, 
v
.
	`asFlt
());

753 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

754 
	`JSONTEST_ASSERT_STRING_EQUAL
("4294967295", 
v
.
	`asSg
());

756 #ifde
JSON_NO_INT64


758 
v
 = 
Js
::
	`Vue
((
kt64max
));

760 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

762 
checks
 = 
	`IsCheck
();

763 
checks
.
isDoub_
 = 
ue
;

764 
checks
.
isNumic_
 = 
ue
;

765 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

767 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

768 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

769 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

771 
	`JSONTEST_ASSERT_EQUAL
((
kt64max
), 
v
.
	`asDoub
());

772 
	`JSONTEST_ASSERT_EQUAL
((
kt64max
), 
v
.
	`asFlt
());

773 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

774 
	`JSONTEST_ASSERT_STRING_EQUAL
("9.22337e+18", 
v
.
	`asSg
());

777 
v
 = 
Js
::
	`Vue
((
kt64m
));

779 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

781 
checks
 = 
	`IsCheck
();

782 
checks
.
isDoub_
 = 
ue
;

783 
checks
.
isNumic_
 = 
ue
;

784 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

786 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

787 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

788 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

790 
	`JSONTEST_ASSERT_EQUAL
((
kt64m
), 
v
.
	`asDoub
());

791 
	`JSONTEST_ASSERT_EQUAL
((
kt64m
), 
v
.
	`asFlt
());

792 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

793 
	`JSONTEST_ASSERT_STRING_EQUAL
("-9.22337e+18", 
v
.
	`asSg
());

796 
v
 = 
Js
::
	`Vue
((
kut64max
));

798 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

800 
checks
 = 
	`IsCheck
();

801 
checks
.
isDoub_
 = 
ue
;

802 
checks
.
isNumic_
 = 
ue
;

803 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

805 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

806 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

807 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

809 
	`JSONTEST_ASSERT_EQUAL
((
kut64max
), 
v
.
	`asDoub
());

810 
	`JSONTEST_ASSERT_EQUAL
((
kut64max
), 
v
.
	`asFlt
());

811 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

812 
	`JSONTEST_ASSERT_STRING_EQUAL
("1.84467e+19", 
v
.
	`asSg
());

815 
v
 = 
Js
::
	`Vue
(Js::
	`I64
(1) << 40);

817 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

819 
checks
 = 
	`IsCheck
();

820 
checks
.
isI64_
 = 
ue
;

821 
checks
.
isUI64_
 = 
ue
;

822 
checks
.
isIegl_
 = 
ue
;

823 
checks
.
isDoub_
 = 
ue
;

824 
checks
.
isNumic_
 = 
ue
;

825 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

827 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

828 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

829 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

831 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asI64
());

832 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asLgeI
());

833 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asUI64
());

834 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asLgeUI
());

835 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asDoub
());

836 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asFlt
());

837 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

838 
	`JSONTEST_ASSERT_STRING_EQUAL
("1099511627776", 
v
.
	`asSg
());

841 
v
 = 
Js
::
	`Vue
(Js::
	`UI64
(1) << 40);

843 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
utVue
, 
v
.
	`ty
());

845 
checks
 = 
	`IsCheck
();

846 
checks
.
isI64_
 = 
ue
;

847 
checks
.
isUI64_
 = 
ue
;

848 
checks
.
isIegl_
 = 
ue
;

849 
checks
.
isDoub_
 = 
ue
;

850 
checks
.
isNumic_
 = 
ue
;

851 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

853 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

854 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

855 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

857 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asI64
());

858 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asLgeI
());

859 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asUI64
());

860 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asLgeUI
());

861 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asDoub
());

862 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asFlt
());

863 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

864 
	`JSONTEST_ASSERT_STRING_EQUAL
("1099511627776", 
v
.
	`asSg
());

867 
v
 = 
Js
::
	`Vue
((Js::
	`I64
(1) << 40) / 1.0);

869 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

871 
checks
 = 
	`IsCheck
();

872 
checks
.
isI64_
 = 
ue
;

873 
checks
.
isUI64_
 = 
ue
;

874 
checks
.
isIegl_
 = 
ue
;

875 
checks
.
isDoub_
 = 
ue
;

876 
checks
.
isNumic_
 = 
ue
;

877 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

879 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

880 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

881 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

883 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asI64
());

884 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asLgeI
());

885 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asUI64
());

886 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asLgeUI
());

887 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asDoub
());

888 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 40), 
v
.
	`asFlt
());

889 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

890 
	`JSONTEST_ASSERT_STRING_EQUAL
("1099511627776",

891 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

894 
v
 = 
Js
::
	`Vue
(-(Js::
	`I64
(1) << 40));

896 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

898 
checks
 = 
	`IsCheck
();

899 
checks
.
isI64_
 = 
ue
;

900 
checks
.
isIegl_
 = 
ue
;

901 
checks
.
isDoub_
 = 
ue
;

902 
checks
.
isNumic_
 = 
ue
;

903 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

905 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

906 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

907 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

909 
	`JSONTEST_ASSERT_EQUAL
(-(
Js
::
	`I64
(1<< 40), 
v
.
	`asI64
());

910 
	`JSONTEST_ASSERT_EQUAL
(-(
Js
::
	`I64
(1<< 40), 
v
.
	`asLgeI
());

911 
	`JSONTEST_ASSERT_EQUAL
(-(
Js
::
	`I64
(1<< 40), 
v
.
	`asDoub
());

912 
	`JSONTEST_ASSERT_EQUAL
(-(
Js
::
	`I64
(1<< 40), 
v
.
	`asFlt
());

913 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

914 
	`JSONTEST_ASSERT_STRING_EQUAL
("-1099511627776", 
v
.
	`asSg
());

917 
v
 = 
Js
::
	`Vue
(Js::
	`I64
(
kt64max
));

919 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

921 
checks
 = 
	`IsCheck
();

922 
checks
.
isI64_
 = 
ue
;

923 
checks
.
isUI64_
 = 
ue
;

924 
checks
.
isIegl_
 = 
ue
;

925 
checks
.
isDoub_
 = 
ue
;

926 
checks
.
isNumic_
 = 
ue
;

927 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

929 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

930 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

931 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

933 
	`JSONTEST_ASSERT_EQUAL
(
kt64max
, 
v
.
	`asI64
());

934 
	`JSONTEST_ASSERT_EQUAL
(
kt64max
, 
v
.
	`asLgeI
());

935 
	`JSONTEST_ASSERT_EQUAL
(
kt64max
, 
v
.
	`asUI64
());

936 
	`JSONTEST_ASSERT_EQUAL
(
kt64max
, 
v
.
	`asLgeUI
());

937 
	`JSONTEST_ASSERT_EQUAL
((
kt64max
), 
v
.
	`asDoub
());

938 
	`JSONTEST_ASSERT_EQUAL
((
kt64max
), 
v
.
	`asFlt
());

939 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

940 
	`JSONTEST_ASSERT_STRING_EQUAL
("9223372036854775807", 
v
.
	`asSg
());

944 
v
 = 
Js
::
	`Vue
((
kt64max
));

946 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

948 
checks
 = 
	`IsCheck
();

949 
checks
.
isUI64_
 = 
ue
;

950 
checks
.
isIegl_
 = 
ue
;

951 
checks
.
isDoub_
 = 
ue
;

952 
checks
.
isNumic_
 = 
ue
;

953 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

955 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

956 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

957 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

959 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`UI64
(1<< 63, 
v
.
	`asUI64
());

960 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`UI64
(1<< 63, 
v
.
	`asLgeUI
());

961 
	`JSONTEST_ASSERT_EQUAL
(
	`ut64ToDoub
(
Js
::
	`UI64
(1<< 63), 
v
.
	`asDoub
());

962 
	`JSONTEST_ASSERT_EQUAL
((
	`ut64ToDoub
(
Js
::
	`UI64
(1) << 63)),

963 
v
.
	`asFlt
());

964 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

965 
	`JSONTEST_ASSERT_STRING_EQUAL
("9.2233720368547758e+18",

966 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

969 
v
 = 
Js
::
	`Vue
(Js::
	`I64
(
kt64m
));

971 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
tVue
, 
v
.
	`ty
());

973 
checks
 = 
	`IsCheck
();

974 
checks
.
isI64_
 = 
ue
;

975 
checks
.
isIegl_
 = 
ue
;

976 
checks
.
isDoub_
 = 
ue
;

977 
checks
.
isNumic_
 = 
ue
;

978 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

980 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

981 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

982 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

984 
	`JSONTEST_ASSERT_EQUAL
(
kt64m
, 
v
.
	`asI64
());

985 
	`JSONTEST_ASSERT_EQUAL
(
kt64m
, 
v
.
	`asLgeI
());

986 
	`JSONTEST_ASSERT_EQUAL
((
kt64m
), 
v
.
	`asDoub
());

987 
	`JSONTEST_ASSERT_EQUAL
((
kt64m
), 
v
.
	`asFlt
());

988 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

989 
	`JSONTEST_ASSERT_STRING_EQUAL
("-9223372036854775808", 
v
.
	`asSg
());

993 
v
 = 
Js
::
	`Vue
((
kt64m
));

995 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

997 
checks
 = 
	`IsCheck
();

998 
checks
.
isI64_
 = 
ue
;

999 
checks
.
isIegl_
 = 
ue
;

1000 
checks
.
isDoub_
 = 
ue
;

1001 
checks
.
isNumic_
 = 
ue
;

1002 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1004 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1005 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1006 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1008 
	`JSONTEST_ASSERT_EQUAL
(
kt64m
, 
v
.
	`asI64
());

1009 
	`JSONTEST_ASSERT_EQUAL
(
kt64m
, 
v
.
	`asLgeI
());

1010 
	`JSONTEST_ASSERT_EQUAL
(-9223372036854775808.0, 
v
.
	`asDoub
());

1011 
	`JSONTEST_ASSERT_EQUAL
(-9223372036854775808.0, 
v
.
	`asFlt
());

1012 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1013 
	`JSONTEST_ASSERT_STRING_EQUAL
("-9.2233720368547758e+18",

1014 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1017 cڡ 
Js
::
UI64
 
n_to_19
 = 
ic_
<Json::UInt64>(1e19);

1018 
v
 = 
Js
::
	`Vue
(Js::
	`UI64
(
n_to_19
));

1020 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
utVue
, 
v
.
	`ty
());

1022 
checks
 = 
	`IsCheck
();

1023 
checks
.
isUI64_
 = 
ue
;

1024 
checks
.
isIegl_
 = 
ue
;

1025 
checks
.
isDoub_
 = 
ue
;

1026 
checks
.
isNumic_
 = 
ue
;

1027 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1029 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1030 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1031 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1033 
	`JSONTEST_ASSERT_EQUAL
(
n_to_19
, 
v
.
	`asUI64
());

1034 
	`JSONTEST_ASSERT_EQUAL
(
n_to_19
, 
v
.
	`asLgeUI
());

1035 
	`JSONTEST_ASSERT_EQUAL
(
	`ut64ToDoub
(
n_to_19
), 
v
.
	`asDoub
());

1036 
	`JSONTEST_ASSERT_EQUAL
((
	`ut64ToDoub
(
n_to_19
)), 
v
.
	`asFlt
());

1037 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1038 
	`JSONTEST_ASSERT_STRING_EQUAL
("10000000000000000000", 
v
.
	`asSg
());

1042 
v
 = 
Js
::
	`Vue
(
	`ut64ToDoub
(
n_to_19
));

1044 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

1046 
checks
 = 
	`IsCheck
();

1047 
checks
.
isUI64_
 = 
ue
;

1048 
checks
.
isIegl_
 = 
ue
;

1049 
checks
.
isDoub_
 = 
ue
;

1050 
checks
.
isNumic_
 = 
ue
;

1051 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1053 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1054 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1055 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1057 
	`JSONTEST_ASSERT_EQUAL
(1e19, 
v
.
	`asDoub
());

1058 
	`JSONTEST_ASSERT_EQUAL
(1e19, 
v
.
	`asFlt
());

1059 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1060 
	`JSONTEST_ASSERT_STRING_EQUAL
("1e+19",

1061 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1064 
v
 = 
Js
::
	`Vue
(Js::
	`UI64
(
kut64max
));

1066 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
utVue
, 
v
.
	`ty
());

1068 
checks
 = 
	`IsCheck
();

1069 
checks
.
isUI64_
 = 
ue
;

1070 
checks
.
isIegl_
 = 
ue
;

1071 
checks
.
isDoub_
 = 
ue
;

1072 
checks
.
isNumic_
 = 
ue
;

1073 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1075 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1076 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1077 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1079 
	`JSONTEST_ASSERT_EQUAL
(
kut64max
, 
v
.
	`asUI64
());

1080 
	`JSONTEST_ASSERT_EQUAL
(
kut64max
, 
v
.
	`asLgeUI
());

1081 
	`JSONTEST_ASSERT_EQUAL
(
	`ut64ToDoub
(
kut64max
), 
v
.
	`asDoub
());

1082 
	`JSONTEST_ASSERT_EQUAL
((
	`ut64ToDoub
(
kut64max
)), 
v
.
	`asFlt
());

1083 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1084 
	`JSONTEST_ASSERT_STRING_EQUAL
("18446744073709551615", 
v
.
	`asSg
());

1088 
v
 = 
Js
::
	`Vue
(
	`ut64ToDoub
(
kut64max
));

1090 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

1092 
checks
 = 
	`IsCheck
();

1093 
checks
.
isDoub_
 = 
ue
;

1094 
checks
.
isNumic_
 = 
ue
;

1095 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1097 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1098 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1099 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1101 
	`JSONTEST_ASSERT_EQUAL
(18446744073709551616.0, 
v
.
	`asDoub
());

1102 
	`JSONTEST_ASSERT_EQUAL
(18446744073709551616.0, 
v
.
	`asFlt
());

1103 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1104 
	`JSONTEST_ASSERT_STRING_EQUAL
("1.8446744073709552e+19",

1105 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1107 
	}
}

1109 
	$JSONTEST_FIXTURE
(
VueTe
, 
nIegs
) {

1110 
IsCheck
 
checks
;

1111 
Js
::
Vue
 
v
;

1114 
v
 = 
Js
::
	`Vue
(1.5);

1116 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

1118 
checks
 = 
	`IsCheck
();

1119 
checks
.
isDoub_
 = 
ue
;

1120 
checks
.
isNumic_
 = 
ue
;

1121 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1123 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

1124 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

1125 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
Vue
));

1126 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
boޗnVue
));

1127 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
rgVue
));

1128 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1129 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
yVue
));

1130 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
objeVue
));

1132 
	`JSONTEST_ASSERT_EQUAL
(1.5, 
v
.
	`asDoub
());

1133 
	`JSONTEST_ASSERT_EQUAL
(1.5, 
v
.
	`asFlt
());

1134 
	`JSONTEST_ASSERT_EQUAL
(1, 
v
.
	`asI
());

1135 
	`JSONTEST_ASSERT_EQUAL
(1, 
v
.
	`asLgeI
());

1136 
	`JSONTEST_ASSERT_EQUAL
(1, 
v
.
	`asUI
());

1137 
	`JSONTEST_ASSERT_EQUAL
(1, 
v
.
	`asLgeUI
());

1138 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1139 
	`JSONTEST_ASSERT_EQUAL
("1.5", 
v
.
	`asSg
());

1142 
v
 = 
Js
::
	`Vue
(-1.5);

1144 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

1146 
checks
 = 
	`IsCheck
();

1147 
checks
.
isDoub_
 = 
ue
;

1148 
checks
.
isNumic_
 = 
ue
;

1149 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1151 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
tVue
));

1152 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
Vue
));

1153 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
boޗnVue
));

1154 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
rgVue
));

1155 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1156 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1157 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
yVue
));

1158 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
objeVue
));

1160 
	`JSONTEST_ASSERT_EQUAL
(-1.5, 
v
.
	`asDoub
());

1161 
	`JSONTEST_ASSERT_EQUAL
(-1.5, 
v
.
	`asFlt
());

1162 
	`JSONTEST_ASSERT_EQUAL
(-1, 
v
.
	`asI
());

1163 
	`JSONTEST_ASSERT_EQUAL
(-1, 
v
.
	`asLgeI
());

1164 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1165 
	`JSONTEST_ASSERT_EQUAL
("-1.5", 
v
.
	`asSg
());

1168 
v
 = 
Js
::
	`Vue
(
kt32max
 + 0.5);

1170 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

1172 
checks
 = 
	`IsCheck
();

1173 
checks
.
isDoub_
 = 
ue
;

1174 
checks
.
isNumic_
 = 
ue
;

1175 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1177 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
utVue
));

1178 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
Vue
));

1179 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
boޗnVue
));

1180 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
rgVue
));

1181 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1182 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1183 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
yVue
));

1184 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
objeVue
));

1186 
	`JSONTEST_ASSERT_EQUAL
(2147483647.5, 
v
.
	`asDoub
());

1187 
	`JSONTEST_ASSERT_EQUAL
((2147483647.5), 
v
.
	`asFlt
());

1188 
	`JSONTEST_ASSERT_EQUAL
(2147483647U, 
v
.
	`asUI
());

1189 #ifde
JSON_HAS_INT64


1190 
	`JSONTEST_ASSERT_EQUAL
(2147483647L, 
v
.
	`asLgeI
());

1191 
	`JSONTEST_ASSERT_EQUAL
(2147483647U, 
v
.
	`asLgeUI
());

1193 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1194 
	`JSONTEST_ASSERT_EQUAL
("2147483647.5",

1195 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1198 
v
 = 
Js
::
	`Vue
(
kt32m
 - 0.5);

1200 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

1202 
checks
 = 
	`IsCheck
();

1203 
checks
.
isDoub_
 = 
ue
;

1204 
checks
.
isNumic_
 = 
ue
;

1205 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1207 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
Vue
));

1208 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
boޗnVue
));

1209 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
rgVue
));

1210 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1211 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1212 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1213 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
yVue
));

1214 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
objeVue
));

1216 
	`JSONTEST_ASSERT_EQUAL
(-2147483648.5, 
v
.
	`asDoub
());

1217 
	`JSONTEST_ASSERT_EQUAL
((-2147483648.5), 
v
.
	`asFlt
());

1218 #ifde
JSON_HAS_INT64


1219 
	`JSONTEST_ASSERT_EQUAL
(-(
Js
::
	`I64
(1<< 31), 
v
.
	`asLgeI
());

1221 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1222 
	`JSONTEST_ASSERT_EQUAL
("-2147483648.5",

1223 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1226 
v
 = 
Js
::
	`Vue
(
kut32max
 + 0.5);

1228 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
Vue
, 
v
.
	`ty
());

1230 
checks
 = 
	`IsCheck
();

1231 
checks
.
isDoub_
 = 
ue
;

1232 
checks
.
isNumic_
 = 
ue
;

1233 
	`JSONTEST_ASSERT_PRED
(
	`checkIs
(
v
, 
checks
));

1235 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
Vue
));

1236 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
boޗnVue
));

1237 
	`JSONTEST_ASSERT
(
v
.
	`isCvtibTo
(
Js
::
rgVue
));

1238 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
nuVue
));

1239 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
tVue
));

1240 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
utVue
));

1241 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
yVue
));

1242 
	`JSONTEST_ASSERT
(!
v
.
	`isCvtibTo
(
Js
::
objeVue
));

1244 
	`JSONTEST_ASSERT_EQUAL
(4294967295.5, 
v
.
	`asDoub
());

1245 
	`JSONTEST_ASSERT_EQUAL
((4294967295.5), 
v
.
	`asFlt
());

1246 #ifde
JSON_HAS_INT64


1247 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`I64
(1<< 32- 1, 
v
.
	`asLgeI
());

1248 
	`JSONTEST_ASSERT_EQUAL
((
Js
::
	`UI64
(1) << 32) - Json::UInt64(1),

1249 
v
.
	`asLgeUI
());

1251 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
v
.
	`asBo
());

1252 
	`JSONTEST_ASSERT_EQUAL
("4294967295.5",

1253 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1255 
v
 = 
Js
::
	`Vue
(1.2345678901234);

1256 
	`JSONTEST_ASSERT_STRING_EQUAL
("1.2345678901234001",

1257 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1260 
v
 = 
Js
::
	`Vue
(2199023255552000.0f);

1261 
	`JSONTEST_ASSERT_EQUAL
((2199023255552000.0f), 
v
.
	`asFlt
());

1262 
	`JSONTEST_ASSERT_STRING_EQUAL
("2199023255552000",

1263 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1266 
v
 = 
Js
::
	`Vue
(3.402823466385289e38);

1267 
	`JSONTEST_ASSERT_EQUAL
((3.402823466385289e38), 
v
.
	`asFlt
());

1268 
	`JSONTEST_ASSERT_STRING_EQUAL
("3.402823466385289e+38",

1269 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1272 
v
 = 
Js
::
	`Vue
(1.2345678e300);

1273 
	`JSONTEST_ASSERT_EQUAL
((1.2345678e300), 
v
.
	`asDoub
());

1274 
	`JSONTEST_ASSERT_STRING_EQUAL
("1.2345678e+300",

1275 
	`nmizeFltgPotS
(
JsTe
::
	`ToJsSg
(
v
.
	`asSg
())));

1276 
	}
}

1278 
	gVueTe
::
	$checkCڡMembCou
(cڡ 
Js
::
Vue
& 
vue
,

1279 
exedCou
) {

1280 
cou
 = 0;

1281 
Js
::
Vue
::
cڡ_
 
End
 = 
vue
.
	`d
();

1282 
Js
::
Vue
::
cڡ_
 

 = 
vue
.
	`beg
(); i!
End
; ++it) {

1283 ++
cou
;

1285 
	`JSONTEST_ASSERT_EQUAL
(
exedCou
, 
cou
) << "Json::Value::const_iterator";

1286 
	}
}

1288 
	gVueTe
::
	$checkMembCou
(
Js
::
Vue
& 
vue
,

1289 
exedCou
) {

1290 
	`JSONTEST_ASSERT_EQUAL
(
exedCou
, 
vue
.
	`size
());

1292 
cou
 = 0;

1293 
Js
::
Vue
::

 
End
 = 
vue
.
	`d
();

1294 
Js
::
Vue
::

 

 = 
vue
.
	`beg
(); i!
End
; ++it) {

1295 ++
cou
;

1297 
	`JSONTEST_ASSERT_EQUAL
(
exedCou
, 
cou
) << "Json::Value::iterator";

1299 
	`JSONTEST_ASSERT_PRED
(
	`checkCڡMembCou
(
vue
, 
exedCou
));

1300 
	}
}

1302 
	gVueTe
::
IsCheck
::
	$IsCheck
()

1303 : 
	`isObje_
(
l
), 
	`isAay_
(l), 
	`isBo_
(l), 
	`isSg_
(false),

1304 
	`isNu_
(
l
), 
	`isI_
(l), 
	`isI64_
(l), 
	`isUI_
(false),

1305 
	`isUI64_
(
l
), 
	`isIegl_
(l), 
	`isDoub_
(false),

1306 
	$isNumic_
(
l
{
	}
}

1308 
	gVueTe
::
	$checkIs
(cڡ 
Js
::
Vue
& 
vue
, cڡ 
IsCheck
& 
check
) {

1309 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isObje_
, 
vue
.
	`isObje
());

1310 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isAay_
, 
vue
.
	`isAay
());

1311 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isBo_
, 
vue
.
	`isBo
());

1312 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isDoub_
, 
vue
.
	`isDoub
());

1313 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isI_
, 
vue
.
	`isI
());

1314 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isUI_
, 
vue
.
	`isUI
());

1315 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isIegl_
, 
vue
.
	`isIegl
());

1316 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isNumic_
, 
vue
.
	`isNumic
());

1317 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isSg_
, 
vue
.
	`isSg
());

1318 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isNu_
, 
vue
.
	`isNu
());

1320 #ifde
JSON_HAS_INT64


1321 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isI64_
, 
vue
.
	`isI64
());

1322 
	`JSONTEST_ASSERT_EQUAL
(
check
.
isUI64_
, 
vue
.
	`isUI64
());

1324 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
vue
.
	`isI64
());

1325 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
vue
.
	`isUI64
());

1327 
	}
}

1329 
	$JSONTEST_FIXTURE
(
VueTe
, 
comNu
) {

1330 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
Js
::
	`Vue
(), Json::Value()));

1331 
	}
}

1333 
	$JSONTEST_FIXTURE
(
VueTe
, 
comI
) {

1334 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(0, 10));

1335 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(10, 10));

1336 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(-10, -10));

1337 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(-10, 0));

1338 
	}
}

1340 
	$JSONTEST_FIXTURE
(
VueTe
, 
comUI
) {

1341 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(0u, 10u));

1342 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(0u, 
Js
::
Vue
::
maxUI
));

1343 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(10u, 10u));

1344 
	}
}

1346 
	$JSONTEST_FIXTURE
(
VueTe
, 
comDoub
) {

1347 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(0.0, 10.0));

1348 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(10.0, 10.0));

1349 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(-10.0, -10.0));

1350 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(-10.0, 0.0));

1351 
	}
}

1353 
	$JSONTEST_FIXTURE
(
VueTe
, 
comSg
) {

1354 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
("", " "));

1355 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
("", "a"));

1356 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
("abcd", "zyui"));

1357 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
("abc", "abcd"));

1358 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
("abcd", "abcd"));

1359 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(" ", " "));

1360 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
("ABCD", "abcd"));

1361 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
("ABCD", "ABCD"));

1362 
	}
}

1364 
	$JSONTEST_FIXTURE
(
VueTe
, 
comBoޗn
) {

1365 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
l
, 
ue
));

1366 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
l
, false));

1367 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
ue
,rue));

1368 
	}
}

1370 
	$JSONTEST_FIXTURE
(
VueTe
, 
comAay
) {

1372 
Js
::
Vue
 
	`emyAay
(Js::
yVue
);

1373 
Js
::
Vue
 
l1aAay
;

1374 
l1aAay
.
	`nd
(0);

1375 
Js
::
Vue
 
l1bAay
;

1376 
l1bAay
.
	`nd
(10);

1377 
Js
::
Vue
 
l2aAay
;

1378 
l2aAay
.
	`nd
(0);

1379 
l2aAay
.
	`nd
(0);

1380 
Js
::
Vue
 
l2bAay
;

1381 
l2bAay
.
	`nd
(0);

1382 
l2bAay
.
	`nd
(10);

1383 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
emyAay
, 
l1aAay
));

1384 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
emyAay
, 
l2aAay
));

1385 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
l1aAay
, 
l2aAay
));

1386 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
l2aAay
, 
l2bAay
));

1387 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
emyAay
, 
Js
::
	`Vue
(emptyArray)));

1388 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
l1aAay
, 
Js
::
	`Vue
(l1aArray)));

1389 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
l2bAay
, 
Js
::
	`Vue
(l2bArray)));

1390 
	}
}

1392 
	$JSONTEST_FIXTURE
(
VueTe
, 
comObje
) {

1394 
Js
::
Vue
 
	`emyObje
(Js::
objeVue
);

1395 
Js
::
Vue
 
l1aObje
;

1396 
l1aObje
["key1"] = 0;

1397 
Js
::
Vue
 
l1bObje
;

1398 
l1aObje
["key1"] = 10;

1399 
Js
::
Vue
 
l2aObje
;

1400 
l2aObje
["key1"] = 0;

1401 
l2aObje
["key2"] = 0;

1402 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
emyObje
, 
l1aObje
));

1403 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
emyObje
, 
l2aObje
));

1404 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
l1aObje
, 
l2aObje
));

1405 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
emyObje
, 
Js
::
	`Vue
(emptyObject)));

1406 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
l1aObje
, 
Js
::
	`Vue
(l1aObject)));

1407 
	`JSONTEST_ASSERT_PRED
(
	`checkIsEqu
(
l2aObje
, 
Js
::
	`Vue
(l2aObject)));

1408 
	}
}

1410 
	$JSONTEST_FIXTURE
(
VueTe
, 
comTy
) {

1412 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
Js
::
	`Vue
(), Json::Value(1)));

1413 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
Js
::
	`Vue
(1), Json::Value(1u)));

1414 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
Js
::
	`Vue
(1u), Json::Value(1.0)));

1415 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
Js
::
	`Vue
(1.0), Json::Value("a")));

1416 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
Js
::
	`Vue
("a"), Js::Vue(
ue
)));

1417 
	`JSONTEST_ASSERT_PRED
(

1418 
	`checkIsLess
(
Js
::
	`Vue
(
ue
), Js::Vue(Js::
yVue
)));

1419 
	`JSONTEST_ASSERT_PRED
(
	`checkIsLess
(
Js
::
	`Vue
(Js::
yVue
),

1420 
Js
::
	`Vue
(Js::
objeVue
)));

1421 
	}
}

1423 
	gVueTe
::
	$checkIsLess
(cڡ 
Js
::
Vue
& 
x
, cڡ Js::Vue& 
y
) {

1424 
	`JSONTEST_ASSERT
(
x
 < 
y
);

1425 
	`JSONTEST_ASSERT
(
y
 > 
x
);

1426 
	`JSONTEST_ASSERT
(
x
 <
y
);

1427 
	`JSONTEST_ASSERT
(
y
 >
x
);

1428 
	`JSONTEST_ASSERT
(!(
x
 =
y
));

1429 
	`JSONTEST_ASSERT
(!(
y
 =
x
));

1430 
	`JSONTEST_ASSERT
(!(
x
 >
y
));

1431 
	`JSONTEST_ASSERT
(!(
y
 <
x
));

1432 
	`JSONTEST_ASSERT
(!(
x
 > 
y
));

1433 
	`JSONTEST_ASSERT
(!(
y
 < 
x
));

1434 
	`JSONTEST_ASSERT
(
x
.
	`com
(
y
) < 0);

1435 
	`JSONTEST_ASSERT
(
y
.
	`com
(
x
) >= 0);

1436 
	}
}

1438 
	gVueTe
::
	$checkIsEqu
(cڡ 
Js
::
Vue
& 
x
, cڡ Js::Vue& 
y
) {

1439 
	`JSONTEST_ASSERT
(
x
 =
y
);

1440 
	`JSONTEST_ASSERT
(
y
 =
x
);

1441 
	`JSONTEST_ASSERT
(
x
 <
y
);

1442 
	`JSONTEST_ASSERT
(
y
 <
x
);

1443 
	`JSONTEST_ASSERT
(
x
 >
y
);

1444 
	`JSONTEST_ASSERT
(
y
 >
x
);

1445 
	`JSONTEST_ASSERT
(!(
x
 < 
y
));

1446 
	`JSONTEST_ASSERT
(!(
y
 < 
x
));

1447 
	`JSONTEST_ASSERT
(!(
x
 > 
y
));

1448 
	`JSONTEST_ASSERT
(!(
y
 > 
x
));

1449 
	`JSONTEST_ASSERT
(
x
.
	`com
(
y
) == 0);

1450 
	`JSONTEST_ASSERT
(
y
.
	`com
(
x
) == 0);

1451 
	}
}

1453 
	$JSONTEST_FIXTURE
(
VueTe
, 
tyChecksThrowExis
) {

1454 #i
JSON_USE_EXCEPTION


1456 
Js
::
Vue
 
	`tV
(1);

1457 
Js
::
Vue
 
	`rV
("Test");

1458 
Js
::
Vue
 
	`objV
(Js::
objeVue
);

1459 
Js
::
Vue
 
	`rV
(Js::
yVue
);

1461 
	`JSONTEST_ASSERT_THROWS
(
tV
["test"]);

1462 
	`JSONTEST_ASSERT_THROWS
(
rV
["test"]);

1463 
	`JSONTEST_ASSERT_THROWS
(
rV
["test"]);

1465 
	`JSONTEST_ASSERT_THROWS
(
tV
.
	`moveMemb
("test"));

1466 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`moveMemb
("test"));

1467 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`moveMemb
("test"));

1469 
	`JSONTEST_ASSERT_THROWS
(
tV
.
	`gMembNames
());

1470 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`gMembNames
());

1471 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`gMembNames
());

1473 
	`JSONTEST_ASSERT_THROWS
(
tV
[0]);

1474 
	`JSONTEST_ASSERT_THROWS
(
objV
[0]);

1475 
	`JSONTEST_ASSERT_THROWS
(
rV
[0]);

1477 
	`JSONTEST_ASSERT_THROWS
(
tV
.
	`r
());

1479 
	`JSONTEST_ASSERT_THROWS
(
tV
.
	`size
(1));

1480 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`size
(1));

1481 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`size
(1));

1483 
	`JSONTEST_ASSERT_THROWS
(
tV
.
	`asCSg
());

1485 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asSg
());

1486 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asSg
());

1488 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asI
());

1489 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asI
());

1490 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asI
());

1492 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asUI
());

1493 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asUI
());

1494 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asUI
());

1496 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asI64
());

1497 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asI64
());

1498 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asI64
());

1500 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asUI64
());

1501 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asUI64
());

1502 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asUI64
());

1504 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asDoub
());

1505 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asDoub
());

1506 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asDoub
());

1508 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asFlt
());

1509 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asFlt
());

1510 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asFlt
());

1512 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asBo
());

1513 
	`JSONTEST_ASSERT_THROWS
(
objV
.
	`asBo
());

1514 
	`JSONTEST_ASSERT_THROWS
(
rV
.
	`asBo
());

1517 
	}
}

1519 
	$JSONTEST_FIXTURE
(
VueTe
, 
offtAcsss
) {

1520 
Js
::
Vue
 
x
;

1521 
	`JSONTEST_ASSERT
(
x
.
	`gOfftS
() == 0);

1522 
	`JSONTEST_ASSERT
(
x
.
	`gOfftLim
() == 0);

1523 
x
.
	`tOfftS
(10);

1524 
x
.
	`tOfftLim
(20);

1525 
	`JSONTEST_ASSERT
(
x
.
	`gOfftS
() == 10);

1526 
	`JSONTEST_ASSERT
(
x
.
	`gOfftLim
() == 20);

1527 
Js
::
Vue
 
	`y
(
x
);

1528 
	`JSONTEST_ASSERT
(
y
.
	`gOfftS
() == 10);

1529 
	`JSONTEST_ASSERT
(
y
.
	`gOfftLim
() == 20);

1530 
Js
::
Vue
 
z
;

1531 
z
.
	`sw
(
y
);

1532 
	`JSONTEST_ASSERT
(
z
.
	`gOfftS
() == 10);

1533 
	`JSONTEST_ASSERT
(
z
.
	`gOfftLim
() == 20);

1534 
	`JSONTEST_ASSERT
(
y
.
	`gOfftS
() == 0);

1535 
	`JSONTEST_ASSERT
(
y
.
	`gOfftLim
() == 0);

1536 
	}
}

1538 
	$JSONTEST_FIXTURE
(
VueTe
, 
SticSg
) {

1539 
mu
[] = "hello";

1540 
Js
::
SticSg
 
	`ss
(
mu
);

1541 
JSONCPP_STRING
 
	`gur
(
mu
);

1542 
mu
[1] = 'a';

1543 
	`JSONTEST_ASSERT_STRING_EQUAL
("hlo", 
ss
.
	`c_r
());

1544 
	`JSONTEST_ASSERT_STRING_EQUAL
("hlo", 
gur
.
	`c_r
());

1546 
Js
::
Vue
 
ro
;

1547 
ro
["t"] = 
ss
;

1548 
	`JSONTEST_ASSERT_STRING_EQUAL
("hlo", 
ro
["t"].
	`asSg
());

1549 
mu
[1] = 'u';

1550 
	`JSONTEST_ASSERT_STRING_EQUAL
("huo", 
ro
["t"].
	`asSg
());

1553 
Js
::
Vue
 
ro
;

1554 
ro
["t"] = 
gur
;

1555 
	`JSONTEST_ASSERT_STRING_EQUAL
("hlo", 
ro
["t"].
	`asSg
());

1556 
mu
[1] = 'u';

1557 
	`JSONTEST_ASSERT_STRING_EQUAL
("hlo", 
ro
["t"].
	`asSg
());

1559 
	}
}

1561 
	$JSONTEST_FIXTURE
(
VueTe
, 
CommtBefe
) {

1562 
Js
::
Vue
 
v
;

1563 
v
.
	`tCommt
(
	`JSONCPP_STRING
("//hicommshouldbefe"), 
Js
::
commtBefe
);

1564 
Js
::
SmWrBud
 
wbud
;

1565 
wbud
.
gs_
["commentStyle"] = "All";

1567 cڡ 
exed
[] = "//his comment shouldppear before\nnull";

1568 
JSONCPP_STRING
 
su
 = 
Js
::
	`wreSg
(
wbud
, 
v
);

1569 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1570 
JSONCPP_STRING
 
s2
 = 
v
.
	`toStydSg
();

1571 
JSONCPP_STRING
 
exp2
 = "\n";

1572 
exp2
 +
exed
;

1573 
exp2
 += "\n";

1574 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exp2
, 
s2
);

1576 
Js
::
Vue
 
h
 = "hello";

1577 
v
.
	`swPayld
(
h
);

1579 cڡ 
exed
[] = "//his comment shouldppear before\n\"hello\"";

1580 
JSONCPP_STRING
 
su
 = 
Js
::
	`wreSg
(
wbud
, 
v
);

1581 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1582 
JSONCPP_STRING
 
s2
 = 
v
.
	`toStydSg
();

1583 
JSONCPP_STRING
 
exp2
 = "\n";

1584 
exp2
 +
exed
;

1585 
exp2
 += "\n";

1586 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exp2
, 
s2
);

1587 
	`JSONTEST_ASSERT_STRING_EQUAL
("nu\n", 
h
.
	`toStydSg
());

1589 
v
 = "hello";

1593 cڡ 
exed
[] = "\"hello\"";

1594 
JSONCPP_STRING
 
su
 = 
Js
::
	`wreSg
(
wbud
, 
v
);

1595 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1596 
JSONCPP_STRING
 
s2
 = 
v
.
	`toStydSg
();

1597 
JSONCPP_STRING
 
exp2
 = "";

1598 
exp2
 +
exed
;

1599 
exp2
 += "\n";

1600 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exp2
, 
s2
);

1602 
	}
}

1604 
	$JSONTEST_FIXTURE
(
VueTe
, 
zs
) {

1605 cڡ 
cr
[] = "h\0i";

1606 
JSONCPP_STRING
 
	`by
(
cr
, (cstr));

1607 
	`JSONTEST_ASSERT_EQUAL
(4U, 
by
.
	`ngth
());

1608 
Js
::
SmWrBud
 
b
;

1610 
Js
::
Vue
 
ro
;

1611 
ro
 = 
by
;

1612 
	`JSONTEST_ASSERT_STRING_EQUAL
(
by
, 
ro
.
	`asSg
());

1615 cڡ 
t
[] = "top";

1616 
Js
::
Vue
 
ro
;

1617 
ro
[
t
] = 
by
;

1618 
	`JSONTEST_ASSERT_STRING_EQUAL
(
by
, 
ro
[
t
].
	`asSg
());

1619 
Js
::
Vue
 
moved
;

1620 
bo
 
did
;

1621 
did
 = 
ro
.
	`moveMemb
(
t
,op + (top) - 1U,

1622 &
moved
);

1623 
	`JSONTEST_ASSERT
(
did
);

1624 
	`JSONTEST_ASSERT_STRING_EQUAL
(
by
, 
moved
.
	`asSg
());

1625 
did
 = 
ro
.
	`moveMemb
(
t
,op + (top) - 1U,

1626 &
moved
);

1627 
	`JSONTEST_ASSERT
(!
did
);

1628 
	`JSONTEST_ASSERT_STRING_EQUAL
(
by
, 
moved
.
	`asSg
());

1630 
	}
}

1632 
	$JSONTEST_FIXTURE
(
VueTe
, 
zsInKeys
) {

1633 cڡ 
cr
[] = "h\0i";

1634 
JSONCPP_STRING
 
	`by
(
cr
, (cstr));

1635 
	`JSONTEST_ASSERT_EQUAL
(4U, 
by
.
	`ngth
());

1637 
Js
::
Vue
 
ro
;

1638 
ro
[
by
] = "there";

1639 
	`JSONTEST_ASSERT_STRING_EQUAL
("the", 
ro
[
by
].
	`asSg
());

1640 
	`JSONTEST_ASSERT
(!
ro
.
	`isMemb
("h"));

1641 
	`JSONTEST_ASSERT
(
ro
.
	`isMemb
(
by
));

1642 
	`JSONTEST_ASSERT_STRING_EQUAL
("the", 
ro
.
	`g
(
by
, 
Js
::
Vue
::
nuRef
).
	`asSg
());

1643 
Js
::
Vue
 
moved
;

1644 
bo
 
did
;

1645 
did
 = 
ro
.
	`moveMemb
(
by
.
	`da
(), by.da(+ by.
	`ngth
(),

1646 &
moved
);

1647 
	`JSONTEST_ASSERT
(
did
);

1648 
	`JSONTEST_ASSERT_STRING_EQUAL
("the", 
moved
.
	`asSg
());

1649 
did
 = 
ro
.
	`moveMemb
(
by
.
	`da
(), by.da(+ by.
	`ngth
(),

1650 &
moved
);

1651 
	`JSONTEST_ASSERT
(!
did
);

1652 
	`JSONTEST_ASSERT_STRING_EQUAL
("the", 
moved
.
	`asSg
());

1653 
	`JSONTEST_ASSERT
(!
ro
.
	`isMemb
(
by
));

1654 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
ro
.
	`g
(
by
, 
Js
::
Vue
::
nuRef
).
	`asSg
());

1656 
	}
}

1658 
	$JSONTEST_FIXTURE
(
VueTe
, 
eclFlts
) {

1659 
Js
::
SmWrBud
 
b
;

1660 
b
.
gs_
["uSclFlts"] = 
ue
;

1662 
Js
::
Vue
 
v
 = 
d
::
numic_lims
<>::
	`qut_NaN
();

1663 
JSONCPP_STRING
 
exed
 = "NaN";

1664 
JSONCPP_STRING
 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1665 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1667 
v
 = 
d
::
numic_lims
<>::
	`fy
();

1668 
exed
 = "Infinity";

1669 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1670 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1672 
v
 = -
d
::
numic_lims
<>::
	`fy
();

1673 
exed
 = "-Infinity";

1674 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1675 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1676 
	}
}

1678 
	$JSONTEST_FIXTURE
(
VueTe
, 
ecisi
) {

1679 
Js
::
SmWrBud
 
b
;

1680 
b
.
gs_
["precision"] = 5;

1682 
Js
::
Vue
 
v
 = 100.0/3;

1683 
JSONCPP_STRING
 
exed
 = "33.333";

1684 
JSONCPP_STRING
 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1685 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1687 
v
 = 0.25000000;

1688 
exed
 = "0.25";

1689 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1690 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1692 
v
 = 0.2563456;

1693 
exed
 = "0.25635";

1694 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1695 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1697 
b
.
gs_
["precision"] = 1;

1698 
exed
 = "0.3";

1699 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1700 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1702 
b
.
gs_
["precision"] = 17;

1703 
v
 = 1234857476305.256345694873740545068;

1704 
exed
 = "1234857476305.2563";

1705 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1706 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1708 
b
.
gs_
["precision"] = 24;

1709 
v
 = 0.256345694873740545068;

1710 
exed
 = "0.25634569487374054";

1711 
su
 = 
Js
::
	`wreSg
(
b
, 
v
);

1712 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
su
);

1713 
	}
}

1715 
	gWrTe
 : 
JsTe
::
TeCa
 {};

1717 
	$JSONTEST_FIXTURE
(
WrTe
, 
drNuPhds
) {

1718 
Js
::
FaWr
 
wr
;

1719 
Js
::
Vue
 
nuVue
;

1720 
	`JSONTEST_ASSERT
(
wr
.
	`wre
(
nuVue
) == "null\n");

1722 
wr
.
	`drNuPhds
();

1723 
	`JSONTEST_ASSERT
(
wr
.
	`wre
(
nuVue
) == "\n");

1724 
	}
}

1726 
	gSmWrTe
 : 
JsTe
::
TeCa
 {};

1728 
	$JSONTEST_FIXTURE
(
SmWrTe
, 
drNuPhds
) {

1729 
Js
::
SmWrBud
 
b
;

1730 
Js
::
Vue
 
nuVue
;

1731 
b
.
gs_
["drNuPhds"] = 
l
;

1732 
	`JSONTEST_ASSERT
(
Js
::
	`wreSg
(
b
, 
nuVue
) == "null");

1733 
b
.
gs_
["drNuPhds"] = 
ue
;

1734 
	`JSONTEST_ASSERT
(
Js
::
	`wreSg
(
b
, 
nuVue
) == "");

1735 
	}
}

1737 
	$JSONTEST_FIXTURE
(
SmWrTe
, 
wreZs
) {

1738 
JSONCPP_STRING
 
	`by
("hi", 3);

1739 
	`JSONTEST_ASSERT_EQUAL
(3, 
by
.
	`ngth
());

1740 
JSONCPP_STRING
 
	`exed
("\"hi\\u0000\"");

1741 
Js
::
SmWrBud
 
b
;

1743 
Js
::
Vue
 
ro
;

1744 
ro
 = 
by
;

1745 
	`JSONTEST_ASSERT_STRING_EQUAL
(
by
, 
ro
.
	`asSg
());

1746 
JSONCPP_STRING
 
out
 = 
Js
::
	`wreSg
(
b
, 
ro
);

1747 
	`JSONTEST_ASSERT_EQUAL
(
exed
.
	`size
(), 
out
.size());

1748 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
out
);

1751 
Js
::
Vue
 
ro
;

1752 
ro
["t"] = 
by
;

1753 
	`JSONTEST_ASSERT_STRING_EQUAL
(
by
, 
ro
["t"].
	`asSg
());

1754 
JSONCPP_STRING
 
out
 = 
Js
::
	`wreSg
(
b
, 
ro
["top"]);

1755 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
out
);

1757 
	}
}

1759 
	gRdTe
 : 
JsTe
::
TeCa
 {};

1761 
	$JSONTEST_FIXTURE
(
RdTe
, 
rWhNoEs
) {

1762 
Js
::
Rd
 
ad
;

1763 
Js
::
Vue
 
ro
;

1764 
bo
 
ok
 = 
ad
.
	`r
("{ \"ݔty\" : \"vue\" }", 
ro
);

1765 
	`JSONTEST_ASSERT
(
ok
);

1766 
	`JSONTEST_ASSERT
(
ad
.
	`gFmdEMesges
().
	`size
() == 0);

1767 
	`JSONTEST_ASSERT
(
ad
.
	`gSuudEs
().
	`size
() == 0);

1768 
	}
}

1770 
	$JSONTEST_FIXTURE
(
RdTe
, 
rWhNoEsTegOffts
) {

1771 
Js
::
Rd
 
ad
;

1772 
Js
::
Vue
 
ro
;

1773 
bo
 
ok
 = 
ad
.
	`r
("{ \"property\" : [\"value\", \"value2\"], \"obj\" : "

1776 
ro
);

1777 
	`JSONTEST_ASSERT
(
ok
);

1778 
	`JSONTEST_ASSERT
(
ad
.
	`gFmdEMesges
().
	`size
() == 0);

1779 
	`JSONTEST_ASSERT
(
ad
.
	`gSuudEs
().
	`size
() == 0);

1780 
	`JSONTEST_ASSERT
(
ro
["ݔty"].
	`gOfftS
() == 15);

1781 
	`JSONTEST_ASSERT
(
ro
["ݔty"].
	`gOfftLim
() == 34);

1782 
	`JSONTEST_ASSERT
(
ro
["ݔty"][0].
	`gOfftS
() == 16);

1783 
	`JSONTEST_ASSERT
(
ro
["ݔty"][0].
	`gOfftLim
() == 23);

1784 
	`JSONTEST_ASSERT
(
ro
["ݔty"][1].
	`gOfftS
() == 25);

1785 
	`JSONTEST_ASSERT
(
ro
["ݔty"][1].
	`gOfftLim
() == 33);

1786 
	`JSONTEST_ASSERT
(
ro
["obj"].
	`gOfftS
() == 44);

1787 
	`JSONTEST_ASSERT
(
ro
["obj"].
	`gOfftLim
() == 76);

1788 
	`JSONTEST_ASSERT
(
ro
["obj"]["áed"].
	`gOfftS
() == 57);

1789 
	`JSONTEST_ASSERT
(
ro
["obj"]["áed"].
	`gOfftLim
() == 60);

1790 
	`JSONTEST_ASSERT
(
ro
["obj"]["bo"].
	`gOfftS
() == 71);

1791 
	`JSONTEST_ASSERT
(
ro
["obj"]["bo"].
	`gOfftLim
() == 75);

1792 
	`JSONTEST_ASSERT
(
ro
["nu"].
	`gOfftS
() == 87);

1793 
	`JSONTEST_ASSERT
(
ro
["nu"].
	`gOfftLim
() == 91);

1794 
	`JSONTEST_ASSERT
(
ro
["l"].
	`gOfftS
() == 103);

1795 
	`JSONTEST_ASSERT
(
ro
["l"].
	`gOfftLim
() == 108);

1796 
	`JSONTEST_ASSERT
(
ro
.
	`gOfftS
() == 0);

1797 
	`JSONTEST_ASSERT
(
ro
.
	`gOfftLim
() == 110);

1798 
	}
}

1800 
	$JSONTEST_FIXTURE
(
RdTe
, 
rWhOE
) {

1801 
Js
::
Rd
 
ad
;

1802 
Js
::
Vue
 
ro
;

1803 
bo
 
ok
 = 
ad
.
	`r
("{ \"ݔty\" :: \"vue\" }", 
ro
);

1804 
	`JSONTEST_ASSERT
(!
ok
);

1805 
	`JSONTEST_ASSERT
(
ad
.
	`gFmdEMesges
() ==

1808 
d
::
ve
<
Js
::
Rd
::
SuudE
> 
rs
 =

1809 
ad
.
	`gSuudEs
();

1810 
	`JSONTEST_ASSERT
(
rs
.
	`size
() == 1);

1811 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
offt_t
 == 14);

1812 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
offt_lim
 == 15);

1813 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
mesge
 ==

1815 
	}
}

1817 
	$JSONTEST_FIXTURE
(
RdTe
, 
rCheWhOE
) {

1818 
Js
::
Rd
 
ad
;

1819 
Js
::
Vue
 
ro
;

1820 
bo
 
ok
 = 
ad
.
	`r
("{ \"佐藤ty\" :: \"vue\" }", 
ro
);

1821 
	`JSONTEST_ASSERT
(!
ok
);

1822 
	`JSONTEST_ASSERT
(
ad
.
	`gFmdEMesges
() ==

1825 
d
::
ve
<
Js
::
Rd
::
SuudE
> 
rs
 =

1826 
ad
.
	`gSuudEs
();

1827 
	`JSONTEST_ASSERT
(
rs
.
	`size
() == 1);

1828 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
offt_t
 == 18);

1829 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
offt_lim
 == 19);

1830 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
mesge
 ==

1832 
	}
}

1834 
	$JSONTEST_FIXTURE
(
RdTe
, 
rWhDaE
) {

1835 
Js
::
Rd
 
ad
;

1836 
Js
::
Vue
 
ro
;

1837 
bo
 
ok
 = 
ad
.
	`r
("{ \"ݔty\" : \"v\\ue\" }", 
ro
);

1838 
	`JSONTEST_ASSERT
(!
ok
);

1839 
	`JSONTEST_ASSERT
(
ad
.
	`gFmdEMesges
() ==

1842 
d
::
ve
<
Js
::
Rd
::
SuudE
> 
rs
 =

1843 
ad
.
	`gSuudEs
();

1844 
	`JSONTEST_ASSERT
(
rs
.
	`size
() == 1);

1845 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
offt_t
 == 15);

1846 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
offt_lim
 == 23);

1847 
	`JSONTEST_ASSERT
(
rs
.
	`
(0).
mesge
 == "Badscape sequence in string");

1848 
	}
}

1850 
	gChRdTe
 : 
JsTe
::
TeCa
 {};

1852 
	$JSONTEST_FIXTURE
(
ChRdTe
, 
rWhNoEs
) {

1853 
Js
::
ChRdBud
 
b
;

1854 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1855 
JSONCPP_STRING
 
rs
;

1856 
Js
::
Vue
 
ro
;

1857 cڡ 
doc
[] = "{ \"property\" : \"value\" }";

1858 
bo
 
ok
 = 
ad
->
	`r
(

1859 
doc
, do+ 
d
::
	`
(doc),

1860 &
ro
, &
rs
);

1861 
	`JSONTEST_ASSERT
(
ok
);

1862 
	`JSONTEST_ASSERT
(
rs
.
	`size
() == 0);

1863 
de
 
ad
;

1864 
	}
}

1866 
	$JSONTEST_FIXTURE
(
ChRdTe
, 
rWhNoEsTegOffts
) {

1867 
Js
::
ChRdBud
 
b
;

1868 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1869 
JSONCPP_STRING
 
rs
;

1870 
Js
::
Vue
 
ro
;

1871 cڡ 
doc
[] =

1875 
bo
 
ok
 = 
ad
->
	`r
(

1876 
doc
, do+ 
d
::
	`
(doc),

1877 &
ro
, &
rs
);

1878 
	`JSONTEST_ASSERT
(
ok
);

1879 
	`JSONTEST_ASSERT
(
rs
.
	`size
() == 0);

1880 
de
 
ad
;

1881 
	}
}

1883 
	$JSONTEST_FIXTURE
(
ChRdTe
, 
rWhOE
) {

1884 
Js
::
ChRdBud
 
b
;

1885 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1886 
JSONCPP_STRING
 
rs
;

1887 
Js
::
Vue
 
ro
;

1888 cڡ 
doc
[] =

1890 
bo
 
ok
 = 
ad
->
	`r
(

1891 
doc
, do+ 
d
::
	`
(doc),

1892 &
ro
, &
rs
);

1893 
	`JSONTEST_ASSERT
(!
ok
);

1894 
	`JSONTEST_ASSERT
(
rs
 ==

1897 
de
 
ad
;

1898 
	}
}

1900 
	$JSONTEST_FIXTURE
(
ChRdTe
, 
rCheWhOE
) {

1901 
Js
::
ChRdBud
 
b
;

1902 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1903 
JSONCPP_STRING
 
rs
;

1904 
Js
::
Vue
 
ro
;

1905 cڡ 
doc
[] =

1907 
bo
 
ok
 = 
ad
->
	`r
(

1908 
doc
, do+ 
d
::
	`
(doc),

1909 &
ro
, &
rs
);

1910 
	`JSONTEST_ASSERT
(!
ok
);

1911 
	`JSONTEST_ASSERT
(
rs
 ==

1914 
de
 
ad
;

1915 
	}
}

1917 
	$JSONTEST_FIXTURE
(
ChRdTe
, 
rWhDaE
) {

1918 
Js
::
ChRdBud
 
b
;

1919 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1920 
JSONCPP_STRING
 
rs
;

1921 
Js
::
Vue
 
ro
;

1922 cڡ 
doc
[] =

1924 
bo
 
ok
 = 
ad
->
	`r
(

1925 
doc
, do+ 
d
::
	`
(doc),

1926 &
ro
, &
rs
);

1927 
	`JSONTEST_ASSERT
(!
ok
);

1928 
	`JSONTEST_ASSERT
(
rs
 ==

1931 
de
 
ad
;

1932 
	}
}

1934 
	$JSONTEST_FIXTURE
(
ChRdTe
, 
rWhSckLim
) {

1935 
Js
::
ChRdBud
 
b
;

1936 
Js
::
Vue
 
ro
;

1937 cڡ 
doc
[] =

1940 
b
.
gs_
["stackLimit"] = 2;

1941 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1942 
JSONCPP_STRING
 
rs
;

1943 
bo
 
ok
 = 
ad
->
	`r
(

1944 
doc
, do+ 
d
::
	`
(doc),

1945 &
ro
, &
rs
);

1946 
	`JSONTEST_ASSERT
(
ok
);

1947 
	`JSONTEST_ASSERT
(
rs
 == "");

1948 
	`JSONTEST_ASSERT_EQUAL
("vue", 
ro
["property"]);

1949 
de
 
ad
;

1952 
b
.
gs_
["stackLimit"] = 1;

1953 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1954 
JSONCPP_STRING
 
rs
;

1955 
	`JSONTEST_ASSERT_THROWS
(
ad
->
	`r
(

1956 
doc
, do+ 
d
::
	`
(doc),

1957 &
ro
, &
rs
));

1958 
de
 
ad
;

1960 
	}
}

1962 
	gChRdSiModeTe
 : 
JsTe
::
TeCa
 {};

1964 
	$JSONTEST_FIXTURE
(
ChRdSiModeTe
, 
dupKeys
) {

1965 
Js
::
ChRdBud
 
b
;

1966 
Js
::
Vue
 
ro
;

1967 cڡ 
doc
[] =

1970 
b
.
	`riMode
(&b.
gs_
);

1971 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1972 
JSONCPP_STRING
 
rs
;

1973 
bo
 
ok
 = 
ad
->
	`r
(

1974 
doc
, do+ 
d
::
	`
(doc),

1975 &
ro
, &
rs
);

1976 
	`JSONTEST_ASSERT
(!
ok
);

1977 
	`JSONTEST_ASSERT_STRING_EQUAL
(

1980 
rs
);

1981 
	`JSONTEST_ASSERT_EQUAL
("v1", 
ro
["key"]);

1982 
de
 
ad
;

1984 
	}
}

1985 
	gChRdFaIfExaTe
 : 
JsTe
::
TeCa
 {};

1987 
	$JSONTEST_FIXTURE
(
ChRdFaIfExaTe
, 
issue164
) {

1989 
Js
::
ChRdBud
 
b
;

1990 
Js
::
Vue
 
ro
;

1991 cڡ 
doc
[] =

1994 
b
.
gs_
["IfExa"] = 
l
;

1995 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

1996 
JSONCPP_STRING
 
rs
;

1997 
bo
 
ok
 = 
ad
->
	`r
(

1998 
doc
, do+ 
d
::
	`
(doc),

1999 &
ro
, &
rs
);

2000 
	`JSONTEST_ASSERT
(
ok
);

2001 
	`JSONTEST_ASSERT
(
rs
 == "");

2002 
	`JSONTEST_ASSERT_EQUAL
("ݔty", 
ro
);

2003 
de
 
ad
;

2006 
b
.
gs_
["IfExa"] = 
ue
;

2007 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2008 
JSONCPP_STRING
 
rs
;

2009 
bo
 
ok
 = 
ad
->
	`r
(

2010 
doc
, do+ 
d
::
	`
(doc),

2011 &
ro
, &
rs
);

2012 
	`JSONTEST_ASSERT
(!
ok
);

2013 
	`JSONTEST_ASSERT_STRING_EQUAL
(
rs
,

2016 
	`JSONTEST_ASSERT_EQUAL
("ݔty", 
ro
);

2017 
de
 
ad
;

2020 
b
.
gs_
["IfExa"] = 
l
;

2021 
b
.
	`riMode
(&b.
gs_
);

2022 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2023 
JSONCPP_STRING
 
rs
;

2024 
bo
 
ok
 = 
ad
->
	`r
(

2025 
doc
, do+ 
d
::
	`
(doc),

2026 &
ro
, &
rs
);

2027 
	`JSONTEST_ASSERT
(!
ok
);

2028 
	`JSONTEST_ASSERT_STRING_EQUAL
(
rs
,

2031 
	`JSONTEST_ASSERT_EQUAL
("ݔty", 
ro
);

2032 
de
 
ad
;

2034 
	}
}

2035 
	$JSONTEST_FIXTURE
(
ChRdFaIfExaTe
, 
issue107
) {

2037 
Js
::
ChRdBud
 
b
;

2038 
Js
::
Vue
 
ro
;

2039 cڡ 
doc
[] =

2041 
b
.
gs_
["IfExa"] = 
ue
;

2042 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2043 
JSONCPP_STRING
 
rs
;

2044 
bo
 
ok
 = 
ad
->
	`r
(

2045 
doc
, do+ 
d
::
	`
(doc),

2046 &
ro
, &
rs
);

2047 
	`JSONTEST_ASSERT
(!
ok
);

2048 
	`JSONTEST_ASSERT_STRING_EQUAL
(

2051 
rs
);

2052 
	`JSONTEST_ASSERT_EQUAL
(1, 
ro
.
	`asI
());

2053 
de
 
ad
;

2054 
	}
}

2055 
	$JSONTEST_FIXTURE
(
ChRdFaIfExaTe
, 
commtAObje
) {

2056 
Js
::
ChRdBud
 
b
;

2057 
Js
::
Vue
 
ro
;

2059 cڡ 
doc
[] =

2061 
b
.
gs_
["IfExa"] = 
ue
;

2062 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2063 
JSONCPP_STRING
 
rs
;

2064 
bo
 
ok
 = 
ad
->
	`r
(

2065 
doc
, do+ 
d
::
	`
(doc),

2066 &
ro
, &
rs
);

2067 
	`JSONTEST_ASSERT
(
ok
);

2068 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2069 
	`JSONTEST_ASSERT_EQUAL
("vue", 
ro
["property"]);

2070 
de
 
ad
;

2072 
	}
}

2073 
	$JSONTEST_FIXTURE
(
ChRdFaIfExaTe
, 
commtAAay
) {

2074 
Js
::
ChRdBud
 
b
;

2075 
Js
::
Vue
 
ro
;

2076 cڡ 
doc
[] =

2078 
b
.
gs_
["IfExa"] = 
ue
;

2079 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2080 
JSONCPP_STRING
 
rs
;

2081 
bo
 
ok
 = 
ad
->
	`r
(

2082 
doc
, do+ 
d
::
	`
(doc),

2083 &
ro
, &
rs
);

2084 
	`JSONTEST_ASSERT
(
ok
);

2085 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2086 
	`JSONTEST_ASSERT_EQUAL
("vue", 
ro
[1u]);

2087 
de
 
ad
;

2088 
	}
}

2089 
	$JSONTEST_FIXTURE
(
ChRdFaIfExaTe
, 
commtABo
) {

2090 
Js
::
ChRdBud
 
b
;

2091 
Js
::
Vue
 
ro
;

2092 cڡ 
doc
[] =

2094 
b
.
gs_
["IfExa"] = 
ue
;

2095 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2096 
JSONCPP_STRING
 
rs
;

2097 
bo
 
ok
 = 
ad
->
	`r
(

2098 
doc
, do+ 
d
::
	`
(doc),

2099 &
ro
, &
rs
);

2100 
	`JSONTEST_ASSERT
(
ok
);

2101 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2102 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
ro
.
	`asBo
());

2103 
de
 
ad
;

2104 
	}
}

2105 
	gChRdAowDrNuTe
 : 
JsTe
::
TeCa
 {};

2107 
	$JSONTEST_FIXTURE
(
ChRdAowDrNuTe
, 
issue178
) {

2108 
Js
::
ChRdBud
 
b
;

2109 
b
.
gs_
["lowDrݳdNuPhds"] = 
ue
;

2110 
Js
::
Vue
 
ro
;

2111 
JSONCPP_STRING
 
rs
;

2112 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2114 cڡ 
doc
[] = "{\"a\":,\"b\":true}";

2115 
bo
 
ok
 = 
ad
->
	`r
(

2116 
doc
, do+ 
d
::
	`
(doc),

2117 &
ro
, &
rs
);

2118 
	`JSONTEST_ASSERT
(
ok
);

2119 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2120 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2121 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
nuVue
, 
ro
.
	`g
("a", 
ue
));

2124 cڡ 
doc
[] = "{\"a\":}";

2125 
bo
 
ok
 = 
ad
->
	`r
(

2126 
doc
, do+ 
d
::
	`
(doc),

2127 &
ro
, &
rs
);

2128 
	`JSONTEST_ASSERT
(
ok
);

2129 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2130 
	`JSONTEST_ASSERT_EQUAL
(1u, 
ro
.
	`size
());

2131 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
nuVue
, 
ro
.
	`g
("a", 
ue
));

2134 cڡ 
doc
[] = "[]";

2135 
bo
 
ok
 = 
ad
->
	`r
(

2136 
doc
, do+ 
d
::
	`
(doc),

2137 &
ro
, &
rs
);

2138 
	`JSONTEST_ASSERT
(
ok
);

2139 
	`JSONTEST_ASSERT
(
rs
 == "");

2140 
	`JSONTEST_ASSERT_EQUAL
(0u, 
ro
.
	`size
());

2141 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
yVue
, 
ro
);

2144 cڡ 
doc
[] = "[null]";

2145 
bo
 
ok
 = 
ad
->
	`r
(

2146 
doc
, do+ 
d
::
	`
(doc),

2147 &
ro
, &
rs
);

2148 
	`JSONTEST_ASSERT
(
ok
);

2149 
	`JSONTEST_ASSERT
(
rs
 == "");

2150 
	`JSONTEST_ASSERT_EQUAL
(1u, 
ro
.
	`size
());

2153 cڡ 
doc
[] = "[,]";

2154 
bo
 
ok
 = 
ad
->
	`r
(

2155 
doc
, do+ 
d
::
	`
(doc),

2156 &
ro
, &
rs
);

2157 
	`JSONTEST_ASSERT
(
ok
);

2158 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2159 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2162 cڡ 
doc
[] = "[,,,]";

2163 
bo
 
ok
 = 
ad
->
	`r
(

2164 
doc
, do+ 
d
::
	`
(doc),

2165 &
ro
, &
rs
);

2166 
	`JSONTEST_ASSERT
(
ok
);

2167 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2168 
	`JSONTEST_ASSERT_EQUAL
(4u, 
ro
.
	`size
());

2171 cڡ 
doc
[] = "[null,]";

2172 
bo
 
ok
 = 
ad
->
	`r
(

2173 
doc
, do+ 
d
::
	`
(doc),

2174 &
ro
, &
rs
);

2175 
	`JSONTEST_ASSERT
(
ok
);

2176 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2177 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2180 cڡ 
doc
[] = "[,null]";

2181 
bo
 
ok
 = 
ad
->
	`r
(

2182 
doc
, do+ 
d
::
	`
(doc),

2183 &
ro
, &
rs
);

2184 
	`JSONTEST_ASSERT
(
ok
);

2185 
	`JSONTEST_ASSERT
(
rs
 == "");

2186 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2189 cڡ 
doc
[] = "[,,]";

2190 
bo
 
ok
 = 
ad
->
	`r
(

2191 
doc
, do+ 
d
::
	`
(doc),

2192 &
ro
, &
rs
);

2193 
	`JSONTEST_ASSERT
(
ok
);

2194 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2195 
	`JSONTEST_ASSERT_EQUAL
(3u, 
ro
.
	`size
());

2198 cڡ 
doc
[] = "[null,,]";

2199 
bo
 
ok
 = 
ad
->
	`r
(

2200 
doc
, do+ 
d
::
	`
(doc),

2201 &
ro
, &
rs
);

2202 
	`JSONTEST_ASSERT
(
ok
);

2203 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2204 
	`JSONTEST_ASSERT_EQUAL
(3u, 
ro
.
	`size
());

2207 cڡ 
doc
[] = "[,null,]";

2208 
bo
 
ok
 = 
ad
->
	`r
(

2209 
doc
, do+ 
d
::
	`
(doc),

2210 &
ro
, &
rs
);

2211 
	`JSONTEST_ASSERT
(
ok
);

2212 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2213 
	`JSONTEST_ASSERT_EQUAL
(3u, 
ro
.
	`size
());

2216 cڡ 
doc
[] = "[,,null]";

2217 
bo
 
ok
 = 
ad
->
	`r
(

2218 
doc
, do+ 
d
::
	`
(doc),

2219 &
ro
, &
rs
);

2220 
	`JSONTEST_ASSERT
(
ok
);

2221 
	`JSONTEST_ASSERT
(
rs
 == "");

2222 
	`JSONTEST_ASSERT_EQUAL
(3u, 
ro
.
	`size
());

2225 cڡ 
doc
[] = "[[],,,]";

2226 
bo
 
ok
 = 
ad
->
	`r
(

2227 
doc
, do+ 
d
::
	`
(doc),

2228 &
ro
, &
rs
);

2229 
	`JSONTEST_ASSERT
(
ok
);

2230 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2231 
	`JSONTEST_ASSERT_EQUAL
(4u, 
ro
.
	`size
());

2232 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
yVue
, 
ro
[0u]);

2235 cڡ 
doc
[] = "[,[],,]";

2236 
bo
 
ok
 = 
ad
->
	`r
(

2237 
doc
, do+ 
d
::
	`
(doc),

2238 &
ro
, &
rs
);

2239 
	`JSONTEST_ASSERT
(
ok
);

2240 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2241 
	`JSONTEST_ASSERT_EQUAL
(4u, 
ro
.
	`size
());

2242 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
yVue
, 
ro
[1u]);

2245 cڡ 
doc
[] = "[,,,[]]";

2246 
bo
 
ok
 = 
ad
->
	`r
(

2247 
doc
, do+ 
d
::
	`
(doc),

2248 &
ro
, &
rs
);

2249 
	`JSONTEST_ASSERT
(
ok
);

2250 
	`JSONTEST_ASSERT
(
rs
 == "");

2251 
	`JSONTEST_ASSERT_EQUAL
(4u, 
ro
.
	`size
());

2252 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
yVue
, 
ro
[3u]);

2254 
de
 
ad
;

2255 
	}
}

2257 
	gChRdAowSgQuesTe
 : 
JsTe
::
TeCa
 {};

2259 
	$JSONTEST_FIXTURE
(
ChRdAowSgQuesTe
, 
issue182
) {

2260 
Js
::
ChRdBud
 
b
;

2261 
b
.
gs_
["lowSgQues"] = 
ue
;

2262 
Js
::
Vue
 
ro
;

2263 
JSONCPP_STRING
 
rs
;

2264 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2266 cڡ 
doc
[] = "{'a':true,\"b\":true}";

2267 
bo
 
ok
 = 
ad
->
	`r
(

2268 
doc
, do+ 
d
::
	`
(doc),

2269 &
ro
, &
rs
);

2270 
	`JSONTEST_ASSERT
(
ok
);

2271 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2272 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2273 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
ro
.
	`g
("a", 
l
));

2274 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
ro
.
	`g
("b", 
l
));

2277 cڡ 
doc
[] = "{'a': 'x', \"b\":'y'}";

2278 
bo
 
ok
 = 
ad
->
	`r
(

2279 
doc
, do+ 
d
::
	`
(doc),

2280 &
ro
, &
rs
);

2281 
	`JSONTEST_ASSERT
(
ok
);

2282 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2283 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2284 
	`JSONTEST_ASSERT_STRING_EQUAL
("x", 
ro
["a"].
	`asSg
());

2285 
	`JSONTEST_ASSERT_STRING_EQUAL
("y", 
ro
["b"].
	`asSg
());

2287 
de
 
ad
;

2288 
	}
}

2290 
	gChRdAowZsTe
 : 
JsTe
::
TeCa
 {};

2292 
	$JSONTEST_FIXTURE
(
ChRdAowZsTe
, 
issue176
) {

2293 
Js
::
ChRdBud
 
b
;

2294 
b
.
gs_
["lowSgQues"] = 
ue
;

2295 
Js
::
Vue
 
ro
;

2296 
JSONCPP_STRING
 
rs
;

2297 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2299 cڡ 
doc
[] = "{'a':true,\"b\":true}";

2300 
bo
 
ok
 = 
ad
->
	`r
(

2301 
doc
, do+ 
d
::
	`
(doc),

2302 &
ro
, &
rs
);

2303 
	`JSONTEST_ASSERT
(
ok
);

2304 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2305 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2306 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
ro
.
	`g
("a", 
l
));

2307 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
ro
.
	`g
("b", 
l
));

2310 cڡ 
doc
[] = "{'a': 'x', \"b\":'y'}";

2311 
bo
 
ok
 = 
ad
->
	`r
(

2312 
doc
, do+ 
d
::
	`
(doc),

2313 &
ro
, &
rs
);

2314 
	`JSONTEST_ASSERT
(
ok
);

2315 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2316 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2317 
	`JSONTEST_ASSERT_STRING_EQUAL
("x", 
ro
["a"].
	`asSg
());

2318 
	`JSONTEST_ASSERT_STRING_EQUAL
("y", 
ro
["b"].
	`asSg
());

2320 
de
 
ad
;

2321 
	}
}

2323 
	gChRdAowSclFltsTe
 : 
JsTe
::
TeCa
 {};

2325 
	$JSONTEST_FIXTURE
(
ChRdAowSclFltsTe
, 
issue209
) {

2326 
Js
::
ChRdBud
 
b
;

2327 
b
.
gs_
["lowSclFlts"] = 
ue
;

2328 
Js
::
Vue
 
ro
;

2329 
JSONCPP_STRING
 
rs
;

2330 
Js
::
ChRd
* 
	`ad
(
b
.
	`wChRd
());

2332 cڡ 
doc
[] = "{\"a\":NaN,\"b\":Infinity,\"c\":-Infinity}";

2333 
bo
 
ok
 = 
ad
->
	`r
(

2334 
doc
, do+ 
d
::
	`
(doc),

2335 &
ro
, &
rs
);

2336 
	`JSONTEST_ASSERT
(
ok
);

2337 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2338 
	`JSONTEST_ASSERT_EQUAL
(3u, 
ro
.
	`size
());

2339 
n
 = 
ro
["a"].
	`asDoub
();

2340 
	`JSONTEST_ASSERT
(
n
 !=);

2341 
	`JSONTEST_ASSERT_EQUAL
(
d
::
numic_lims
<>::
	`fy
(), 
ro
.
	`g
("b", 0.0));

2342 
	`JSONTEST_ASSERT_EQUAL
(-
d
::
numic_lims
<>::
	`fy
(), 
ro
.
	`g
("c", 0.0));

2345 
	sTeDa
 {

2346 
le
;

2347 
bo
 
ok
;

2348 
JSONCPP_STRING
 

;

2350 cڡ 
TeDa
 
_da
[] = {

2351 {
__LINE__
, 1, "{\"a\":9}"},

2352 {
__LINE__
, 0, "{\"a\":0Infinity}"},

2353 {
__LINE__
, 0, "{\"a\":1Infinity}"},

2354 {
__LINE__
, 0, "{\"a\":9Infinity}"},

2355 {
__LINE__
, 0, "{\"a\":0nfinity}"},

2356 {
__LINE__
, 0, "{\"a\":1nfinity}"},

2357 {
__LINE__
, 0, "{\"a\":9nfinity}"},

2358 {
__LINE__
, 0, "{\"a\":nfinity}"},

2359 {
__LINE__
, 0, "{\"a\":.nfinity}"},

2360 {
__LINE__
, 0, "{\"a\":9nfinity}"},

2361 {
__LINE__
, 0, "{\"a\":-nfinity}"},

2362 {
__LINE__
, 1, "{\"a\":Infinity}"},

2363 {
__LINE__
, 0, "{\"a\":.Infinity}"},

2364 {
__LINE__
, 0, "{\"a\":_Infinity}"},

2365 {
__LINE__
, 0, "{\"a\":_nfinity}"},

2366 {
__LINE__
, 1, "{\"a\":-Infinity}"}

2368 
size_t
 
tdi
 = 0;d< (
_da
) / (*test_data); ++tdi) {

2369 cڡ 
TeDa
& 
td
 = 
_da
[
tdi
];

2370 
bo
 
ok
 = 
ad
->
	`r
(&*
td
.

.
	`beg
(),

2371 &*
td
.

.
	`beg
(+d..
	`size
(),

2372 &
ro
, &
rs
);

2373 
	`JSONTEST_ASSERT
(
td
.
ok
 == ok)

2374 << "le:" << 
td
.
le
 << "\n"

2376 << "ok:" << 
td
.
ok


2377 << ", in:\'" << 
td
.

 << "\'"

2380 << "ok:" << 
ok


2385 cڡ 
doc
[] = "{\"posInf\": Infinity, \"NegInf\": -Infinity}";

2386 
bo
 
ok
 = 
ad
->
	`r
(

2387 
doc
, do+ 
d
::
	`
(doc),

2388 &
ro
, &
rs
);

2389 
	`JSONTEST_ASSERT
(
ok
);

2390 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 
rs
);

2391 
	`JSONTEST_ASSERT_EQUAL
(2u, 
ro
.
	`size
());

2392 
	`JSONTEST_ASSERT_EQUAL
(
d
::
numic_lims
<>::
	`fy
(), 
ro
["posInf"].
	`asDoub
());

2393 
	`JSONTEST_ASSERT_EQUAL
(-
d
::
numic_lims
<>::
	`fy
(), 
ro
["NegInf"].
	`asDoub
());

2395 
de
 
ad
;

2396 
	}
}

2398 
	gBudTe
 : 
JsTe
::
TeCa
 {};

2400 
	$JSONTEST_FIXTURE
(
BudTe
, 
gs
) {

2402 
Js
::
Vue
 
rs
;

2403 
Js
::
ChRdBud
 
rb
;

2404 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
rb
.
gs_
.
	`isMemb
("foo"));

2405 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
rb
.
	`vide
(&
rs
));

2406 
rb
["foo"] = "bar";

2407 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
rb
.
gs_
.
	`isMemb
("foo"));

2408 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
rb
.
	`vide
(&
rs
));

2411 
Js
::
Vue
 
rs
;

2412 
Js
::
SmWrBud
 
wb
;

2413 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
wb
.
gs_
.
	`isMemb
("foo"));

2414 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
wb
.
	`vide
(&
rs
));

2415 
wb
["foo"] = "bar";

2416 
	`JSONTEST_ASSERT_EQUAL
(
ue
, 
wb
.
gs_
.
	`isMemb
("foo"));

2417 
	`JSONTEST_ASSERT_EQUAL
(
l
, 
wb
.
	`vide
(&
rs
));

2419 
	}
}

2421 
	gItTe
 : 
JsTe
::
TeCa
 {};

2423 
	$JSONTEST_FIXTURE
(
ItTe
, 
di
) {

2424 
Js
::
Vue
 
js
;

2425 
js
["k1"] = "a";

2426 
js
["k2"] = "b";

2427 
di
 = 0;

2428 
JSONCPP_STRING
 
r
;

2429 
Js
::
VueIt
 

 = 
js
.
	`beg
(); i!js.
	`d
(); ++it) {

2430 
di
 = 

 - 
js
.
	`beg
();

2431 
r
 = 

->
	`asSg
().
	`c_r
();

2433 
	`JSONTEST_ASSERT_EQUAL
(1, 
di
);

2434 
	`JSONTEST_ASSERT_STRING_EQUAL
("b", 
r
);

2435 
	}
}

2437 
	$JSONTEST_FIXTURE
(
ItTe
, 
mes
) {

2438 
Js
::
Vue
 
js
;

2439 
js
["k1"] = "a";

2440 
js
["k2"] = "b";

2441 
Js
::
VueIt
 

 = 
js
.
	`beg
();

2442 
	`JSONTEST_ASSERT
(

 !
js
.
	`d
());

2443 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
("k1"), 

.
	`key
());

2444 
	`JSONTEST_ASSERT_STRING_EQUAL
("k1", 

.
	`me
());

2445 
	`JSONTEST_ASSERT_EQUAL
(-1, 

.
	`dex
());

2446 ++

;

2447 
	`JSONTEST_ASSERT
(

 !
js
.
	`d
());

2448 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
("k2"), 

.
	`key
());

2449 
	`JSONTEST_ASSERT_STRING_EQUAL
("k2", 

.
	`me
());

2450 
	`JSONTEST_ASSERT_EQUAL
(-1, 

.
	`dex
());

2451 ++

;

2452 
	`JSONTEST_ASSERT
(

 =
js
.
	`d
());

2453 
	}
}

2455 
	$JSONTEST_FIXTURE
(
ItTe
, 
dexes
) {

2456 
Js
::
Vue
 
js
;

2457 
js
[0] = "a";

2458 
js
[1] = "b";

2459 
Js
::
VueIt
 

 = 
js
.
	`beg
();

2460 
	`JSONTEST_ASSERT
(

 !
js
.
	`d
());

2461 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(Js::
	`AayIndex
(0)), 

.
	`key
());

2462 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 

.
	`me
());

2463 
	`JSONTEST_ASSERT_EQUAL
(0, 

.
	`dex
());

2464 ++

;

2465 
	`JSONTEST_ASSERT
(

 !
js
.
	`d
());

2466 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
	`Vue
(Js::
	`AayIndex
(1)), 

.
	`key
());

2467 
	`JSONTEST_ASSERT_STRING_EQUAL
("", 

.
	`me
());

2468 
	`JSONTEST_ASSERT_EQUAL
(1, 

.
	`dex
());

2469 ++

;

2470 
	`JSONTEST_ASSERT
(

 =
js
.
	`d
());

2471 
	}
}

2473 
	$JSONTEST_FIXTURE
(
ItTe
, const) {

2474 
Js
::
Vue
 cڡ 
v
;

2475 
	`JSONTEST_ASSERT_THROWS
(

2476 
Js
::
Vue
::

 
	`
(
v
.
	`beg
())

2479 
Js
::
Vue
 
vue
;

2481 
i
 = 9; i < 12; ++i)

2483 
JSONCPP_OSTRINGSTREAM
 
out
;

2484 
out
 << 
d
::
	`tw
(2<< 
i
;

2485 
JSONCPP_STRING
 
r
 = 
out
.
	`r
();

2486 
vue
[
r
] = str;

2489 
JSONCPP_OSTRINGSTREAM
 
out
;

2491 
Js
::
Vue
::
cڡ_
 

 = 
vue
.
	`beg
();

2492 ; 

 !
vue
.
	`d
(); ++iter)

2494 
out
 << *

 << ',';

2496 
JSONCPP_STRING
 
exed
 = "\" 9\",\"10\",\"11\",";

2497 
	`JSONTEST_ASSERT_STRING_EQUAL
(
exed
, 
out
.
	`r
());

2498 
	}
}

2500 
	gRVueTe
 : 
JsTe
::
TeCa
 {};

2502 
	$JSONTEST_FIXTURE
(
RVueTe
, 
moveCڡrui
) {

2503 #i
JSON_HAS_RVALUE_REFERENCES


2504 
Js
::
Vue
 
js
;

2505 
js
["key"] = "value";

2506 
Js
::
Vue
 
moved
 = 
d
::
	`move
(
js
);

2507 
	`JSONTEST_ASSERT
(
moved
 !
js
);

2508 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
objeVue
, 
moved
.
	`ty
());

2509 
	`JSONTEST_ASSERT_EQUAL
(
Js
::
rgVue
, 
moved
["key"].
	`ty
());

2511 
	}
}

2513 
	$ma
(
gc
, cڡ * 
gv
[]) {

2514 
JsTe
::
Ru
 
ru
;

2515 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
checkNmizeFltgPotS
);

2516 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
membCou
);

2517 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
objes
);

2518 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
ys
);

2519 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
yIssue252
);

2520 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
nu
);

2521 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
rgs
);

2522 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
bos
);

2523 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
gs
);

2524 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
nIegs
);

2525 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comNu
);

2526 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comI
);

2527 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comUI
);

2528 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comDoub
);

2529 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comSg
);

2530 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comBoޗn
);

2531 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comAay
);

2532 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comObje
);

2533 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
comTy
);

2534 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
offtAcsss
);

2535 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
tyChecksThrowExis
);

2536 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
SticSg
);

2537 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
CommtBefe
);

2539 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
zs
);

2540 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
zsInKeys
);

2541 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
eclFlts
);

2542 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
VueTe
, 
ecisi
);

2544 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
WrTe
, 
drNuPhds
);

2545 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
SmWrTe
, 
drNuPhds
);

2546 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
SmWrTe
, 
wreZs
);

2548 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
RdTe
, 
rWhNoEs
);

2549 
	`JSONTEST_REGISTER_FIXTURE
(

2550 
ru
, 
RdTe
, 
rWhNoEsTegOffts
);

2551 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
RdTe
, 
rWhOE
);

2552 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
RdTe
, 
rCheWhOE
);

2553 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
RdTe
, 
rWhDaE
);

2555 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdTe
, 
rWhNoEs
);

2556 
	`JSONTEST_REGISTER_FIXTURE
(

2557 
ru
, 
ChRdTe
, 
rWhNoEsTegOffts
);

2558 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdTe
, 
rWhOE
);

2559 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdTe
, 
rCheWhOE
);

2560 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdTe
, 
rWhDaE
);

2561 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdTe
, 
rWhSckLim
);

2563 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdSiModeTe
, 
dupKeys
);

2565 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdFaIfExaTe
, 
issue164
);

2566 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdFaIfExaTe
, 
issue107
);

2567 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdFaIfExaTe
, 
commtAObje
);

2568 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdFaIfExaTe
, 
commtAAay
);

2569 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdFaIfExaTe
, 
commtABo
);

2571 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdAowDrNuTe
, 
issue178
);

2573 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdAowSgQuesTe
, 
issue182
);

2575 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdAowZsTe
, 
issue176
);

2577 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ChRdAowSclFltsTe
, 
issue209
);

2579 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
BudTe
, 
gs
);

2581 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ItTe
, 
di
);

2582 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ItTe
, 
mes
);

2583 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ItTe
, 
dexes
);

2584 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
ItTe
, const);

2586 
	`JSONTEST_REGISTER_FIXTURE
(
ru
, 
RVueTe
, 
moveCڡrui
);

2588  
ru
.
	`runCommdLe
(
gc
, 
gv
);

2589 
	}
}

	@src/ME_802_1p_mapper_service_profile.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_802_1p_mr_rvi_ofe.h
>

15 
	gME_802_1p_mr_rvi_ofe
::
	$ME_802_1p_mr_rvi_ofe
()

18 
	}
}

20 
ME_802_1p_mr_rvi_ofe
::
	$ME_802_1p_mr_rvi_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_802_1p_mr_rvi_ofe
::~
	$ME_802_1p_mr_rvi_ofe
()

27 
	`tf
("~ME_802_1p_mapper_service_profile\r\n");

28 
	}
}

30 
	gME_802_1p_mr_rvi_ofe
::
	$g_mhod
()

32 
	`tf
("ME_802_1p_mapper_service_profile get_method\r\n");

33 
	}
}

38 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

272 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_10_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

274 
_Ai
)

276 
MSG_TYPE_GET
:

279 
g
 = (*)&
m_Aribus
[9].
Vue
;

282 
MSG_TYPE_SET
:

285 
m_Aribus
[9].
Vue
 = *
vue
;

293  
ue
;

294 
	}
}

298 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_11_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

300 
_Ai
)

302 
MSG_TYPE_GET
:

305 
g
 = (*)&
m_Aribus
[10].
Vue
;

308 
MSG_TYPE_SET
:

311 
m_Aribus
[10].
Vue
 = *
vue
;

319  
ue
;

320 
	}
}

324 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_12_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

326 
_Ai
)

328 
MSG_TYPE_GET
:

331 
g
 = (*)&
m_Aribus
[11].
Vue
;

334 
MSG_TYPE_SET
:

337 
m_Aribus
[11].
Vue
 = *
vue
;

345  
ue
;

346 
	}
}

350 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_13_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

352 
_Ai
)

354 
MSG_TYPE_GET
:

357 
g
 = (*)&
m_Aribus
[12].
Vue
;

360 
MSG_TYPE_SET
:

363 
m_Aribus
[12].
Vue
 = *
vue
;

371  
ue
;

372 
	}
}

376 
bo
 
	gME_802_1p_mr_rvi_ofe
::
	$ibu_14_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

378 
_Ai
)

380 
MSG_TYPE_GET
:

383 
g
 = (*)&
m_Aribus
[13].
Vue
;

386 
MSG_TYPE_SET
:

389 
m_Aribus
[13].
Vue
 = *
vue
;

397  
ue
;

398 
	}
}

	@src/ME_Extended_VLAN_tagging_operation_configuration_data.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_Exnded_VLAN_ggg_ݔi_cfiguti_da.h
>

15 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
()

18 
	}
}

20 
ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::~
	$ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
()

27 
	`tf
("~ME_Extended_VLAN_tagging_operation_configuration_data\r\n");

28 
	}
}

30 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$g_mhod
()

32 
	`tf
("ME_Extended_VLAN_tagging_operation_configuration_data get_method\r\n");

33 
	}
}

38 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_Exnded_VLAN_ggg_ݔi_cfiguti_da
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

	@src/ME_GAL_Ethernet_profile.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_GAL_Etht_ofe.h
>

15 
	gME_GAL_Etht_ofe
::
	$ME_GAL_Etht_ofe
()

18 
	}
}

20 
ME_GAL_Etht_ofe
::
	$ME_GAL_Etht_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_GAL_Etht_ofe
::~
	$ME_GAL_Etht_ofe
()

27 
	`tf
("~ME_GAL_Ethernet_profile\r\n");

28 
	}
}

30 
	gME_GAL_Etht_ofe
::
	$g_mhod
()

32 
	`tf
("ME_GAL_Ethernet_profile get_method\r\n");

33 
	}
}

38 
bo
 
	gME_GAL_Etht_ofe
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_GAL_Etht_ofe
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

	@src/ME_GEM_interworking_termination_point.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_GEM_rwkg_rmi_pot.h
>

15 
	gME_GEM_rwkg_rmi_pot
::
	$ME_GEM_rwkg_rmi_pot
()

18 
	}
}

20 
ME_GEM_rwkg_rmi_pot
::
	$ME_GEM_rwkg_rmi_pot
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_GEM_rwkg_rmi_pot
::~
	$ME_GEM_rwkg_rmi_pot
()

27 
	`tf
("~ME_GEM_interworking_termination_point\r\n");

28 
	}
}

30 
	gME_GEM_rwkg_rmi_pot
::
	$g_mhod
()

32 
	`tf
("ME_GEM_interworking_termination_point get_method\r\n");

33 
	}
}

38 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_GEM_rwkg_rmi_pot
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

	@src/ME_GEM_port_network_CTP.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_GEM_pt_twk_CTP.h
>

15 
	gME_GEM_pt_twk_CTP
::
	$ME_GEM_pt_twk_CTP
()

18 
	}
}

20 
ME_GEM_pt_twk_CTP
::
	$ME_GEM_pt_twk_CTP
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_GEM_pt_twk_CTP
::~
	$ME_GEM_pt_twk_CTP
()

27 
	`tf
("~ME_GEM_port_network_CTP\r\n");

28 
	}
}

30 
	gME_GEM_pt_twk_CTP
::
	$g_mhod
()

32 
	`tf
("ME_GEM_port_network_CTP get_method\r\n");

33 
	}
}

38 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_GEM_pt_twk_CTP
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

	@src/ME_MAC_bridge_configuration_data.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_MAC_bridge_cfiguti_da.h
>

15 
	gME_MAC_bridge_cfiguti_da
::
	$ME_MAC_bridge_cfiguti_da
()

18 
	}
}

20 
ME_MAC_bridge_cfiguti_da
::
	$ME_MAC_bridge_cfiguti_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_MAC_bridge_cfiguti_da
::~
	$ME_MAC_bridge_cfiguti_da
()

27 
	`tf
("~ME_MAC_bridge_configuration_data\r\n");

28 
	}
}

30 
	gME_MAC_bridge_cfiguti_da
::
	$g_mhod
()

32 
	`tf
("ME_MAC_bridge_configuration_data get_method\r\n");

33 
	}
}

38 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_MAC_bridge_cfiguti_da
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

	@src/ME_MAC_bridge_port_configuration_data.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_MAC_bridge_pt_cfiguti_da.h
>

15 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ME_MAC_bridge_pt_cfiguti_da
()

18 
	}
}

20 
ME_MAC_bridge_pt_cfiguti_da
::
	$ME_MAC_bridge_pt_cfiguti_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_MAC_bridge_pt_cfiguti_da
::~
	$ME_MAC_bridge_pt_cfiguti_da
()

27 
	`tf
("~ME_MAC_bridge_port_configuration_data\r\n");

28 
	}
}

30 
	gME_MAC_bridge_pt_cfiguti_da
::
	$g_mhod
()

32 
	`tf
("ME_MAC_bridge_port_configuration_data get_method\r\n");

33 
	}
}

38 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

272 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_10_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

274 
_Ai
)

276 
MSG_TYPE_GET
:

279 
g
 = (*)&
m_Aribus
[9].
Vue
;

282 
MSG_TYPE_SET
:

285 
m_Aribus
[9].
Vue
 = *
vue
;

293  
ue
;

294 
	}
}

298 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_11_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

300 
_Ai
)

302 
MSG_TYPE_GET
:

305 
g
 = (*)&
m_Aribus
[10].
Vue
;

308 
MSG_TYPE_SET
:

311 
m_Aribus
[10].
Vue
 = *
vue
;

319  
ue
;

320 
	}
}

324 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_12_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

326 
_Ai
)

328 
MSG_TYPE_GET
:

331 
g
 = (*)&
m_Aribus
[11].
Vue
;

334 
MSG_TYPE_SET
:

337 
m_Aribus
[11].
Vue
 = *
vue
;

345  
ue
;

346 
	}
}

350 
bo
 
	gME_MAC_bridge_pt_cfiguti_da
::
	$ibu_13_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

352 
_Ai
)

354 
MSG_TYPE_GET
:

357 
g
 = (*)&
m_Aribus
[12].
Vue
;

360 
MSG_TYPE_SET
:

363 
m_Aribus
[12].
Vue
 = *
vue
;

371  
ue
;

372 
	}
}

	@src/ME_MAC_bridge_service_profile.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_MAC_bridge_rvi_ofe.h
>

15 
	gME_MAC_bridge_rvi_ofe
::
	$ME_MAC_bridge_rvi_ofe
()

18 
	}
}

20 
ME_MAC_bridge_rvi_ofe
::
	$ME_MAC_bridge_rvi_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_MAC_bridge_rvi_ofe
::~
	$ME_MAC_bridge_rvi_ofe
()

27 
	`tf
("~ME_MAC_bridge_service_profile\r\n");

28 
	}
}

30 
	gME_MAC_bridge_rvi_ofe
::
	$g_mhod
()

32 
	`tf
("ME_MAC_bridge_service_profile get_method\r\n");

33 
	}
}

38 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

272 
bo
 
	gME_MAC_bridge_rvi_ofe
::
	$ibu_10_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

274 
_Ai
)

276 
MSG_TYPE_GET
:

279 
g
 = (*)&
m_Aribus
[9].
Vue
;

282 
MSG_TYPE_SET
:

285 
m_Aribus
[9].
Vue
 = *
vue
;

293  
ue
;

294 
	}
}

	@src/ME_Multicast_GEM_interworking_termination_point.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_Mui_GEM_rwkg_rmi_pot.h
>

15 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ME_Mui_GEM_rwkg_rmi_pot
()

18 
	}
}

20 
ME_Mui_GEM_rwkg_rmi_pot
::
	$ME_Mui_GEM_rwkg_rmi_pot
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_Mui_GEM_rwkg_rmi_pot
::~
	$ME_Mui_GEM_rwkg_rmi_pot
()

27 
	`tf
("~ME_Multicast_GEM_interworking_termination_point\r\n");

28 
	}
}

30 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$g_mhod
()

32 
	`tf
("ME_Multicast_GEM_interworking_termination_point get_method\r\n");

33 
	}
}

38 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_Mui_GEM_rwkg_rmi_pot
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

	@src/ME_Multicast_operations_profile.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_Mui_ݔis_ofe.h
>

15 
	gME_Mui_ݔis_ofe
::
	$ME_Mui_ݔis_ofe
()

18 
	}
}

20 
ME_Mui_ݔis_ofe
::
	$ME_Mui_ݔis_ofe
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_Mui_ݔis_ofe
::~
	$ME_Mui_ݔis_ofe
()

27 
	`tf
("~ME_Multicast_operations_profile\r\n");

28 
	}
}

30 
	gME_Mui_ݔis_ofe
::
	$g_mhod
()

32 
	`tf
("ME_Multicast_operations_profile get_method\r\n");

33 
	}
}

38 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

272 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_10_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

274 
_Ai
)

276 
MSG_TYPE_GET
:

279 
g
 = (*)&
m_Aribus
[9].
Vue
;

282 
MSG_TYPE_SET
:

285 
m_Aribus
[9].
Vue
 = *
vue
;

293  
ue
;

294 
	}
}

298 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_11_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

300 
_Ai
)

302 
MSG_TYPE_GET
:

305 
g
 = (*)&
m_Aribus
[10].
Vue
;

308 
MSG_TYPE_SET
:

311 
m_Aribus
[10].
Vue
 = *
vue
;

319  
ue
;

320 
	}
}

324 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_12_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

326 
_Ai
)

328 
MSG_TYPE_GET
:

331 
g
 = (*)&
m_Aribus
[11].
Vue
;

334 
MSG_TYPE_SET
:

337 
m_Aribus
[11].
Vue
 = *
vue
;

345  
ue
;

346 
	}
}

350 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_13_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

352 
_Ai
)

354 
MSG_TYPE_GET
:

357 
g
 = (*)&
m_Aribus
[12].
Vue
;

360 
MSG_TYPE_SET
:

363 
m_Aribus
[12].
Vue
 = *
vue
;

371  
ue
;

372 
	}
}

376 
bo
 
	gME_Mui_ݔis_ofe
::
	$ibu_14_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

378 
_Ai
)

380 
MSG_TYPE_GET
:

383 
g
 = (*)&
m_Aribus
[13].
Vue
;

386 
MSG_TYPE_SET
:

389 
m_Aribus
[13].
Vue
 = *
vue
;

397  
ue
;

398 
	}
}

	@src/ME_Multicast_subscriber_config_info.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_Mui_subsib_cfig_fo.h
>

15 
	gME_Mui_subsib_cfig_fo
::
	$ME_Mui_subsib_cfig_fo
()

18 
	}
}

20 
ME_Mui_subsib_cfig_fo
::
	$ME_Mui_subsib_cfig_fo
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_Mui_subsib_cfig_fo
::~
	$ME_Mui_subsib_cfig_fo
()

27 
	`tf
("~ME_Multicast_subscriber_config_info\r\n");

28 
	}
}

30 
	gME_Mui_subsib_cfig_fo
::
	$g_mhod
()

32 
	`tf
("ME_Multicast_subscriber_config_info get_method\r\n");

33 
	}
}

38 
bo
 
	gME_Mui_subsib_cfig_fo
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_Mui_subsib_cfig_fo
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_Mui_subsib_cfig_fo
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_Mui_subsib_cfig_fo
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_Mui_subsib_cfig_fo
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_Mui_subsib_cfig_fo
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

	@src/ME_ONT_data.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_ONT_da.h
>

15 
	gME_ONT_da
::
	$ME_ONT_da
()

18 
	}
}

20 
ME_ONT_da
::
	$ME_ONT_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_ONT_da
::~
	$ME_ONT_da
()

27 
	`tf
("~ME_ONT_data\r\n");

28 
	}
}

30 
	gME_ONT_da
::
	$g_mhod
()

32 
	`tf
("ME_ONT_data get_method\r\n");

33 
	}
}

38 
bo
 
	gME_ONT_da
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_ONT_da
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

	@src/ME_Physical_path_termination_point_Ethernet_UNI.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_Physil_th_rmi_pot_Etht_UNI.h
>

15 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ME_Physil_th_rmi_pot_Etht_UNI
()

18 
	}
}

20 
ME_Physil_th_rmi_pot_Etht_UNI
::
	$ME_Physil_th_rmi_pot_Etht_UNI
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_Physil_th_rmi_pot_Etht_UNI
::~
	$ME_Physil_th_rmi_pot_Etht_UNI
()

27 
	`tf
("~ME_Physical_path_termination_point_Ethernet_UNI\r\n");

28 
	}
}

30 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$g_mhod
()

32 
	`tf
("ME_Physical_path_termination_point_Ethernet_UNI get_method\r\n");

33 
	}
}

38 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

142 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_5_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

144 
_Ai
)

146 
MSG_TYPE_GET
:

149 
g
 = (*)&
m_Aribus
[4].
Vue
;

152 
MSG_TYPE_SET
:

155 
m_Aribus
[4].
Vue
 = *
vue
;

163  
ue
;

164 
	}
}

168 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_6_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

170 
_Ai
)

172 
MSG_TYPE_GET
:

175 
g
 = (*)&
m_Aribus
[5].
Vue
;

178 
MSG_TYPE_SET
:

181 
m_Aribus
[5].
Vue
 = *
vue
;

189  
ue
;

190 
	}
}

194 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_7_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

196 
_Ai
)

198 
MSG_TYPE_GET
:

201 
g
 = (*)&
m_Aribus
[6].
Vue
;

204 
MSG_TYPE_SET
:

207 
m_Aribus
[6].
Vue
 = *
vue
;

215  
ue
;

216 
	}
}

220 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_8_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

222 
_Ai
)

224 
MSG_TYPE_GET
:

227 
g
 = (*)&
m_Aribus
[7].
Vue
;

230 
MSG_TYPE_SET
:

233 
m_Aribus
[7].
Vue
 = *
vue
;

241  
ue
;

242 
	}
}

246 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_9_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

248 
_Ai
)

250 
MSG_TYPE_GET
:

253 
g
 = (*)&
m_Aribus
[8].
Vue
;

256 
MSG_TYPE_SET
:

259 
m_Aribus
[8].
Vue
 = *
vue
;

267  
ue
;

268 
	}
}

272 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_10_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

274 
_Ai
)

276 
MSG_TYPE_GET
:

279 
g
 = (*)&
m_Aribus
[9].
Vue
;

282 
MSG_TYPE_SET
:

285 
m_Aribus
[9].
Vue
 = *
vue
;

293  
ue
;

294 
	}
}

298 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_11_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

300 
_Ai
)

302 
MSG_TYPE_GET
:

305 
g
 = (*)&
m_Aribus
[10].
Vue
;

308 
MSG_TYPE_SET
:

311 
m_Aribus
[10].
Vue
 = *
vue
;

319  
ue
;

320 
	}
}

324 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_12_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

326 
_Ai
)

328 
MSG_TYPE_GET
:

331 
g
 = (*)&
m_Aribus
[11].
Vue
;

334 
MSG_TYPE_SET
:

337 
m_Aribus
[11].
Vue
 = *
vue
;

345  
ue
;

346 
	}
}

350 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_13_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

352 
_Ai
)

354 
MSG_TYPE_GET
:

357 
g
 = (*)&
m_Aribus
[12].
Vue
;

360 
MSG_TYPE_SET
:

363 
m_Aribus
[12].
Vue
 = *
vue
;

371  
ue
;

372 
	}
}

376 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_14_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

378 
_Ai
)

380 
MSG_TYPE_GET
:

383 
g
 = (*)&
m_Aribus
[13].
Vue
;

386 
MSG_TYPE_SET
:

389 
m_Aribus
[13].
Vue
 = *
vue
;

397  
ue
;

398 
	}
}

402 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_15_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

404 
_Ai
)

406 
MSG_TYPE_GET
:

409 
g
 = (*)&
m_Aribus
[14].
Vue
;

412 
MSG_TYPE_SET
:

415 
m_Aribus
[14].
Vue
 = *
vue
;

423  
ue
;

424 
	}
}

428 
bo
 
	gME_Physil_th_rmi_pot_Etht_UNI
::
	$ibu_16_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

430 
_Ai
)

432 
MSG_TYPE_GET
:

435 
g
 = (*)&
m_Aribus
[15].
Vue
;

438 
MSG_TYPE_SET
:

441 
m_Aribus
[15].
Vue
 = *
vue
;

449  
ue
;

450 
	}
}

	@src/ME_T_CONT.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_T_CONT.h
>

15 
	gME_T_CONT
::
	$ME_T_CONT
()

18 
	}
}

20 
ME_T_CONT
::
	$ME_T_CONT
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_T_CONT
::~
	$ME_T_CONT
()

27 
	`tf
("~ME_T_CONT\r\n");

28 
	}
}

30 
	gME_T_CONT
::
	$g_mhod
()

32 
	`tf
("ME_T_CONT get_method\r\n");

33 
	}
}

38 
bo
 
	gME_T_CONT
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_T_CONT
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_T_CONT
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_T_CONT
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

	@src/ME_VLAN_tagging_filter_data.cpp

6 
	~<ioam
>

7 
	~<fam
>

8 
	~<iam
>

9 
	~<dt.h
>

10 
	~<sys/tys.h
>

11 
	~<rg.h
>

12 
	~<tyfo
>

13 
	~<ME_VLAN_ggg_fr_da.h
>

15 
	gME_VLAN_ggg_fr_da
::
	$ME_VLAN_ggg_fr_da
()

18 
	}
}

20 
ME_VLAN_ggg_fr_da
::
	$ME_VLAN_ggg_fr_da
(
ass_id
,
_id
, 
Js
::
Vue
 
me_s
):
	$ME_S
(
ass_id
, 
_id
, 
me_s
)

23 
	}
}

25 
	gME_VLAN_ggg_fr_da
::~
	$ME_VLAN_ggg_fr_da
()

27 
	`tf
("~ME_VLAN_tagging_filter_data\r\n");

28 
	}
}

30 
	gME_VLAN_ggg_fr_da
::
	$g_mhod
()

32 
	`tf
("ME_VLAN_tagging_filter_data get_method\r\n");

33 
	}
}

38 
bo
 
	gME_VLAN_ggg_fr_da
::
	$ibu_1_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

40 
_Ai
)

42 
MSG_TYPE_GET
:

45 
g
 = (*)&
m_Aribus
[0].
Vue
;

48 
MSG_TYPE_SET
:

51 
m_Aribus
[0].
Vue
 = *
vue
;

59  
ue
;

60 
	}
}

64 
bo
 
	gME_VLAN_ggg_fr_da
::
	$ibu_2_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

66 
_Ai
)

68 
MSG_TYPE_GET
:

71 
g
 = (*)&
m_Aribus
[1].
Vue
;

74 
MSG_TYPE_SET
:

77 
m_Aribus
[1].
Vue
 = *
vue
;

85  
ue
;

86 
	}
}

90 
bo
 
	gME_VLAN_ggg_fr_da
::
	$ibu_3_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

92 
_Ai
)

94 
MSG_TYPE_GET
:

97 
g
 = (*)&
m_Aribus
[2].
Vue
;

100 
MSG_TYPE_SET
:

103 
m_Aribus
[2].
Vue
 = *
vue
;

111  
ue
;

112 
	}
}

116 
bo
 
	gME_VLAN_ggg_fr_da
::
	$ibu_4_mhod
(
Ai
 
_Ai
, 
UI32_T
 *
vue
, *
g
)

118 
_Ai
)

120 
MSG_TYPE_GET
:

123 
g
 = (*)&
m_Aribus
[3].
Vue
;

126 
MSG_TYPE_SET
:

129 
m_Aribus
[3].
Vue
 = *
vue
;

137  
ue
;

138 
	}
}

	@src/base_class.cpp

1 
	~<ba_ass.h
>

2 
	~<rg
>

3 
	~<omci_rr.h
>

5 
	gME_S
::
	$ME_S
(
UI32_T
 
ass_id
,UI32_T 
_id
, 
Js
::
Vue
 
me_s
)

7 
m_ass_id
 = 
ass_id
;

8 
m__id
 = 
_id
;

9 
m_j_me
 = 
me_s
;

11 
d
::
rg
 
ai

m_j_me
["Ai"].
	`asSg
();

13 
	`tf
("Ai[%s]\r\n", 
ai
.
	`c_r
());

15 if(
ai
.
	`fd
(""!
d
::
rg
::
os
 )

17 
m_ais_b
 |
OMCI_Pr
::
	`g_omci_ai_id
("CREATE");

18 
	`tf
("C\r\n");

20 if(
ai
.
	`fd
("de")!
d
::
rg
::
os
 )

22 
m_ais_b
 |
OMCI_Pr
::
	`g_omci_ai_id
("DELETE");

23 
	`tf
("D\r\n");

25 if(
ai
.
	`fd
("g")!
d
::
rg
::
os
 )

27 
m_ais_b
 |
OMCI_Pr
::
	`g_omci_ai_id
("GET");

28 
	`tf
("G\r\n");

30 if(
ai
.
	`fd
("t")!
d
::
rg
::
os
 )

32 
m_ais_b
 |
OMCI_Pr
::
	`g_omci_ai_id
("SET");

33 
	`tf
("S\r\n");

35 if(
ai
.
	`fd
("bo")!
d
::
rg
::
os
 )

37 
m_ais_b
 |
OMCI_Pr
::
	`g_omci_ai_id
("REBOOT");

38 
	`tf
("R\r\n");

41 
	`tf
("aiځab[0x%04X]\r\n", 
m_ais_b
);

44 
	}
};

	@src/common.cpp

1 
	~<comm.h
>

3 
BOOL_T
 
	$mkdp
(cڡ * 
th
, 
mode_t
 
mode
)

5 * 
p
 = 
cڡ_
<*>(
th
);

7 *
p
 != '\0') {

8 
p
++;

10 *
p
 != '\0' && *p != '/')++;

12 
v
 = *
p
;

14 *
p
 = '\0';

16 if(
	`mkd
(
th
, 
mode
=-1 && 
o
 !
EEXIST
)

18 *
p
 = 
v
;

19  
l
;

21 *
p
 = 
v
;

24  
ue
;

25 
	}
}

	@src/main.cpp

1 
	~<iam
>

2 
	~<rg.h
>

3 
	~<comm.h
>

4 
	~<me_c.h
>

5 
	~<omci_rr.h
>

6 
	~<y.h
>

7 
	~<dio.h
>

8 
	~<dlib.h
>

9 
	~<unid.h
>

13 
UI32_T
 
	$g_ut_om_hex_rg
(*
rg
, 
UI8_T
 
ut_bys_cou
, *
ut_vue
)

15 
mp_xt
[10];

17 
	`memt
(
mp_xt
,0,(temp_text));

18 
ut_bys_cou
)

21 
	`ssnf
(
rg
,"%2c",
mp_xt
);

22 *(
UI8_T
*)
ut_vue
 = (UI8_T)
	`oul
(
mp_xt
, 
NULL
, 16);

25 
	`ssnf
(
rg
,"%4c",
mp_xt
);

26 *(
UI16_T
*)
ut_vue
 = (UI16_T)
	`oul
(
mp_xt
, 
NULL
, 16);

29 
	`ssnf
(
rg
,"%8c",
mp_xt
);

30 *(
UI32_T
*)
ut_vue
 = (UI32_T)
	`oul
(
mp_xt
, 
NULL
, 16);

35  (2 * 
ut_bys_cou
);

36 
	}
}

38 * 
	$g_xt_le
(
FILE
* 
put_
)

40 *
ad_buf
 = 0;

41 
UI32_T
 
leL
=0;

42 
I32_T
 
L
=0;

43 
OMCI_Pr
 
omci_p
;

45 (
L
 = 
	`gle
(&
ad_buf
,(
size_t
 *)&
leL
 ,
put_
)) != -1)

47 
UI8_T
 
omci_w
[256]={0};

48 
UI8_T
 
PC
;

49 
sizeofTe

	`
(
ad_buf
)/2;

51 
	`tf
("[%s]omcsizi%d\r\n", 
__MY_FILE__
, 
sizeofTe
);

53 * 
OMCI_pkt_hex_rg
 =
ad_buf
;

55 
i
 = 0; i < 
sizeofTe
; i++)

57 
OMCI_pkt_hex_rg
 +
	`g_ut_om_hex_rg
(OMCI_pkt_hex_rg,1,(*)&
PC
);

58 
	`tf
("%02X", 
PC
);

59 
omci_w
[
i
] = (
UI8_T
)
PC
;

61 
	`tf
("\r\n");

62 
omci_p
.
	`omci_pkt_rr
(
omci_w
, 
sizeofTe
);

63 
	`up
(1000*200);

64 
	`tf
("\r\n");

66  
ad_buf
;

67 
	}
}

71 
	$fm_ch_fo
()

73 
	`tf
("UI32_T sizi[%zu]\r\n", (
UI32_T
));

74 
	`tf
("UI16_T sizi[%zu]\r\n", (
UI16_T
));

75 
	`tf
("UI8_T sizi[%zu]\r\n", (
UI8_T
));

76 
	`tf
("BOOL_T sizi[%zu]\r\n", (
BOOL_T
));

77 
	}
}

79 
	$ma
(
gc
, *
gv
[])

81 
	`fm_ch_fo
();

82 
FILE
 *
OMCI_cmds_
;

83 
OMCI_Cmds_fame
[256];

85 if(
gc
 =2 && 
	`
(
gv
[1]) > 0)

87 
	`tf
("[%s]fame[%s]\r\n",
__MY_FILE__
, 
gv
[1]);

89 
	`rtf
(
OMCI_Cmds_fame
,"%s",
gv
[1]);

91 i((
OMCI_cmds_
 = 
	`fݒ
(
OMCI_Cmds_fame
, "r"))==
NULL
)

93 
	`tf
("[%s]Faedݒ fe: %f܄dg..",
__MY_FILE__
,
OMCI_Cmds_fame
);

98 *
omci_TEST
 = 
	`g_xt_le
(
OMCI_cmds_
);

99 
	`
(
omci_TEST
);

100 
	`fo
(
OMCI_cmds_
);

106 
OMCI_Pr
 
omci_p
;

107 
omci_p
.
	`omci_ay_back
();

111 
	}
}

	@src/me_c.cpp

1 
	~<ioam
>

2 
	~<fam
>

3 
	~<iam
>

4 
	~<dt.h
>

5 
	~<sys/tys.h
>

6 
	~<rg.h
>

7 
	~<tyfo
>

8 
	~<l_me.h
>

9 
	~<me_c.h
>

10 
	~<omci_rr.h
>

12 
	gME_C
::
	$ME_C
()

14 if(
	`g_omci_s
())

16 
	`tf
("[%s]g_omci_OK!!\r\n",
__MY_FILE__
);

17 if(!
	`e__me_obj
())

18 
	`tf
("[%s]e__me_obj NG!!\r\n",
__MY_FILE__
);

22 
	`tf
("[%s]g_omci_NG!!\r\n", 
__MY_FILE__
);

23 
	`tf
("[%s]###### SUPPORTED ME FILE ERROR #######!!!!\r\n", 
__MY_FILE__
);

25 
	}
}

27 
	gME_C
::~
	$ME_C
()

29 
	`a_l_me_obj
();

30 
	}
}

39 
BOOL_T
 
	gME_C
::
	$e__me_obj
()

41 
BOOL_T
 
s
=
l
;

42 
Js
::
Vue
 
Tvue
;

44 
	`tf
("[%s]e__me_obj ONT_DATA\r\n", 
__MY_FILE__
);

45 
Tvue
 = 
	`g_me_s_js
(
MECID_ONT_DATA
);

46 
s
 = 
	`_me_obj
(
MECID_ONT_DATA
, 0, 
Tvue
);

47  
s
;

48 
	}
}

50 
	gME_C
::
	$a_l_me_obj
()

52 
d
::
m
 < std::

<,>, 
ME_S
 *>::

 

;

53 aut

 = 
M_OMCI_P
.
	`beg
(); i!M_OMCI_P.
	`d
(); ++it)

55 
ME_S
 * 
pME_S
 = 

->
cd
;

56 if(
pME_S
)

58 
de
 
pME_S
;

61 
M_OMCI_P
.
	`r
();

62 
	}
}

64 
ME_S
 * 
	gME_C
::
	$g_me_obj
(
ass_id
, 
_id
)

66 
ME_S
 *
pTmp
 = 
NULL
;

67 
pTmp
 = 
M_OMCI_P
[
d
::
	`make_
(
ass_id
, 
_id
)];

68 if(!
pTmp
)

69  
NULL
;

71  
pTmp
;

72 
	}
}

79 
BOOL_T
 
	gME_C
::
	$_me_obj
(
ass_id
, 
_id
, 
Js
::
Vue
 
me_s
)

81 
ME_S
 *
pME
 = 
NULL
;

83 
	`tf
("[%s]Cmobje csid [%d] in id[%d] \r\n", 
__MY_FILE__
, 
ass_id
, 
_id
);

85 
pME
 = 
M_OMCI_P
[
d
::
	`make_
(
ass_id
, 
_id
)];

86 i(
pME
 =
NULL
)

88 
ass_id
)

91 
	`SWITCHCASE
(47 , 
_id
, 
ME_MAC_bridge_pt_cfiguti_da
, 
me_s
);

92 
	`SWITCHCASE
(11 , 
_id
, 
ME_Physil_th_rmi_pot_Etht_UNI
, 
me_s
);

93 
	`SWITCHCASE
(84 , 
_id
, 
ME_VLAN_ggg_fr_da
, 
me_s
);

94 
	`SWITCHCASE
(46 , 
_id
, 
ME_MAC_bridge_cfiguti_da
, 
me_s
);

95 
	`SWITCHCASE
(268 , 
_id
, 
ME_GEM_pt_twk_CTP
, 
me_s
);

96 
	`SWITCHCASE
(45 , 
_id
, 
ME_MAC_bridge_rvi_ofe
, 
me_s
);

97 
	`SWITCHCASE
(266 , 
_id
, 
ME_GEM_rwkg_rmi_pot
, 
me_s
);

98 
	`SWITCHCASE
(310 , 
_id
, 
ME_Mui_subsib_cfig_fo
, 
me_s
);

99 
	`SWITCHCASE
(262 , 
_id
, 
ME_T_CONT
, 
me_s
);

100 
	`SWITCHCASE
(309 , 
_id
, 
ME_Mui_ݔis_ofe
, 
me_s
);

101 
	`SWITCHCASE
(171 , 
_id
, 
ME_Exnded_VLAN_ggg_ݔi_cfiguti_da
, 
me_s
);

102 
	`SWITCHCASE
(2 , 
_id
, 
ME_ONT_da
, 
me_s
);

103 
	`SWITCHCASE
(130 , 
_id
, 
ME_802_1p_mr_rvi_ofe
, 
me_s
);

104 
	`SWITCHCASE
(281 , 
_id
, 
ME_Mui_GEM_rwkg_rmi_pot
, 
me_s
);

105 
	`SWITCHCASE
(272 , 
_id
, 
ME_GAL_Etht_ofe
, 
me_s
);

109  
ue
;

113 
	`tf
("[%s]A̗dyxi css_id [%d] in_id[%d]!!\r\n", 
__MY_FILE__
, 
ass_id
, 
_id
);

114  
l
;

116 
	}
}

123 
BOOL_T
 
	gME_C
::
	$g_omci_s
()

125 
d
::
rg
 
	`ME_S_DIR
(
ME_SEC_PATH
);

126 
dt
 *
y
;

128 
DIR
 *
d
 = 
	`ݒd
(
ME_S_DIR
.
	`c_r
());

130 i(
d
 =
NULL
)

132 
	`tf
("[%s]nsuchhxi!!\r\n", 
__MY_FILE__
);

133  
l
;

136 (
y
 = 
	`add
(
d
)!
NULL
)

138 
d
::
rg
 
	`d
(".");

139 
d
::
rg
 
	`dd
("..");

141 
d
::
rg
 
tmp_me_me
 = 
y
->
d_me
;

143 if((
d
 =
tmp_me_me
|| (
dd
 ==mp_me_name))

146 
d
::
rg
 
tmp_me_cid
 = 
tmp_me_me
.
	`subr
(0,mp_me_me.
	`fd
("_"));

147 
	`tf
("[%s]mme[%s] mcid[%s]\r\n", 
__MY_FILE__
, 
tmp_me_me
.
	`c_r
(), 
tmp_me_cid
.c_str());

149 
d
::
rg
 
m_cfig_fe_th
 = 
ME_S_DIR
 + 
tmp_me_me
 ;

150 
	`tf
("[%s]whme[%s]\r\n",
__MY_FILE__
, 
m_cfig_fe_th
.
	`c_r
());

152 
ifam
 
m_sour_fes
= {};

154 
m_sour_fes
.
	`ݒ
(
m_cfig_fe_th
);

156 if(
m_sour_fes
.
	`good
())

158 
Js
::
Vue
 
omci_s
;

159 
Js
::
Rd
 
ad
;

160 
BOOL_T
 
isJsOK
 = (
ad
.
	`r
(
m_sour_fes
, 
omci_s
));

162 if(
isJsOK
)

164 
	`tf
("[%s]G omci_ok \r\n", 
__MY_FILE__
);

165 
	`tf
("[%s]Csid:%d\r\n", 
__MY_FILE__
, 
omci_s
["Css"].
	`asI
());

166 
Css
 = 
omci_s
["Css"].
	`asI
();

167 
Id
 = 0;

168 
M_OMCI_G
[
d
::
	`make_
(
Css
,
Id
)]=
omci_s
;

169 
	`tf
("[%s]g vecٸsizi%zu\r\n",
__MY_FILE__
 ,
M_OMCI_G
.
	`size
());

173 
	`tf
("[%s]G omci_ng\r\n", 
__MY_FILE__
);

174  
l
;

179 
	`tf
("[%s]OfNG\r\n", 
__MY_FILE__
);

180  
l
;

184 
	`od
(
d
);

185  
ue
;

186 
	}
}

188 
	gJs
::
Vue
 
ME_C
::
	$g_me_s_js
(
UI16_T
 
Css
)

190 
Js
::
Vue
 
Tvue
;

191 
d
::
m
<d::

<,>, 
Js
::
Vue
>::
cڡ_
 

;

192 

 = 
M_OMCI_G
.
	`fd
(
d
::
	`make_
(
Css
, 0));

194 i(

 =
M_OMCI_G
.
	`d
())

196  
Tvue
;

200 
Tvue
 = 

->
cd
;

201  
Tvue
;

203 
	}
}

206 
BOOL_T
 
	gME_C
::
	$check_me_s_vid
(
UI16_T
 
Css
)

208 
d
::
m
<d::

<,>, 
Js
::
Vue
>::
cڡ_
 

;

209 

 = 
M_OMCI_G
.
	`fd
(
d
::
	`make_
(
Css
, 0));

211 i(

 =
M_OMCI_G
.
	`d
())

212  
l
;

214  
ue
;

215 
	}
}

217 
BOOL_T
 
	gME_C
::
	$check_me_o_vid
(
UI16_T
 
Css
, UI16_T 
_id
)

219 
	`tf
("[%s]check_me_o_vid Css[%d] in_id[%d]\r\n",
__MY_FILE__
 ,
Css
, 
_id
);

220 
d
::
m
<d::

<,>, 
ME_S
 *>::
cڡ_
 

;

221 

 = 
M_OMCI_P
.
	`fd
(
d
::
	`make_
(
Css
, 
_id
));

223 i(

 =
M_OMCI_P
.
	`d
())

224  
l
;

226  
ue
;

227 
	}
}

229 
BOOL_T
 
	gME_C
::
	$check_ai_vid
(
UI16_T
 
Css
, UI16_T 
Ai
)

231 
Js
::
Vue
 
omci_s
;

233 
omci_s
 = 
M_OMCI_G
[
d
::
	`make_
(
Css
, 0)];

235 
d
::
rg
 
ai

omci_s
["Su܋d_Ai"].
	`asSg
();

236 
d
::
rg
 
_ai
 = 
OMCI_Pr
::
	`g_omci_ai_me
(
Ai
);

238 
	`tf
("[%s]Css[%d] chki[%s][%d] su܈ai[%s][%d]\r\n",
__MY_FILE__
 , \

239 
Css
, 
_ai
.
	`c_r
(),
Ai
, 
ai
.c_r(), 
OMCI_Pr
::
	`g_omci_ai_id
("SET"));

241 if(
ai
.
	`fd
(""!
d
::
rg
::
os
 && (
Ai
 =
OMCI_Pr
::
	`g_omci_ai_id
("CREATE")))

243  
ue
;

245 if(
ai
.
	`fd
("de")!
d
::
rg
::
os
 && (
Ai
 =
OMCI_Pr
::
	`g_omci_ai_id
("DELETE")))

247  
ue
;

249 if(
ai
.
	`fd
("g")!
d
::
rg
::
os
 && (
Ai
 =
OMCI_Pr
::
	`g_omci_ai_id
("GET")))

251  
ue
;

253 if(
ai
.
	`fd
("t")!
d
::
rg
::
os
 && (
Ai
 =
OMCI_Pr
::
	`g_omci_ai_id
("SET")))

255  
ue
;

257 if(
ai
.
	`fd
("bo")!
d
::
rg
::
os
 && (
Ai
 =
OMCI_Pr
::
	`g_omci_ai_id
("SET")))

259  
ue
;

261 if(
ai
.
	`fd
("mibet")!
d
::
rg
::
os
 && (
Ai
 =
OMCI_Pr
::
	`g_omci_ai_id
("MIB_RESET")))

263  
ue
;

265 if(
ai
.
	`fd
("m")!
d
::
rg
::
os
 && (
Ai
 =
OMCI_Pr
::
	`g_omci_ai_id
("ALARM")))

267  
ue
;

270  
l
;

271 
	}
}

	@src/omci_parser.cpp

1 
	~<comm.h
>

2 
	~</.h
>

3 
	~<dio.h
>

4 
	~<rg.h
>

5 
	~<dio.h
>

6 
	~<oam
>

7 
	~<ioam
>

8 
	~<fam
>

9 
	~<iam
>

10 
	~<sys/time.h
>

11 
	~<dt.h
>

12 
	~<unid.h
>

13 
	~<omci_rr.h
>

16 
usg
 
mea
 
	gd
;

19 
	gOMCI_Pr
::
	$OMCI_Pr
()

21 
	`g_cfg
();

22 
	`g_omci_ayback_da
();

23 
	}
}

26 
	gOMCI_Pr
::
	$omci_ay_back
()

28 
UI16_T
 
i
 = 0;

29 
UI16_T
 
day
 = 0;

31 
UI16_T
 
key
 = 0;

35 
d
::
ve
<> 
dA
;

37 aut&
J
 : 
m_omci_ayback
)

39 
Js
::
Vue
 
ayback
 = 
J
.
cd
;

40 
t
 = 
ayback
["Ce_Time"].
	`asUI64
();

41 
dA
[
i
] = 
t
;

43 
i
++;

47 
	`up
(1000*200);

51 
i
 = 0; i < 
m_ayback_omci_num
 ; i++)

57 
Js
::
Vue
 
ayback
 = 
m_omci_ayback
[
i
];

58 
t1
 = 
ayback
["Ce_Time"].
	`asUI64
();

59 
	`tf
("t1[%u]\r\n", 
t1
);

60 
Js
::
Vue
 
ayback_xt
 = 
m_omci_ayback
[
i
+1];

62 if(
i
 !(
m_ayback_omci_num
 -1))

64 
t2
 = 
ayback_xt
["Ce_Time"].
	`asUI64
();

65 
	`tf
("t2[%u]\r\n", 
t2
);

66 
	`tf
("day[%u]\r\n", (
t2
-
t1
));

69 
	`tf
("w[%d][%s]\r\n",
i
, 
ayback
["Raw_Da"].
	`asSg
().
	`c_r
());

71 
	}
}

74 
	gOMCI_Pr
::
	$g_omci_ayback_da
()

76 if(
	`is_omci_ay_ab
())

78 
d
::
rg
 
	`ME_PLAYBACK_DIR
(
m_ayback_cfg
["OMCI_PLATBACK_FILE_PATH"].
	`asSg
());

79 
dt
 *
y
;

81 
DIR
 *
d
 = 
	`ݒd
(
ME_PLAYBACK_DIR
.
	`c_r
());

83 i(
d
 =
NULL
)

85 
	`tf
("[%s]nsuchh [%s]xi!!\r\n", 
__MY_FILE__
, 
ME_PLAYBACK_DIR
.
	`c_r
());

89 (
y
 = 
	`add
(
d
)!
NULL
)

91 
d
::
rg
 
	`d
(".");

92 
d
::
rg
 
	`dd
("..");

94 
d
::
rg
 
tmp_me_me
 = 
y
->
d_me
;

96 if((
d
 =
tmp_me_me
|| (
dd
 ==mp_me_name))

99 
d
::
rg
 
s_cid
 = 
tmp_me_me
.
	`subr
(0,mp_me_me.
	`fd
("_"));

100 
	`tf
("[%s]mme[%s] mcid[%s]\r\n", 
__MY_FILE__
, 
tmp_me_me
.
	`c_r
(), 
s_cid
.c_str());

102 
d
::
rg
 
m_cfig_fe_th
 = 
ME_PLAYBACK_DIR
 + 
tmp_me_me
 ;

103 
	`tf
("[%s]whme[%s]\r\n",
__MY_FILE__
, 
m_cfig_fe_th
.
	`c_r
());

105 
ifam
 
sour_fes
= {};

107 
sour_fes
.
	`ݒ
(
m_cfig_fe_th
);

109 if(
sour_fes
.
	`good
())

111 
Js
::
Vue
 
omci_s
;

112 
Js
::
Rd
 
ad
;

113 
BOOL_T
 
isJsOK
 = (
ad
.
	`r
(
sour_fes
, 
omci_s
));

115 if(
isJsOK
)

117 
	`tf
("[%s]Gyback omci_ok \r\n", 
__MY_FILE__
);

118 
	`tf
("[%s]Csid:%d\r\n", 
__MY_FILE__
, 
omci_s
["Css"].
	`asI
());

119 
Css
 = 
omci_s
["Css"].
	`asI
();

120 
m_omci_ayback
[
d
::
	`oi
(
s_cid
)]=
omci_s
;

121 
m_ayback_omci_num
++;

122 
	`tf
("[%s]m_ayback_omci_num sizi%zu\r\n",
__MY_FILE__
 ,
m_omci_ayback
.
	`size
());

126 
	`tf
("[%s]G omci_ng\r\n", 
__MY_FILE__
);

132 
	`tf
("[%s]OfNG\r\n", 
__MY_FILE__
);

136 
	`od
(
d
);

139 
	}
}

141 
	gOMCI_Pr
::
	$g_cfg
()

146 
ifam
 
m_sour_fes
= {};

147 
d
::
rg
 
t_th
 = 
PLAYBACK_CFG_NAME
;

149 
m_sour_fes
.
	`ݒ
(
t_th
);

151 if(
m_sour_fes
.
	`good
())

153 
Js
::
Rd
 
ad
;

154 
BOOL_T
 
isJsOK
 = (
ad
.
	`r
(
m_sour_fes
, 
m_ayback_cfg
));

156 if(
isJsOK
)

158 
	`tf
("[%s]G PyBack_Cfg OK \r\n", 
__MY_FILE__
);

159 
	`tf
("[%s]PLAYBACK Eb[%d]\r\n", 
__MY_FILE__
, 
m_ayback_cfg
["PLAYBACK"].
	`asI
());

160 
	`tf
("[%s]RECORD PLAYBACK Eb[%d]\r\n", 
__MY_FILE__
, 
m_ayback_cfg
["RECORD_PLAYBACK"].
	`asI
());

161 
	`tf
("[%s]OMCI_PLATBACK_FILE_PATH[%s]\r\n", 
__MY_FILE__
, 
m_ayback_cfg
["OMCI_PLATBACK_FILE_PATH"].
	`asSg
().
	`c_r
());

162 
	`tf
("[%s]OLT_PLATBACK_FILE_PATH[%s]\r\n", 
__MY_FILE__
, 
m_ayback_cfg
["OLT_PLATBACK_FILE_PATH"].
	`asSg
().
	`c_r
());

166 
	`tf
("[%s]G PyBack_Cfg NG, Check JSON fm !!!\r\n", 
__MY_FILE__
);

171 
	`tf
("[%s]OPyBack_Cfg NG\r\n", 
__MY_FILE__
);

178 if(
	`is_omci_log_ab
())

180 
d
::
rg
 
t_time
;

181 
d
::
y
<, 32> 
bufr
;

182 
time_t
 
wtime
;

183 
	`time
(&
wtime
);

184 cڡut
timefo
 = 
	`loime
(&
wtime
);

185 
	`rime
(
bufr
.
	`da
(), (bufr, "%Y_%m_%dT%H_%M_%S", 
timefo
);

186 
t_time
 = 
bufr
.
	`da
();

188 
m_log_out_th
="./E_OMCI_LOG/" + 
t_time
 + "/";

190 if
	`mkdp
(
m_log_out_th
.
	`c_r
(), 
DEFAULT_MODE
))

192 
	`tf
("[%s]Clog outh [%s] OK\r\b",
__MY_FILE__
, 
m_log_out_th
.
	`c_r
());

195 
	`tf
("[%s]Clog outh [%s] NG\r\b",
__MY_FILE__
, 
m_log_out_th
.
	`c_r
());

197 
	}
}

199 
BOOL_T
 
	gOMCI_Pr
::
	$omci_rr_vidxpkt
 (
UI8_T
 * 
pkt_p
)

201  
ue
;

202 
	}
}

204 
BOOL_T
 
	gOMCI_Pr
::
	$check_ai_vid
(
UI16_T
 
Css
, UI16_T 
Ai
)

206  
m_me
.
	`check_ai_vid
(
Css
, 
Ai
);

207 
	}
}

209 
BOOL_T
 
	gOMCI_Pr
::
	$check_me_ass_vid
(
UI16_T
 
Css
)

211  
m_me
.
	`check_me_s_vid
(
Css
);

212 
	}
}

214 
BOOL_T
 
	gOMCI_Pr
::
	$check_me__vid
(
UI16_T
 
Css
 ,UI16_T 
ME_ID
)

216  
m_me
.
	`check_me_o_vid
(
Css
, 
ME_ID
);

217 
	}
}

219 
BOOL_T
 
	gOMCI_Pr
::
	$is_omci_log_ab
()

221  
m_ayback_cfg
["RECORD_PLAYBACK"].
	`asBo
();

222 
	}
}

224 
BOOL_T
 
	gOMCI_Pr
::
	$is_omci_ay_ab
()

226  
m_ayback_cfg
["PLAYBACK"].
	`asBo
();

227 
	}
}

230 
BOOL_T
 
	gOMCI_Pr
::
	$me__
(
UI16_T
 
TnsID
 ,UI16_T 
Css
 ,UI16_T 
ME_ID
, 
UI8_T
 *
pkt_p
,UI8_T 
pkt_size
)

232 
UI8_T
 
i
 = 0;

233 
UI8_T
 
Ai
;

234 
UI16_T
 
Ars_mask
;

235 
timev
 
tv
, 
tv2
;

236 
t_utime
;

237 
	`gtimeofday
(&
tv
,
NULL
);

238 
t_utime
 = 
tv
.
tv_c
 * 1000000 +v.
tv_uc
;

240 
Ars_mask
 = 
	`g_omci_ui16
((
UI8_T
 *(
pkt_p
 + 
OFFSET_ArsMask
));

241 
Ai
 = (*(
pkt_p
 + 
OFFSET_OMCI_MSG_TYPE
)& 
OMCI_MSG_MT_MASK
;

243 
Js
::
Vue
 
omci_s

m_me
.
	`g_me_s_js
(
Css
);

244 
UI8_T
 
w_da
[128] ={0};

246 
i
 = 0; i < 
pkt_size
 ; i++)

248 
	`rtf
((*)&
w_da
[2*
i
],"%02X", *(
pkt_p
 + i));

251 
	`tf
("[%s]Create me instance Class[%d]Name[%s] instance_id [%d] size[%d] \r\n",\

252 
__MY_FILE__
,
Css
,
omci_s
["Name"].
	`asSg
().
	`c_r
(, 
ME_ID
, 
pkt_size
);

254 
d
::
rg
 
	`w
((*)
w_da
);

255 
omci_s
["Raw_Da"] = 
w
;

256 
omci_s
["TnsID"] = 
TnsID
;

257 
omci_s
["Id"] = 
ME_ID
;

258 
omci_s
["Cut_Ai"] = 
	`g_omci_ai_me
(
Ai
).
	`c_r
();

259 
omci_s
["Ce_Time"] = 
t_utime
;

261 
m_me
.
	`_me_obj
(
Css
, 
ME_ID
, 
omci_s
);

264 if(
	`is_omci_log_ab
())

266 
d
::
rg
 
fe_me
=d::
	`to_rg
(
TnsID
)+ "_" + std::to_rg(
Css
)+ "_" + std::to_rg(
ME_ID
+ "_" + 
omci_s
["Name"].
	`asSg
();

267 
d
::
ofam
 
	`ofe
(
m_log_out_th
 + 
fe_me
);

268 
ofe
 << 
omci_s
;

269 
ofe
.
	`o
();

271  
ue
;

272 
	}
}

275 
UI16_T
 
	gOMCI_Pr
::
	$g_omci_ui16
(
UI8_T
 *
da
)

277  
	`ohs
(*((
UI16_T
*)
da
));

278 
	}
}

280 
	gd
::
rg
 
OMCI_Pr
::
	$g_omci_ai_me
(
UI8_T
 
ai_ID
)

282 i(
ai_ID
 >
OMCI_ACTIONS_MAX_ID_PLUS_1
)

283 
ai_ID
 = 0;

285 
d
::
m
<
UI8_T
, std::
rg
>::
cڡ_
 

 ;

286 

 = 
g_ai_t
.
	`fd
(
ai_ID
);

287  

->
cd
;

288 
	}
}

290 
UI16_T
 
	gOMCI_Pr
::
	$g_omci_ai_id
(
d
::
rg
 
vue
)

292 
UI16_T
 
key
 = 0;

293 aut&
i
 : 
g_ai_t
) {

294 i(
i
.
cd
 =
vue
) {

295 
key
 = 
i
.
f
;

299  
key
;

300 
	}
}

302 
UI16_T
 
	gOMCI_Pr
::
	$omci_pkt_rr
(
UI8_T
 *
pkt_p
, UI8_T 
pkt_size
)

304 
UI8_T
 
omci_msg_cڋs
[256];

305 
UI8_T
 
dPkt
[
OMCI_PKT_SIZE
];

306 
UI8_T
 
Ai
;

307 
UI16_T
 
Css
;

308 
UI16_T
 
TnsID
;

309 
UI16_T
 
ME_ID
;

310 
UI16_T
 
Ars_mask
;

311 
BOOL_T
 
obj_exi
 = 
l
;

313 
	`tf
("[%s]OMCI_PKT_SIZE i%d\r\n",
__MY_FILE__
 , 
OMCI_PKT_SIZE
);

318 if(!
	`omci_rr_vidxpkt
(
pkt_p
))

322 
	`memy
(
dPkt
, 
pkt_p
, 
OMCI_PKT_SIZE
);

323 
	`memt
(
dPkt
 + 
OFFSET_RESP_RESULT
, 0, 
OFFSET_OMCI_TRAILER
 - OFFSET_RESP_RESULT);

324 
	`memy
(
omci_msg_cڋs
, 
pkt_p
 + 
OFFSET_OMCI_MSG_CONTENT
, 
OMCI_MSG_CONTENT_SIZE
);

326 
TnsID
 = 
	`g_omci_ui16
((
UI8_T
 *(
pkt_p
 + 
OFFSET_OMCI_TRANS_ID
));

327 
Css
 = 
	`g_omci_ui16
((
UI8_T
 *(
pkt_p
 + 
OFFSET_OMCI_CLASS_ID
));

328 
ME_ID
 = 
	`g_omci_ui16
((
UI8_T
 *(
pkt_p
 + 
OFFSET_OMCI_ME_ID
));

329 
Ars_mask
 = 
	`g_omci_ui16
((
UI8_T
 *(
pkt_p
 + 
OFFSET_ArsMask
));

334 
Ai
 = (*(
pkt_p
 + 
OFFSET_OMCI_MSG_TYPE
)& 
OMCI_MSG_MT_MASK
;

335 
	`tf
("[%s]ass[%d] ME_ID:[%d] Ai[%s][0x%04X]\n",
__MY_FILE__
, 
Css
, 
ME_ID
, 
	`g_omci_ai_me
(
Ai
).
	`c_r
(), Action);

337 if(
ME_ID
 =0 && 
Css
 !
MECID_ONT_DATA
)

339 
	`tf
("[%s]ME INSTANCE ID CAN'T BE 0 !!!!\r\n", 
__MY_FILE__
);

344 i((
Ai
 =
MSGTYPE_ATTRIBUTE_VALUE_CHANGE
|| (Ai =
MSGTYPE_ALARM
))

346 
	`tf
("[%s]MSGTYPE_ATTRIBUTE_VALUE_CHANGE MSGTYPE_ALARM!!!\r\n", 
__MY_FILE__
);

350 i((
Ai
 =
MSGTYPE_SET
|| (Ai =
MSGTYPE_GET
|| (Ai =
MSGTYPE_GET_CURRENT_DATA
))

352 
	`tf
("[%s]_mask: %04X\n", 
__MY_FILE__
, 
Ars_mask
);

359 i(!
	`check_me_ass_vid
(
Css
))

361 
	`tf
("[%s]NOT Su܋d ME (%d.Pa check iimimmsk\n",
__MY_FILE__
, 
Css
);

367 if!
	`check_ai_vid
(
Css
, 
Ai
) )

369 
	`tf
("[%s]ME[%d] su܈thiai[%d]!!\r\n",
__MY_FILE__
, 
Css
, 
Ai
);

373 
	`tf
("[%s]Su܈thiAi!\r\n",
__MY_FILE__
);

376 
obj_exi
 = 
	`check_me__vid
(
Css
 ,
ME_ID
);

377 i(!
obj_exi
 && (
Ai
 !
MSGTYPE_CREATE
))

379 
	`tf
("[%s]ME CLass[%d] in_ID NOTxi. cn [%s]\n",
__MY_FILE__
, 
Css
, 
	`g_omci_ai_me
(
Ai
).
	`c_r
());

382 if(
obj_exi
)

384 
	`tf
("[%s]ME [%d] in found. P %\n",
__MY_FILE__
 ,
Css
, 
	`g_omci_ai_me
(
Ai
).
	`c_r
());

392 
Ai
)

394 
MSGTYPE_CREATE
:

395 i(
obj_exi
)

397 
	`tf
("[%s]ME_ass(%d), ME in(%dexi, cn caga\n",
__MY_FILE__
 ,
Css
, 
ME_ID
);

400 
	`me__
(
TnsID
, 
Css
 , 
ME_ID
, 
pkt_p
, 
pkt_size
);

402 i(
Css
 =
MECID_VLAN_TAGGING_OP_CONFIG_DATA
)

404 
	`tf
("[%s]VTOCD!!!!!!\r\n", 
__MY_FILE__
);

406 i(
Css
 =
MECID_EXT_VLAN_TAGGING_OP_CONFIG_DATA
)

408 
	`tf
("[%s]E-VTOCD!!!!!!\r\n", 
__MY_FILE__
);

412 
MSGTYPE_DELETE
:

413 
	`tf
("[%s]MSGTYPE_DELETE!!!!!!\r\n", 
__MY_FILE__
);

416 
MSGTYPE_SET
:

417 
	`tf
("[%s]MSGTYPE_SET!!!!!!\r\n", 
__MY_FILE__
);

420 
MSGTYPE_GET
:

421 
MSGTYPE_GET_CURRENT_DATA
:

422 
	`tf
("[%s]MSGTYPE_GET!!!!!!\r\n", 
__MY_FILE__
);

425 
MSGTYPE_GET_NEXT
:

426 
	`tf
("[%s]MSGTYPE_GET_NEXT!!!!!!\r\n",
__MY_FILE__
);

436 
MSGTYPE_MIB_RESET
:

437 
	`me__
(
TnsID
, 
Css
 , 
ME_ID
, 
pkt_p
, 
pkt_size
);

438 
	`tf
("[%s]MSGTYPE_REBOOT!!!!!!\r\n",
__MY_FILE__
);

440 
MSGTYPE_GET_ALL_ALARMS
:

441 
MSGTYPE_GET_ALL_ALARMS_NEXT
:

442 
MSGTYPE_MIB_UPLOAD
:

443 
MSGTYPE_MIB_UPLOAD_NEXT
:

448 
MSGTYPE_TEST
:

455 
MSGTYPE_START_SOFTWARE_DOWNLOAD
:

456 
MSGTYPE_DOWNLOAD_SECTION
:

457 
MSGTYPE_END_SOFTWARE_DOWNLOAD
:

458 
MSGTYPE_ACTIVATE_SOFTWARE
:

459 
MSGTYPE_COMMIT_SOFTWARE
:

465 
MSGTYPE_SYNCHRONIZE_TIME
:

467 
MSGTYPE_REBOOT
:

468 
	`tf
("[%s]MSGTYPE_REBOOT!!!!!!\r\n",
__MY_FILE__
);

475 
MSGTYPE_ALARM
:

476 
MSGTYPE_ATTRIBUTE_VALUE_CHANGE
:

477 
MSGTYPE_TEST_RESULT
:

481 
	`tf
("[%s]Ieg mesgTy : %d", 
__MY_FILE__
, 
Ai
);

484 
	}
}

	@
1
.
0
91
3983
build/CMakeFiles/3.5.2/CompilerIdC/CMakeCCompilerId.c
build/CMakeFiles/3.5.2/CompilerIdCXX/CMakeCXXCompilerId.cpp
build/CMakeFiles/feature_tests.c
build/CMakeFiles/feature_tests.cxx
include/ME_802_1p_mapper_service_profile.hpp
include/ME_Extended_VLAN_tagging_operation_configuration_data.hpp
include/ME_GAL_Ethernet_profile.hpp
include/ME_GEM_interworking_termination_point.hpp
include/ME_GEM_port_network_CTP.hpp
include/ME_MAC_bridge_configuration_data.hpp
include/ME_MAC_bridge_port_configuration_data.hpp
include/ME_MAC_bridge_service_profile.hpp
include/ME_Multicast_GEM_interworking_termination_point.hpp
include/ME_Multicast_operations_profile.hpp
include/ME_Multicast_subscriber_config_info.hpp
include/ME_ONT_data.hpp
include/ME_Physical_path_termination_point_Ethernet_UNI.hpp
include/ME_T_CONT.hpp
include/ME_VLAN_tagging_filter_data.hpp
include/Temp.hpp
include/all_me.hpp
include/base_class.hpp
include/common.hpp
include/me_c.hpp
include/omci_parser.hpp
open_source/json-cxx/examples/example.cpp
open_source/json-cxx/examples/performance.cpp
open_source/json-cxx/include/json/deserializer.hpp
open_source/json-cxx/include/json/formatter.hpp
open_source/json-cxx/include/json/formatter/compact.hpp
open_source/json-cxx/include/json/formatter/pretty.hpp
open_source/json-cxx/include/json/iterator.hpp
open_source/json-cxx/include/json/json.hpp
open_source/json-cxx/include/json/number.hpp
open_source/json-cxx/include/json/serializer.hpp
open_source/json-cxx/include/json/value.hpp
open_source/json-cxx/include/json/writter.hpp
open_source/json-cxx/include/json/writter/counter.hpp
open_source/json-cxx/include/json/writter/string.hpp
open_source/json-cxx/src/deserializer.cpp
open_source/json-cxx/src/formatter.cpp
open_source/json-cxx/src/formatter/compact.cpp
open_source/json-cxx/src/formatter/pretty.cpp
open_source/json-cxx/src/iterator.cpp
open_source/json-cxx/src/number.cpp
open_source/json-cxx/src/serializer.cpp
open_source/json-cxx/src/value.cpp
open_source/json-cxx/src/writter.cpp
open_source/json-cxx/src/writter/counter.cpp
open_source/json-cxx/src/writter/string.cpp
open_source/json-cxx/tests/test_deserializer.cpp
open_source/json-cxx/tests/test_runner.cpp
open_source/jsoncpp-1.7.2.no-abi/include/json/allocator.h
open_source/jsoncpp-1.7.2.no-abi/include/json/assertions.h
open_source/jsoncpp-1.7.2.no-abi/include/json/autolink.h
open_source/jsoncpp-1.7.2.no-abi/include/json/config.h
open_source/jsoncpp-1.7.2.no-abi/include/json/features.h
open_source/jsoncpp-1.7.2.no-abi/include/json/forwards.h
open_source/jsoncpp-1.7.2.no-abi/include/json/json.h
open_source/jsoncpp-1.7.2.no-abi/include/json/reader.h
open_source/jsoncpp-1.7.2.no-abi/include/json/value.h
open_source/jsoncpp-1.7.2.no-abi/include/json/version.h
open_source/jsoncpp-1.7.2.no-abi/include/json/writer.h
open_source/jsoncpp-1.7.2.no-abi/src/jsontestrunner/main.cpp
open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_reader.cpp
open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_tool.h
open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_value.cpp
open_source/jsoncpp-1.7.2.no-abi/src/lib_json/json_writer.cpp
open_source/jsoncpp-1.7.2.no-abi/src/test_lib_json/jsontest.cpp
open_source/jsoncpp-1.7.2.no-abi/src/test_lib_json/jsontest.h
open_source/jsoncpp-1.7.2.no-abi/src/test_lib_json/main.cpp
src/ME_802_1p_mapper_service_profile.cpp
src/ME_Extended_VLAN_tagging_operation_configuration_data.cpp
src/ME_GAL_Ethernet_profile.cpp
src/ME_GEM_interworking_termination_point.cpp
src/ME_GEM_port_network_CTP.cpp
src/ME_MAC_bridge_configuration_data.cpp
src/ME_MAC_bridge_port_configuration_data.cpp
src/ME_MAC_bridge_service_profile.cpp
src/ME_Multicast_GEM_interworking_termination_point.cpp
src/ME_Multicast_operations_profile.cpp
src/ME_Multicast_subscriber_config_info.cpp
src/ME_ONT_data.cpp
src/ME_Physical_path_termination_point_Ethernet_UNI.cpp
src/ME_T_CONT.cpp
src/ME_VLAN_tagging_filter_data.cpp
src/base_class.cpp
src/common.cpp
src/main.cpp
src/me_c.cpp
src/omci_parser.cpp
